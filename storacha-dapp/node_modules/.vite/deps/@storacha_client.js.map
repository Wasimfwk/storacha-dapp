{
  "version": 3,
  "sources": ["../../@ucanto/interface/src/lib.js", "../../varint/encode.js", "../../varint/decode.js", "../../varint/length.js", "../../varint/index.js", "browser-external:crypto", "../../retry/lib/retry_operation.js", "../../retry/lib/retry.js", "../../retry/index.js", "../../@protobufjs/aspromise/index.js", "../../@protobufjs/base64/index.js", "../../@protobufjs/eventemitter/index.js", "../../@protobufjs/float/index.js", "../../@protobufjs/inquire/index.js", "../../@protobufjs/utf8/index.js", "../../@protobufjs/pool/index.js", "../../protobufjs/src/util/longbits.js", "../../protobufjs/src/util/minimal.js", "../../protobufjs/src/writer.js", "../../protobufjs/src/writer_buffer.js", "../../protobufjs/src/reader.js", "../../protobufjs/src/reader_buffer.js", "../../protobufjs/src/rpc/service.js", "../../protobufjs/src/rpc.js", "../../protobufjs/src/roots.js", "../../protobufjs/src/index-minimal.js", "../../protobufjs/minimal.js", "../../murmurhash3js-revisited/lib/murmurHash3js.js", "../../murmurhash3js-revisited/index.js", "../../@storacha/access/dist/agent.js", "../../@ucanto/client/src/lib.js", "../../@ucanto/client/src/connection.js", "../../@ucanto/core/src/lib.js", "../../@ucanto/core/src/delegation.js", "../../@ipld/dag-ucan/src/lib.js", "../../cborg/lib/is.js", "../../cborg/lib/token.js", "../../cborg/lib/byte-utils.js", "../../cborg/lib/bl.js", "../../cborg/lib/common.js", "../../cborg/lib/0uint.js", "../../cborg/lib/1negint.js", "../../cborg/lib/2bytes.js", "../../cborg/lib/3string.js", "../../cborg/lib/4array.js", "../../cborg/lib/5map.js", "../../cborg/lib/6tag.js", "../../cborg/lib/7float.js", "../../cborg/lib/jump.js", "../../cborg/lib/encode.js", "../../cborg/lib/decode.js", "../../multiformats/src/bases/base32.ts", "../../multiformats/src/bytes.ts", "../../multiformats/src/vendor/base-x.js", "../../multiformats/src/bases/base.ts", "../../multiformats/src/bases/base36.ts", "../../multiformats/src/bases/base58.ts", "../../multiformats/src/varint.ts", "../../multiformats/src/vendor/varint.js", "../../multiformats/src/hashes/digest.ts", "../../multiformats/src/cid.ts", "../../@ipld/dag-cbor/src/index.js", "../../@ipld/dag-ucan/src/utf8.js", "../../multiformats/src/link.ts", "../../multiformats/src/hashes/identity.ts", "../../@ipld/dag-ucan/src/did.js", "../../multiformats/src/hashes/hasher.ts", "../../multiformats/src/codecs/raw.ts", "../../@ipld/dag-ucan/src/signature.js", "../../multiformats/src/bases/base64.ts", "../../@ipld/dag-ucan/src/schema.js", "../../cborg/lib/json/encode.js", "../../cborg/lib/json/decode.js", "../../@ipld/dag-json/src/index.js", "../../@ipld/dag-ucan/src/formatter.js", "../../@ipld/dag-ucan/src/view.js", "../../@ipld/dag-ucan/src/codec/cbor.js", "../../@ipld/dag-ucan/src/parser.js", "../../@ipld/dag-ucan/src/codec/jwt.js", "../../multiformats/src/hashes/sha2-browser.ts", "../../@ucanto/core/src/dag.js", "../../@ucanto/core/src/cbor.js", "../../@ucanto/core/src/car.js", "../../@ipld/car/src/decoder-common.js", "../../@ipld/car/src/header-validator.js", "../../@ipld/car/src/buffer-decoder.js", "../../@ipld/car/src/buffer-reader-browser.js", "../../cborg/lib/length.js", "../../@ipld/car/src/buffer-writer.js", "../../@ucanto/core/src/schema.js", "../../@ucanto/core/src/schema/uri.js", "../../@ucanto/core/src/result.js", "../../@ucanto/core/src/schema/schema.js", "../../@ucanto/core/src/schema/link.js", "../../@ucanto/core/src/schema/principal.js", "../../@ucanto/core/src/schema/did.js", "../../@ucanto/core/src/schema/text.js", "../../@ucanto/core/src/invocation.js", "../../@ucanto/core/src/message.js", "../../@ucanto/core/src/receipt.js", "../../@ucanto/transport/src/car.js", "../../@ucanto/transport/src/car/request.js", "../../@ucanto/transport/src/car/response.js", "../../@ucanto/transport/src/codec.js", "../../@ucanto/transport/src/http.js", "../../@storacha/capabilities/dist/space.js", "../../@storacha/capabilities/dist/store.js", "../../@ucanto/validator/src/lib.js", "../../@ucanto/validator/src/capability.js", "../../@ucanto/validator/src/util.js", "../../@ucanto/validator/src/error.js", "../../@ucanto/validator/src/authorization.js", "../../@storacha/capabilities/dist/utils.js", "../../@storacha/capabilities/dist/upload.js", "../../@storacha/capabilities/dist/top.js", "../../@storacha/capabilities/dist/ucan.js", "../../@storacha/access/dist/access.js", "../../@storacha/capabilities/dist/access.js", "../../@storacha/access/dist/types.js", "../../@storacha/did-mailto/dist/index.js", "../../uint8arrays/src/equals.ts", "../../uint8arrays/src/alloc.ts", "../../uint8arrays/src/util/as-uint8array.ts", "../../uint8arrays/src/compare.ts", "../../uint8arrays/src/concat.ts", "../../multiformats/src/bases/base10.ts", "../../multiformats/src/bases/base16.ts", "../../multiformats/src/bases/base2.ts", "../../multiformats/src/bases/base256emoji.ts", "../../multiformats/src/bases/base8.ts", "../../multiformats/src/bases/identity.ts", "../../multiformats/src/codecs/json.ts", "../../multiformats/src/basics.ts", "../../uint8arrays/src/util/bases.ts", "../../@storacha/access/dist/encoding.js", "../../@storacha/access/dist/space.js", "../../@ucanto/principal/src/ed25519.js", "../../@ucanto/principal/src/ed25519/signer.js", "../../@noble/ed25519/lib/esm/index.js", "../../@ucanto/principal/src/ed25519/verifier.js", "../../@ucanto/principal/src/verifier.js", "../../@ucanto/principal/src/signer.js", "../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/hmac.ts", "../../@noble/hashes/src/_md.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/sha2.ts", "../../@scure/base/index.ts", "../../@scure/bip39/esm/index.js", "../../@scure/bip39/esm/wordlists/english.js", "../../@storacha/capabilities/dist/provider.js", "../../@storacha/access/dist/provider.js", "../../@storacha/access/dist/space-access.js", "../../@storacha/access/dist/delegations.js", "../../@ucanto/principal/src/rsa.js", "../../one-webcrypto/browser.mjs", "../../@ucanto/principal/src/multiformat.js", "../../@ucanto/principal/src/rsa/spki.js", "../../@ucanto/principal/src/rsa/asn1.js", "../../@ucanto/principal/src/rsa/pkcs8.js", "../../@ucanto/principal/src/rsa/private-key.js", "../../@ucanto/principal/src/rsa/public-key.js", "../../@ucanto/principal/src/lib.js", "../../@storacha/access/dist/agent-data.js", "../../@storacha/capabilities/dist/assert.js", "../../@storacha/capabilities/dist/claim.js", "../../@storacha/capabilities/dist/consumer.js", "../../@storacha/capabilities/dist/customer.js", "../../@storacha/capabilities/dist/console.js", "../../@storacha/capabilities/dist/rate-limit.js", "../../@storacha/capabilities/dist/admin.js", "../../@storacha/capabilities/dist/subscription.js", "../../@storacha/capabilities/dist/filecoin/index.js", "../../@storacha/capabilities/dist/filecoin/lib.js", "../../@storacha/capabilities/dist/filecoin/storefront.js", "../../@storacha/capabilities/dist/filecoin/aggregator.js", "../../@storacha/capabilities/dist/filecoin/dealer.js", "../../@storacha/capabilities/dist/filecoin/deal-tracker.js", "../../@storacha/capabilities/dist/space/index.js", "../../@storacha/capabilities/dist/plan.js", "../../@storacha/capabilities/dist/usage.js", "../../@storacha/capabilities/dist/space/blob.js", "../../@storacha/capabilities/dist/blob/index.js", "../../@storacha/capabilities/dist/web3.storage/blob.js", "../../@storacha/capabilities/dist/http.js", "../../@storacha/capabilities/dist/account/usage.js", "../../@storacha/capabilities/dist/index.js", "../../@storacha/access/dist/utils/buffers.js", "../../@storacha/access/dist/agent-use-cases.js", "../../p-defer/index.js", "../../@storacha/access/dist/drivers/indexeddb.js", "../../@storacha/access/dist/stores/store-indexeddb.js", "../../@web3-storage/data-segment/src/multihash.js", "../../@web3-storage/data-segment/src/constant.js", "../../@web3-storage/data-segment/src/node.js", "../../@web3-storage/data-segment/src/ipld/sha256.js", "../../@noble/hashes/src/sha256.ts", "../../sync-multihash-sha2/src/sha256/digest.js", "../../sync-multihash-sha2/src/sha256/web.js", "../../@web3-storage/data-segment/src/proof.js", "../../@web3-storage/data-segment/src/zero-comm.js", "../../@web3-storage/data-segment/src/piece/tree.js", "../../@web3-storage/data-segment/src/fr32.js", "../../@web3-storage/data-segment/src/uint64.js", "../../@web3-storage/data-segment/src/piece/size/padded.js", "../../@web3-storage/data-segment/src/piece/size/unpadded.js", "../../@web3-storage/data-segment/src/piece/size/expanded.js", "../../@web3-storage/data-segment/src/digest.js", "../../@storacha/filecoin-client/dist/storefront.js", "../../@ucanto/transport/src/utf8.js", "../../@ucanto/transport/src/legacy/response.js", "../../@ucanto/transport/src/legacy/request.js", "../../@ucanto/transport/src/legacy.js", "../../@storacha/filecoin-client/dist/service.js", "../../@storacha/filecoin-client/dist/aggregator.js", "../../@storacha/filecoin-client/dist/dealer.js", "../../@storacha/filecoin-client/dist/deal-tracker.js", "../../@storacha/upload-client/dist/blob/index.js", "../../p-retry/index.js", "../../@storacha/upload-client/dist/service.js", "../../@storacha/upload-client/dist/constants.js", "../../@storacha/upload-client/dist/receipts.js", "../../@storacha/upload-client/dist/runtime.js", "../../@storacha/upload-client/dist/blob/add.js", "../../@storacha/upload-client/dist/blob/get.js", "../../@storacha/upload-client/dist/blob/list.js", "../../@storacha/upload-client/dist/blob/remove.js", "../../@storacha/upload-client/dist/blob/replicate.js", "../../@storacha/upload-client/dist/index/index.js", "../../@storacha/upload-client/dist/index/add.js", "../../@storacha/upload-client/dist/upload/index.js", "../../@storacha/upload-client/dist/upload/add.js", "../../@storacha/upload-client/dist/upload/get.js", "../../@storacha/upload-client/dist/upload/list.js", "../../@storacha/upload-client/dist/upload/remove.js", "../../@ipld/unixfs/src/codec.js", "../../@ipld/dag-pb/src/pb-decode.js", "../../@ipld/dag-pb/src/pb-encode.js", "../../@ipld/dag-pb/src/util.js", "../../@ipld/dag-pb/src/index.js", "../../@ipld/unixfs/gen/unixfs.js", "../../@ipld/unixfs/src/unixfs.js", "../../actor/src/lib.js", "../../@ipld/unixfs/src/file/chunker/indexed.js", "../../@ipld/unixfs/src/file/chunker/buffer.js", "../../@ipld/unixfs/src/writer/util.js", "../../@ipld/unixfs/src/file/chunker.js", "../../@ipld/unixfs/src/file/layout/queue.js", "../../@ipld/unixfs/src/file/writer.js", "../../@ipld/unixfs/src/file/chunker/fixed.js", "../../@ipld/unixfs/src/file/layout/balanced.js", "../../@ipld/unixfs/src/file.js", "../../@ipld/unixfs/src/directory.js", "../../@perma/map/src/bitfield/Uint32.js", "../../@perma/map/src/bitfield/api.js", "../../@perma/map/src/path/Uint32.js", "../../@perma/map/src/node.js", "../../@multiformats/murmur3/src/index.js", "../../@perma/map/src/path/Uint8Array.js", "../../@perma/map/src/bitfield/Uint8Array.js", "../../@perma/map/src/lib.js", "../../@perma/map/src/path/InfiniteUint8Array.js", "../../@perma/map/src/unixfs.js", "../../multiformats/src/block.ts", "../../@ipld/unixfs/src/sharded-directory.js", "../../@ipld/unixfs/src/lib.js", "../../@storacha/upload-client/dist/unixfs.js", "../../@ipld/car/src/decoder.js", "../../@ipld/car/src/iterator.js", "../../@ipld/car/src/encoder.js", "../../@ipld/car/src/iterator-channel.js", "../../@ipld/car/src/writer-browser.js", "../../@storacha/upload-client/dist/car.js", "../../@storacha/upload-client/dist/deduplication.js", "../../@storacha/blob-index/dist/sharded-dag-index.js", "../../@storacha/blob-index/dist/digest-map.js", "../../uint8arraylist/src/index.ts", "../../carstream/src/varint.js", "../../carstream/src/reader.js", "../../carstream/src/writer.js", "../../@storacha/blob-index/dist/util.js", "../../@storacha/upload-client/dist/sharding.js", "../../@storacha/upload-client/dist/index.js", "../../environment/index.js", "../../@storacha/client/dist/service.js", "../../@storacha/client/dist/base.js", "../../@storacha/client/dist/account.js", "../../@storacha/client/dist/types.js", "../../@storacha/client/dist/result.js", "../../@storacha/client/dist/capability/access.js", "../../@storacha/client/dist/capability/plan.js", "../../@storacha/client/dist/capability/subscription.js", "../../@storacha/client/dist/capability/usage.js", "../../@storacha/client/dist/space.js", "../../@storacha/client/dist/delegation.js", "../../@storacha/client/dist/capability/blob.js", "../../@storacha/client/dist/capability/index.js", "../../@storacha/client/dist/capability/upload.js", "../../@storacha/client/dist/capability/space.js", "../../@storacha/client/dist/capability/account/usage.js", "../../@storacha/client/dist/capability/filecoin.js", "../../@storacha/client/dist/coupon.js", "../../@storacha/client/dist/client.js", "../../@storacha/client/dist/ability.js", "../../@storacha/client/dist/index.js"],
  "sourcesContent": ["", "module.exports = encode\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31)\n\nfunction encode(num, out, offset) {\n  if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {\n    encode.bytes = 0\n    throw new RangeError('Could not encode varint')\n  }\n  out = out || []\n  offset = offset || 0\n  var oldOffset = offset\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n  \n  encode.bytes = offset - oldOffset + 1\n  \n  return out\n}\n", "module.exports = read\n\nvar MSB = 0x80\n  , REST = 0x7F\n\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) {\n      read.bytes = 0\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++]\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  read.bytes = counter - offset\n\n  return res\n}\n", "\nvar N1 = Math.pow(2,  7)\nvar N2 = Math.pow(2, 14)\nvar N3 = Math.pow(2, 21)\nvar N4 = Math.pow(2, 28)\nvar N5 = Math.pow(2, 35)\nvar N6 = Math.pow(2, 42)\nvar N7 = Math.pow(2, 49)\nvar N8 = Math.pow(2, 56)\nvar N9 = Math.pow(2, 63)\n\nmodule.exports = function (value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n}\n", "module.exports = {\n    encode: require('./encode.js')\n  , decode: require('./decode.js')\n  , encodingLength: require('./length.js')\n}\n", "module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"crypto\" has been externalized for browser compatibility. Cannot access \"crypto.${key}\" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "function RetryOperation(timeouts, options) {\n  // Compatibility for the old (timeouts, retryForever) signature\n  if (typeof options === 'boolean') {\n    options = { forever: options };\n  }\n\n  this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));\n  this._timeouts = timeouts;\n  this._options = options || {};\n  this._maxRetryTime = options && options.maxRetryTime || Infinity;\n  this._fn = null;\n  this._errors = [];\n  this._attempts = 1;\n  this._operationTimeout = null;\n  this._operationTimeoutCb = null;\n  this._timeout = null;\n  this._operationStart = null;\n  this._timer = null;\n\n  if (this._options.forever) {\n    this._cachedTimeouts = this._timeouts.slice(0);\n  }\n}\nmodule.exports = RetryOperation;\n\nRetryOperation.prototype.reset = function() {\n  this._attempts = 1;\n  this._timeouts = this._originalTimeouts.slice(0);\n}\n\nRetryOperation.prototype.stop = function() {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n  if (this._timer) {\n    clearTimeout(this._timer);\n  }\n\n  this._timeouts       = [];\n  this._cachedTimeouts = null;\n};\n\nRetryOperation.prototype.retry = function(err) {\n  if (this._timeout) {\n    clearTimeout(this._timeout);\n  }\n\n  if (!err) {\n    return false;\n  }\n  var currentTime = new Date().getTime();\n  if (err && currentTime - this._operationStart >= this._maxRetryTime) {\n    this._errors.push(err);\n    this._errors.unshift(new Error('RetryOperation timeout occurred'));\n    return false;\n  }\n\n  this._errors.push(err);\n\n  var timeout = this._timeouts.shift();\n  if (timeout === undefined) {\n    if (this._cachedTimeouts) {\n      // retry forever, only keep last error\n      this._errors.splice(0, this._errors.length - 1);\n      timeout = this._cachedTimeouts.slice(-1);\n    } else {\n      return false;\n    }\n  }\n\n  var self = this;\n  this._timer = setTimeout(function() {\n    self._attempts++;\n\n    if (self._operationTimeoutCb) {\n      self._timeout = setTimeout(function() {\n        self._operationTimeoutCb(self._attempts);\n      }, self._operationTimeout);\n\n      if (self._options.unref) {\n          self._timeout.unref();\n      }\n    }\n\n    self._fn(self._attempts);\n  }, timeout);\n\n  if (this._options.unref) {\n      this._timer.unref();\n  }\n\n  return true;\n};\n\nRetryOperation.prototype.attempt = function(fn, timeoutOps) {\n  this._fn = fn;\n\n  if (timeoutOps) {\n    if (timeoutOps.timeout) {\n      this._operationTimeout = timeoutOps.timeout;\n    }\n    if (timeoutOps.cb) {\n      this._operationTimeoutCb = timeoutOps.cb;\n    }\n  }\n\n  var self = this;\n  if (this._operationTimeoutCb) {\n    this._timeout = setTimeout(function() {\n      self._operationTimeoutCb();\n    }, self._operationTimeout);\n  }\n\n  this._operationStart = new Date().getTime();\n\n  this._fn(this._attempts);\n};\n\nRetryOperation.prototype.try = function(fn) {\n  console.log('Using RetryOperation.try() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = function(fn) {\n  console.log('Using RetryOperation.start() is deprecated');\n  this.attempt(fn);\n};\n\nRetryOperation.prototype.start = RetryOperation.prototype.try;\n\nRetryOperation.prototype.errors = function() {\n  return this._errors;\n};\n\nRetryOperation.prototype.attempts = function() {\n  return this._attempts;\n};\n\nRetryOperation.prototype.mainError = function() {\n  if (this._errors.length === 0) {\n    return null;\n  }\n\n  var counts = {};\n  var mainError = null;\n  var mainErrorCount = 0;\n\n  for (var i = 0; i < this._errors.length; i++) {\n    var error = this._errors[i];\n    var message = error.message;\n    var count = (counts[message] || 0) + 1;\n\n    counts[message] = count;\n\n    if (count >= mainErrorCount) {\n      mainError = error;\n      mainErrorCount = count;\n    }\n  }\n\n  return mainError;\n};\n", "var RetryOperation = require('./retry_operation');\n\nexports.operation = function(options) {\n  var timeouts = exports.timeouts(options);\n  return new RetryOperation(timeouts, {\n      forever: options && (options.forever || options.retries === Infinity),\n      unref: options && options.unref,\n      maxRetryTime: options && options.maxRetryTime\n  });\n};\n\nexports.timeouts = function(options) {\n  if (options instanceof Array) {\n    return [].concat(options);\n  }\n\n  var opts = {\n    retries: 10,\n    factor: 2,\n    minTimeout: 1 * 1000,\n    maxTimeout: Infinity,\n    randomize: false\n  };\n  for (var key in options) {\n    opts[key] = options[key];\n  }\n\n  if (opts.minTimeout > opts.maxTimeout) {\n    throw new Error('minTimeout is greater than maxTimeout');\n  }\n\n  var timeouts = [];\n  for (var i = 0; i < opts.retries; i++) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  if (options && options.forever && !timeouts.length) {\n    timeouts.push(this.createTimeout(i, opts));\n  }\n\n  // sort the array numerically ascending\n  timeouts.sort(function(a,b) {\n    return a - b;\n  });\n\n  return timeouts;\n};\n\nexports.createTimeout = function(attempt, opts) {\n  var random = (opts.randomize)\n    ? (Math.random() + 1)\n    : 1;\n\n  var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));\n  timeout = Math.min(timeout, opts.maxTimeout);\n\n  return timeout;\n};\n\nexports.wrap = function(obj, options, methods) {\n  if (options instanceof Array) {\n    methods = options;\n    options = null;\n  }\n\n  if (!methods) {\n    methods = [];\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        methods.push(key);\n      }\n    }\n  }\n\n  for (var i = 0; i < methods.length; i++) {\n    var method   = methods[i];\n    var original = obj[method];\n\n    obj[method] = function retryWrapper(original) {\n      var op       = exports.operation(options);\n      var args     = Array.prototype.slice.call(arguments, 1);\n      var callback = args.pop();\n\n      args.push(function(err) {\n        if (op.retry(err)) {\n          return;\n        }\n        if (err) {\n          arguments[0] = op.mainError();\n        }\n        callback.apply(this, arguments);\n      });\n\n      op.attempt(function() {\n        original.apply(obj, args);\n      });\n    }.bind(obj, original);\n    obj[method].options = options;\n  }\n};\n", "module.exports = require('./lib/retry');", "\"use strict\";\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n", "\"use strict\";\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n", "\"use strict\";\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n", "\"use strict\";\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n", "\"use strict\";\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n", "\"use strict\";\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n", "\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n", "\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n", "\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n", "\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n", "\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n", "\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n", "\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n", "\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n", "\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n", "\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n", "// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n", "/* jshint -W086: true */\n// +----------------------------------------------------------------------+\n// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js\n// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |\n// |----------------------------------------------------------------------|\n// | Copyright (c) 2012-2015 Karan Lyons                                       |\n// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |\n// | Freely distributable under the MIT license.                          |\n// +----------------------------------------------------------------------+\n\n;(function (root, undefined) {\n    'use strict';\n\n    // Create a local object that'll be exported or referenced globally.\n    var library = {\n        'version': '3.0.0',\n        'x86': {},\n        'x64': {},\n        'inputValidation': true\n    };\n\n    // PRIVATE FUNCTIONS\n    // -----------------\n\n    function _validBytes(bytes) {\n        // check the input is an array or a typed array\n        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {\n            return false;\n        }\n\n        // check all bytes are actually bytes\n        for (var i = 0; i < bytes.length; i++) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function _x86Multiply(m, n) {\n        //\n        // Given two 32bit ints, returns the two multiplied together as a\n        // 32bit int.\n        //\n\n        return ((m & 0xffff) * n) + ((((m >>> 16) * n) & 0xffff) << 16);\n    }\n\n    function _x86Rotl(m, n) {\n        //\n        // Given a 32bit int and an int representing a number of bit positions,\n        // returns the 32bit int rotated left by that number of positions.\n        //\n\n        return (m << n) | (m >>> (32 - n));\n    }\n\n    function _x86Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x86 mix of that block.\n        //\n\n        h ^= h >>> 16;\n        h = _x86Multiply(h, 0x85ebca6b);\n        h ^= h >>> 13;\n        h = _x86Multiply(h, 0xc2b2ae35);\n        h ^= h >>> 16;\n\n        return h;\n    }\n\n    function _x64Add(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // added together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] + n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] + n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] + n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += m[0] + n[0];\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Multiply(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // multiplied together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        m = [m[0] >>> 16, m[0] & 0xffff, m[1] >>> 16, m[1] & 0xffff];\n        n = [n[0] >>> 16, n[0] & 0xffff, n[1] >>> 16, n[1] & 0xffff];\n        var o = [0, 0, 0, 0];\n\n        o[3] += m[3] * n[3];\n        o[2] += o[3] >>> 16;\n        o[3] &= 0xffff;\n\n        o[2] += m[2] * n[3];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[2] += m[3] * n[2];\n        o[1] += o[2] >>> 16;\n        o[2] &= 0xffff;\n\n        o[1] += m[1] * n[3];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[2] * n[2];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[1] += m[3] * n[1];\n        o[0] += o[1] >>> 16;\n        o[1] &= 0xffff;\n\n        o[0] += (m[0] * n[3]) + (m[1] * n[2]) + (m[2] * n[1]) + (m[3] * n[0]);\n        o[0] &= 0xffff;\n\n        return [(o[0] << 16) | o[1], (o[2] << 16) | o[3]];\n    }\n\n    function _x64Rotl(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) rotated left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 32) {\n            return [m[1], m[0]];\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), (m[1] << n) | (m[0] >>> (32 - n))];\n        } else {\n            n -= 32;\n            return [(m[1] << n) | (m[0] >>> (32 - n)), (m[0] << n) | (m[1] >>> (32 - n))];\n        }\n    }\n\n    function _x64LeftShift(m, n) {\n        //\n        // Given a 64bit int (as an array of two 32bit ints) and an int\n        // representing a number of bit positions, returns the 64bit int (as an\n        // array of two 32bit ints) shifted left by that number of positions.\n        //\n\n        n %= 64;\n\n        if (n === 0) {\n            return m;\n        } else if (n < 32) {\n            return [(m[0] << n) | (m[1] >>> (32 - n)), m[1] << n];\n        } else {\n            return [m[1] << (n - 32), 0];\n        }\n    }\n\n    function _x64Xor(m, n) {\n        //\n        // Given two 64bit ints (as an array of two 32bit ints) returns the two\n        // xored together as a 64bit int (as an array of two 32bit ints).\n        //\n\n        return [m[0] ^ n[0], m[1] ^ n[1]];\n    }\n\n    function _x64Fmix(h) {\n        //\n        // Given a block, returns murmurHash3's final x64 mix of that block.\n        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the\n        // only place where we need to right shift 64bit ints.)\n        //\n\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xff51afd7, 0xed558ccd]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n        h = _x64Multiply(h, [0xc4ceb9fe, 0x1a85ec53]);\n        h = _x64Xor(h, [0, h[0] >>> 1]);\n\n        return h;\n    }\n\n    // PUBLIC FUNCTIONS\n    // ----------------\n\n    library.x86.hash32 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 32 bit hash\n        // using the x86 flavor of MurmurHash3, as an unsigned int.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 4;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n\n        var k1 = 0;\n\n        var c1 = 0xcc9e2d51;\n        var c2 = 0x1b873593;\n\n        for (var i = 0; i < blocks; i = i + 4) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n\n            h1 ^= k1;\n            h1 = _x86Rotl(h1, 13);\n            h1 = _x86Multiply(h1, 5) + 0xe6546b64;\n        }\n\n        k1 = 0;\n\n        switch (remainder) {\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h1 = _x86Fmix(h1);\n\n        return h1 >>> 0;\n    };\n\n    library.x86.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n\n        seed = seed || 0;\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = seed;\n        var h2 = seed;\n        var h3 = seed;\n        var h4 = seed;\n\n        var k1 = 0;\n        var k2 = 0;\n        var k3 = 0;\n        var k4 = 0;\n\n        var c1 = 0x239b961b;\n        var c2 = 0xab0e9789;\n        var c3 = 0x38b34ae5;\n        var c4 = 0xa1e38b93;\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = (bytes[i]) | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);\n            k2 = (bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24);\n            k3 = (bytes[i + 8]) | (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24);\n            k4 = (bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24);\n\n            k1 = _x86Multiply(k1, c1);\n            k1 = _x86Rotl(k1, 15);\n            k1 = _x86Multiply(k1, c2);\n            h1 ^= k1;\n\n            h1 = _x86Rotl(h1, 19);\n            h1 += h2;\n            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;\n\n            k2 = _x86Multiply(k2, c2);\n            k2 = _x86Rotl(k2, 16);\n            k2 = _x86Multiply(k2, c3);\n            h2 ^= k2;\n\n            h2 = _x86Rotl(h2, 17);\n            h2 += h3;\n            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;\n\n            k3 = _x86Multiply(k3, c3);\n            k3 = _x86Rotl(k3, 17);\n            k3 = _x86Multiply(k3, c4);\n            h3 ^= k3;\n\n            h3 = _x86Rotl(h3, 15);\n            h3 += h4;\n            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;\n\n            k4 = _x86Multiply(k4, c4);\n            k4 = _x86Rotl(k4, 18);\n            k4 = _x86Multiply(k4, c1);\n            h4 ^= k4;\n\n            h4 = _x86Rotl(h4, 13);\n            h4 += h1;\n            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;\n        }\n\n        k1 = 0;\n        k2 = 0;\n        k3 = 0;\n        k4 = 0;\n\n        switch (remainder) {\n            case 15:\n                k4 ^= bytes[i + 14] << 16;\n\n            case 14:\n                k4 ^= bytes[i + 13] << 8;\n\n            case 13:\n                k4 ^= bytes[i + 12];\n                k4 = _x86Multiply(k4, c4);\n                k4 = _x86Rotl(k4, 18);\n                k4 = _x86Multiply(k4, c1);\n                h4 ^= k4;\n\n            case 12:\n                k3 ^= bytes[i + 11] << 24;\n\n            case 11:\n                k3 ^= bytes[i + 10] << 16;\n\n            case 10:\n                k3 ^= bytes[i + 9] << 8;\n\n            case 9:\n                k3 ^= bytes[i + 8];\n                k3 = _x86Multiply(k3, c3);\n                k3 = _x86Rotl(k3, 17);\n                k3 = _x86Multiply(k3, c4);\n                h3 ^= k3;\n\n            case 8:\n                k2 ^= bytes[i + 7] << 24;\n\n            case 7:\n                k2 ^= bytes[i + 6] << 16;\n\n            case 6:\n                k2 ^= bytes[i + 5] << 8;\n\n            case 5:\n                k2 ^= bytes[i + 4];\n                k2 = _x86Multiply(k2, c2);\n                k2 = _x86Rotl(k2, 16);\n                k2 = _x86Multiply(k2, c3);\n                h2 ^= k2;\n\n            case 4:\n                k1 ^= bytes[i + 3] << 24;\n\n            case 3:\n                k1 ^= bytes[i + 2] << 16;\n\n            case 2:\n                k1 ^= bytes[i + 1] << 8;\n\n            case 1:\n                k1 ^= bytes[i];\n                k1 = _x86Multiply(k1, c1);\n                k1 = _x86Rotl(k1, 15);\n                k1 = _x86Multiply(k1, c2);\n                h1 ^= k1;\n        }\n\n        h1 ^= bytes.length;\n        h2 ^= bytes.length;\n        h3 ^= bytes.length;\n        h4 ^= bytes.length;\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        h1 = _x86Fmix(h1);\n        h2 = _x86Fmix(h2);\n        h3 = _x86Fmix(h3);\n        h4 = _x86Fmix(h4);\n\n        h1 += h2;\n        h1 += h3;\n        h1 += h4;\n        h2 += h1;\n        h3 += h1;\n        h4 += h1;\n\n        return (\"00000000\" + (h1 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h3 >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h4 >>> 0).toString(16)).slice(-8);\n    };\n\n    library.x64.hash128 = function (bytes, seed) {\n        //\n        // Given a string and an optional seed as an int, returns a 128 bit\n        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.\n        //\n        if (library.inputValidation && !_validBytes(bytes)) {\n            return undefined;\n        }\n        seed = seed || 0;\n\n        var remainder = bytes.length % 16;\n        var blocks = bytes.length - remainder;\n\n        var h1 = [0, seed];\n        var h2 = [0, seed];\n\n        var k1 = [0, 0];\n        var k2 = [0, 0];\n\n        var c1 = [0x87c37b91, 0x114253d5];\n        var c2 = [0x4cf5ad43, 0x2745937f];\n\n        for (var i = 0; i < blocks; i = i + 16) {\n            k1 = [(bytes[i + 4]) | (bytes[i + 5] << 8) | (bytes[i + 6] << 16) | (bytes[i + 7] << 24), (bytes[i]) |\n                (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24)];\n            k2 = [(bytes[i + 12]) | (bytes[i + 13] << 8) | (bytes[i + 14] << 16) | (bytes[i + 15] << 24), (bytes[i + 8]) |\n                (bytes[i + 9] << 8) | (bytes[i + 10] << 16) | (bytes[i + 11] << 24)];\n\n            k1 = _x64Multiply(k1, c1);\n            k1 = _x64Rotl(k1, 31);\n            k1 = _x64Multiply(k1, c2);\n            h1 = _x64Xor(h1, k1);\n\n            h1 = _x64Rotl(h1, 27);\n            h1 = _x64Add(h1, h2);\n            h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 0x52dce729]);\n\n            k2 = _x64Multiply(k2, c2);\n            k2 = _x64Rotl(k2, 33);\n            k2 = _x64Multiply(k2, c1);\n            h2 = _x64Xor(h2, k2);\n\n            h2 = _x64Rotl(h2, 31);\n            h2 = _x64Add(h2, h1);\n            h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 0x38495ab5]);\n        }\n\n        k1 = [0, 0];\n        k2 = [0, 0];\n\n        switch (remainder) {\n            case 15:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));\n\n            case 14:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));\n\n            case 13:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));\n\n            case 12:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));\n\n            case 11:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));\n\n            case 10:\n                k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));\n\n            case 9:\n                k2 = _x64Xor(k2, [0, bytes[i + 8]]);\n                k2 = _x64Multiply(k2, c2);\n                k2 = _x64Rotl(k2, 33);\n                k2 = _x64Multiply(k2, c1);\n                h2 = _x64Xor(h2, k2);\n\n            case 8:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));\n\n            case 7:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));\n\n            case 6:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));\n\n            case 5:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));\n\n            case 4:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));\n\n            case 3:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));\n\n            case 2:\n                k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));\n\n            case 1:\n                k1 = _x64Xor(k1, [0, bytes[i]]);\n                k1 = _x64Multiply(k1, c1);\n                k1 = _x64Rotl(k1, 31);\n                k1 = _x64Multiply(k1, c2);\n                h1 = _x64Xor(h1, k1);\n        }\n\n        h1 = _x64Xor(h1, [0, bytes.length]);\n        h2 = _x64Xor(h2, [0, bytes.length]);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        h1 = _x64Fmix(h1);\n        h2 = _x64Fmix(h2);\n\n        h1 = _x64Add(h1, h2);\n        h2 = _x64Add(h2, h1);\n\n        return (\"00000000\" + (h1[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h1[1] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[0] >>> 0).toString(16)).slice(-8) + (\"00000000\" + (h2[1] >>> 0).toString(16)).slice(-8);\n    };\n\n    // INITIALIZATION\n    // --------------\n\n    // Export murmurHash3 for CommonJS, either as an AMD module or just as part\n    // of the global object.\n    if (typeof exports !== 'undefined') {\n\n        if (typeof module !== 'undefined' && module.exports) {\n            exports = module.exports = library;\n        }\n\n        exports.murmurHash3 = library;\n\n    } else if (typeof define === 'function' && define.amd) {\n\n        define([], function () {\n            return library;\n        });\n    } else {\n\n        // Use murmurHash3.noConflict to restore `murmurHash3` back to its\n        // original value. Returns a reference to the library object, to allow\n        // it to be used under a different name.\n        library._murmurHash3 = root.murmurHash3;\n\n        library.noConflict = function () {\n            root.murmurHash3 = library._murmurHash3;\n            library._murmurHash3 = undefined;\n            library.noConflict = undefined;\n\n            return library;\n        };\n\n        root.murmurHash3 = library;\n    }\n})(this);\n", "module.exports = require('./lib/murmurHash3js');\n", "import * as Client from '@ucanto/client';\nimport * as CAR from '@ucanto/transport/car';\nimport * as HTTP from '@ucanto/transport/http';\nimport * as ucanto from '@ucanto/core';\nimport * as Capabilities from '@storacha/capabilities/space';\nimport { attest } from '@storacha/capabilities/ucan';\nimport * as Access from './access.js';\nimport * as Space from './space.js';\nimport { invoke, delegate, DID, Delegation, Schema, isDelegation, } from '@ucanto/core';\nimport { isExpired, isTooEarly, canDelegateCapability } from './delegations.js';\nimport { AgentData, getSessionProofs } from './agent-data.js';\nimport { UCAN } from '@storacha/capabilities';\nimport * as API from './types.js';\nexport * from './types.js';\nexport * from './delegations.js';\nexport { AgentData, Access, Space, Delegation, Schema };\nexport * from './agent-use-cases.js';\nconst HOST = 'https://up.storacha.network';\nconst PRINCIPAL = DID.parse('did:web:up.storacha.network');\n/**\n * Default identities for the service, including the primary identity.\n *\n * @type {API.DID[]}\n */\nconst IDENTITIES = [PRINCIPAL.did(), 'did:web:web3.storage'];\n/**\n * Keeps track of AgentData for all Agents constructed.\n * Used by addSpacesFromDelegations - so it can only accept Agent as param, but\n * still mutate corresponding AgentData\n *\n * @deprecated - remove this when deprecated addSpacesFromDelegations is removed\n */\n/** @type {WeakMap<Agent<Record<string, any>>, AgentData>} */\nconst agentToData = new WeakMap();\n/**\n * @typedef {API.Service} Service\n * @typedef {API.Receipt<any, any>} Receipt\n */\n/**\n * Creates a Ucanto connection for the w3access API\n *\n * Usage:\n *\n * ```js\n * import { connection } from '@storacha/access/agent'\n * ```\n *\n * @template {API.DID} T - DID method\n * @template {Record<string, any>} [S=Service]\n * @param {object} [options]\n * @param {API.Principal<T>} [options.principal] - w3access API Principal\n * @param {URL} [options.url] - w3access API URL\n * @param {API.Transport.Channel<S>} [options.channel] - Ucanto channel to use\n * @param {typeof fetch} [options.fetch] - Fetch implementation to use\n * @returns {API.ConnectionView<S>}\n */\nexport function connection(options = {}) {\n    return Client.connect({\n        id: options.principal ?? PRINCIPAL,\n        codec: CAR.outbound,\n        channel: options.channel ??\n            HTTP.open({\n                url: options.url ?? new URL(HOST),\n                method: 'POST',\n                fetch: options.fetch ?? globalThis.fetch.bind(globalThis),\n            }),\n    });\n}\n/**\n * Agent\n *\n * Usage:\n *\n * ```js\n * import { Agent } from '@storacha/access/agent'\n * ```\n *\n * @template {Record<string, any>} [S=Service]\n */\nexport class Agent {\n    /** @type {import('./agent-data.js').AgentData} */\n    #data;\n    /**\n     * DIDs the service is known by, including the primary. They are used by\n     * `invoke` and `invokeAndExecute` to scope session proofs to just the service\n     * DID or it's aliases.\n     *\n     * @type {Set<API.DID>}\n     */\n    #serviceIdentities;\n    /**\n     * @param {import('./agent-data.js').AgentData} data - Agent data\n     * @param {import('./types.js').AgentOptions<S>} [options]\n     */\n    constructor(data, options = {}) {\n        /** @type { Client.Channel<S> & { url?: URL } | undefined } */\n        const channel = options.connection?.channel;\n        this.url = options.url ?? channel?.url ?? new URL(HOST);\n        this.connection =\n            options.connection ??\n                connection({\n                    principal: options.servicePrincipal,\n                    url: this.url,\n                });\n        this.#data = data;\n        agentToData.set(this, this.#data);\n        const primary = this.connection.id;\n        const serviceIdentities = new Set(options.serviceIdentities);\n        // If the default identities includes the configured primary identity then\n        // add them to the service identities list.\n        if (IDENTITIES.includes(primary.did())) {\n            for (const id of IDENTITIES) {\n                serviceIdentities.add(id);\n            }\n        }\n        // Add the primary identity if not already in service identities.\n        if (!serviceIdentities.has(primary.did())) {\n            serviceIdentities.add(primary.did());\n        }\n        this.#serviceIdentities = serviceIdentities;\n    }\n    /**\n     * Create a new Agent instance, optionally with the passed initialization data.\n     *\n     * @template {Record<string, any>} [R=Service]\n     * @param {Partial<import('./types.js').AgentDataModel>} [init]\n     * @param {import('./types.js').AgentOptions<R> & import('./types.js').AgentDataOptions} [options]\n     */\n    static async create(init, options = {}) {\n        const data = await AgentData.create(init, options);\n        return new Agent(data, options);\n    }\n    /**\n     * Instantiate an Agent from pre-exported agent data.\n     *\n     * @template {Record<string, any>} [R=Service]\n     * @param {import('./types.js').AgentDataExport} raw\n     * @param {import('./types.js').AgentOptions<R> & import('./types.js').AgentDataOptions} [options]\n     */\n    static from(raw, options = {}) {\n        const data = AgentData.fromExport(raw, options);\n        return new Agent(data, options);\n    }\n    get issuer() {\n        return this.#data.principal;\n    }\n    get meta() {\n        return this.#data.meta;\n    }\n    get spaces() {\n        return this.#data.spaces;\n    }\n    did() {\n        return this.#data.principal.did();\n    }\n    /**\n     * Add a proof to the agent store.\n     *\n     * @param {API.Delegation} delegation\n     */\n    async addProof(delegation) {\n        return await this.addProofs([delegation]);\n    }\n    /**\n     * Adds set of proofs to the agent store.\n     *\n     * @param {Iterable<API.Delegation>} delegations\n     */\n    async addProofs(delegations) {\n        for (const proof of delegations) {\n            await this.#data.addDelegation(proof, { audience: this.meta });\n        }\n        await this.removeExpiredDelegations();\n        return {};\n    }\n    /**\n     * Query the delegations store for all the delegations matching the capabilities provided.\n     *\n     * @param {API.CapabilityQuery[]} [caps]\n     */\n    #delegations(caps) {\n        const _caps = new Set(caps);\n        /** @type {Array<{ delegation: API.Delegation, meta: API.DelegationMeta }>} */\n        const values = [];\n        for (const [, value] of this.#data.delegations) {\n            // check expiration\n            if (!isExpired(value.delegation) && // check if delegation can be used\n                !isTooEarly(value.delegation)) {\n                // check if we need to filter for caps\n                if (Array.isArray(caps) && caps.length > 0) {\n                    for (const cap of _caps) {\n                        if (canDelegateCapability(value.delegation, cap)) {\n                            values.push(value);\n                        }\n                    }\n                }\n                else {\n                    values.push(value);\n                }\n            }\n        }\n        return values;\n    }\n    /**\n     * Clean up any expired delegations.\n     */\n    async removeExpiredDelegations() {\n        for (const [, value] of this.#data.delegations) {\n            if (isExpired(value.delegation)) {\n                await this.#data.removeDelegation(value.delegation.cid);\n            }\n        }\n    }\n    /**\n     * Revoke a delegation by CID.\n     *\n     * If the delegation was issued by this agent (and therefore is stored in the\n     * delegation store) you can just pass the CID. If not, or if the current agent's\n     * delegation store no longer contains the delegation, you MUST pass a chain of\n     * proofs that proves your authority to revoke this delegation as `options.proofs`.\n     *\n     * @param {API.UCANLink} delegationCID\n     * @param {object} [options]\n     * @param {API.Delegation[]} [options.proofs]\n     */\n    async revoke(delegationCID, options = {}) {\n        const additionalProofs = options.proofs ?? [];\n        // look for the identified delegation in the delegation store and the passed proofs\n        const delegation = [...this.delegations(), ...additionalProofs].find((delegation) => delegation.cid.equals(delegationCID));\n        if (!delegation) {\n            return {\n                error: new Error(`could not find delegation ${delegationCID.toString()} - please include the delegation in options.proofs`),\n            };\n        }\n        const receipt = await this.invokeAndExecute(UCAN.revoke, {\n            // per https://github.com/storacha/upload-service/blob/main/packages/capabilities/src/ucan.js#L38C6-L38C6 the resource here should be\n            // the current issuer - using the space DID here works for simple cases but falls apart when a delegee tries to revoke a delegation\n            // they have re-delegated, since they don't have \"ucan/revoke\" capabilities on the space\n            with: this.issuer.did(),\n            nb: {\n                ucan: delegation.cid,\n            },\n            proofs: [delegation, ...additionalProofs],\n        });\n        return receipt.out;\n    }\n    /**\n     * Get all the proofs matching the capabilities.\n     *\n     * Proofs are delegations with an audience matching agent DID, or with an\n     * audience matching the session DID.\n     *\n     * Proof of session will also be included in the returned proofs if any\n     * proofs matching the passed capabilities require it.\n     *\n     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the proofs.\n     * @param {object} [options]\n     * @param {API.DID|API.DID[]} [options.sessionProofIssuer] - only include session proofs for these issuer(s)\n     */\n    proofs(caps, options) {\n        /** @type {Map<string, API.Delegation<API.Capabilities>>} */\n        const authorizations = new Map();\n        for (const { delegation } of this.#delegations(caps)) {\n            if (delegation.audience.did() === this.issuer.did()) {\n                authorizations.set(delegation.cid.toString(), delegation);\n            }\n        }\n        /** @type {Set<API.DID>} */\n        const sessionProofIssuers = new Set();\n        if (options?.sessionProofIssuer) {\n            const ids = Array.isArray(options.sessionProofIssuer)\n                ? options.sessionProofIssuer\n                : [options.sessionProofIssuer];\n            for (const id of ids) {\n                sessionProofIssuers.add(id);\n            }\n        }\n        // now let's add any session proofs that refer to those authorizations\n        const sessions = getSessionProofs(this.#data);\n        for (const proof of [...authorizations.values()]) {\n            const proofsByIssuer = sessions[proof.asCID.toString()] ?? {};\n            const sessionProofs = [];\n            if (sessionProofIssuers.size > 0) {\n                for (const id of sessionProofIssuers) {\n                    const proofs = proofsByIssuer[id];\n                    if (proofs)\n                        sessionProofs.push(...proofs);\n                }\n            }\n            else {\n                sessionProofs.push(...Object.values(proofsByIssuer).flat());\n            }\n            for (const sessionProof of sessionProofs) {\n                authorizations.set(sessionProof.cid.toString(), sessionProof);\n            }\n        }\n        return [...authorizations.values()];\n    }\n    /**\n     * Get delegations created by the agent for others.\n     *\n     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.\n     */\n    delegations(caps) {\n        const arr = [];\n        for (const { delegation } of this.delegationsWithMeta(caps)) {\n            arr.push(delegation);\n        }\n        return arr;\n    }\n    /**\n     * Get delegations created by the agent for others and their metadata.\n     *\n     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.\n     */\n    delegationsWithMeta(caps) {\n        const arr = [];\n        for (const value of this.#delegations(caps)) {\n            const { delegation } = value;\n            const isSession = delegation.capabilities.some((c) => c.can === attest.can);\n            if (!isSession && delegation.audience.did() !== this.issuer.did()) {\n                arr.push(value);\n            }\n        }\n        return arr;\n    }\n    /**\n     * Creates a space signer and a delegation to the agent\n     *\n     * @param {string} name\n     * @param {object} [options]\n     * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.\n     */\n    async createSpace(name, { access } = {}) {\n        return await Space.generate({ name, access, agent: this });\n    }\n    /**\n     * @param {string} secret\n     * @param {object} options\n     * @param {string} options.name - The name of the space.\n     * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.\n     */\n    async recoverSpace(secret, { name, access }) {\n        return await Space.fromMnemonic(secret, { name, access, agent: this });\n    }\n    /**\n     * Import a space from a delegation.\n     *\n     * @param {API.Delegation} delegation\n     * @param {object} options\n     * @param {string} [options.name]\n     */\n    async importSpaceFromDelegation(delegation, { name = '' } = {}) {\n        const space = name === ''\n            ? Space.fromDelegation(delegation)\n            : Space.fromDelegation(delegation).withName(name);\n        // Store space metadata preserving all properties\n        this.#data.spaces.set(space.did(), {\n            ...space.meta,\n            name: space.name,\n            access: space.access,\n        });\n        await this.addProof(space.delegation);\n        // if we do not have a current space, make this one current\n        if (!this.currentSpace()) {\n            await this.setCurrentSpace(space.did());\n        }\n        return space;\n    }\n    /**\n     * Sets the current selected space\n     *\n     * Other methods will default to use the current space if no resource is defined\n     *\n     * @param {API.SpaceDID} space\n     */\n    async setCurrentSpace(space) {\n        if (!this.#data.spaces.has(space)) {\n            throw new Error(`Agent has no proofs for ${space}.`);\n        }\n        await this.#data.setCurrentSpace(space);\n        return space;\n    }\n    /**\n     * Get current space DID\n     */\n    currentSpace() {\n        return this.#data.currentSpace;\n    }\n    /**\n     * Get current space DID, proofs and abilities\n     */\n    currentSpaceWithMeta() {\n        if (!this.#data.currentSpace) {\n            return;\n        }\n        const proofs = this.proofs([\n            {\n                can: 'space/info',\n                with: this.#data.currentSpace,\n            },\n        ]);\n        const caps = new Set();\n        for (const p of proofs) {\n            for (const cap of p.capabilities) {\n                caps.add(cap.can);\n            }\n        }\n        return {\n            did: this.#data.currentSpace,\n            proofs,\n            capabilities: [...caps],\n            meta: this.#data.spaces.get(this.#data.currentSpace),\n        };\n    }\n    /**\n     *\n     * @param {import('./types.js').DelegationOptions} options\n     */\n    async delegate(options) {\n        const space = this.currentSpaceWithMeta();\n        if (!space) {\n            throw new Error('no space selected.');\n        }\n        const caps = /** @type {API.Capabilities} */ (options.abilities.map((a) => {\n            return {\n                with: space.did,\n                can: a,\n            };\n        }));\n        // Verify agent can provide proofs for each requested capability\n        for (const cap of caps) {\n            if (!this.proofs([cap]).length) {\n                throw new Error(`cannot delegate capability ${cap.can} with ${cap.with}`);\n            }\n        }\n        const delegation = await delegate({\n            issuer: this.issuer,\n            capabilities: caps,\n            proofs: this.proofs(caps),\n            facts: [{ space: space.meta ?? {} }],\n            ...options,\n        });\n        await this.#data.addDelegation(delegation, {\n            audience: options.audienceMeta,\n        });\n        await this.removeExpiredDelegations();\n        return delegation;\n    }\n    /**\n     * Invoke and execute the given capability on the Access service connection\n     *\n     * ```js\n     *\n     * await agent.invokeAndExecute(Space.recover, {\n     *   nb: {\n     *     identity: 'mailto: email@gmail.com',\n     *   },\n     * })\n     *\n     * // sugar for\n     * const recoverInvocation = await agent.invoke(Space.recover, {\n     *   nb: {\n     *     identity: 'mailto: email@gmail.com',\n     *   },\n     * })\n     *\n     * await recoverInvocation.execute(agent.connection)\n     * ```\n     *\n     * @template {API.Ability} A\n     * @template {API.URI} R\n     * @template {API.Caveats} C\n     * @param {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>} cap\n     * @param {API.InvokeOptions<A, R, API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>>} options\n     * @returns {Promise<API.InferReceipt<API.Capability<A, R, C>, S>>}\n     */\n    async invokeAndExecute(cap, options) {\n        const inv = await this.invoke(cap, options);\n        const out = inv.execute(/** @type {*} */ (this.connection));\n        return /** @type {*} */ (out);\n    }\n    /**\n     * Execute invocations on the agent's connection\n     *\n     * @example\n     * ```js\n     * const i1 = await agent.invoke(Space.info, {})\n     * const i2 = await agent.invoke(Space.recover, {\n     *   nb: {\n     *     identity: 'mailto:hello@storacha.network',\n     *   },\n     * })\n     *\n     * const results = await agent.execute2(i1, i2)\n     *\n     * ```\n     * @template {API.Capability} C\n     * @template {API.Tuple<API.ServiceInvocation<C, S>>} I\n     * @param {I} invocations\n     */\n    execute(...invocations) {\n        return this.connection.execute(...invocations);\n    }\n    /**\n     * Creates an invocation for the given capability with Agent's proofs, service, issuer and space.\n     *\n     * @example\n     * ```js\n     * const recoverInvocation = await agent.invoke(Space.recover, {\n     *   nb: {\n     *     identity: 'mailto: email@gmail.com',\n     *   },\n     * })\n     *\n     * await recoverInvocation.execute(agent.connection)\n     * // or\n     * await agent.execute(recoverInvocation)\n     * ```\n     *\n     * @template {API.Ability} A\n     * @template {API.URI} R\n     * @template {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>} CAP\n     * @template {API.Caveats} [C={}]\n     * @param {CAP} cap\n     * @param {import('./types.js').InvokeOptions<A, R, CAP>} options\n     */\n    async invoke(cap, options) {\n        const audience = options.audience || this.connection.id;\n        const space = options.with || this.currentSpace();\n        if (!space) {\n            throw new Error('No space or resource selected, you need pass a resource.');\n        }\n        const proofs = [\n            ...(options.proofs || []),\n            ...this.proofs([\n                {\n                    with: space,\n                    can: cap.can,\n                },\n            ], {\n                sessionProofIssuer: this.#serviceIdentities.has(audience.did())\n                    ? [...this.#serviceIdentities]\n                    : audience.did(),\n            }),\n        ];\n        if (proofs.length === 0 && options.with !== this.did()) {\n            throw new Error(`no proofs available for resource ${space} and ability ${cap.can}`);\n        }\n        const inv = invoke({\n            ...options,\n            audience,\n            // @ts-ignore\n            capability: cap.create({\n                with: space,\n                nb: 'nb' in options ? options.nb : undefined,\n            }),\n            issuer: this.issuer,\n            proofs: [...proofs],\n            nonce: options.nonce,\n        });\n        return /** @type {API.IssuedInvocationView<API.InferInvokedCapability<CAP>>} */ (inv);\n    }\n    /**\n     * Get Space information from Access service\n     *\n     * @param {API.URI<\"did:\">} [space]\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async getSpaceInfo(space, options) {\n        const _space = space || this.currentSpace();\n        if (!_space) {\n            throw new Error('No space selected, you need pass a resource.');\n        }\n        const inv = await this.invokeAndExecute(Capabilities.info, {\n            ...options,\n            with: _space,\n        });\n        if (inv.out.error) {\n            throw inv.out.error;\n        }\n        return /** @type {import('./types.js').SpaceInfoResult} */ (inv.out.ok);\n    }\n}\n/**\n * Given a list of delegations, add to agent data spaces list.\n *\n * @deprecated - trying to remove explicit space tracking from Agent/AgentData\n * in favor of functions that derive the space set from access.delegations\n *\n * @template {Record<string, any>} [S=Service]\n * @param {Agent<S>} agent\n * @param {API.Delegation[]} delegations\n */\nexport async function addSpacesFromDelegations(agent, delegations) {\n    const data = agentToData.get(agent);\n    if (!data) {\n        throw Object.assign(new Error(`cannot determine AgentData for Agent`), {\n            agent: agent,\n        });\n    }\n    // spaces we find along the way.\n    const spaces = new Map();\n    // only consider ucans with this agent as the audience\n    const ours = delegations.filter((x) => x.audience.did() === agent.did());\n    // space names are stored as facts in proofs in the special `ucan:*` delegation from email to agent.\n    const ucanStars = ours.filter((x) => x.capabilities[0].can === '*' && x.capabilities[0].with === 'ucan:*');\n    for (const delegation of ucanStars) {\n        for (const proof of delegation.proofs) {\n            if (!isDelegation(proof) ||\n                !proof.capabilities[0].with.startsWith('did:key')) {\n                continue;\n            }\n            const space = Space.fromDelegation(proof);\n            spaces.set(space.did(), space.meta);\n        }\n    }\n    // Find any other spaces the user may have access to\n    for (const delegation of ours) {\n        // TODO: we need a more robust way to determine which spaces a user has access to\n        // it may or may not involve look at delegations\n        const allows = ucanto.Delegation.allows(delegation);\n        for (const [resource, value] of Object.entries(allows)) {\n            // If we discovered a delegation to any DID, we add it to the spaces list.\n            if (resource.startsWith('did:key') && Object.keys(value).length > 0) {\n                if (!spaces.has(resource)) {\n                    spaces.set(resource, {});\n                }\n            }\n        }\n    }\n    for (const [did, meta] of spaces) {\n        await data.addSpace(did, meta);\n    }\n}\n/**\n * Stores given delegations in the agent's data store and adds discovered spaces\n * to the agent's space list.\n *\n * @param {Agent} agent\n * @param {object} authorization\n * @param {API.Delegation[]} authorization.proofs\n * @returns {Promise<API.Result<API.Unit, Error>>}\n */\nexport const importAuthorization = async (agent, { proofs }) => {\n    try {\n        await agent.addProofs(proofs);\n        await addSpacesFromDelegations(agent, proofs);\n        return { ok: {} };\n    }\n    catch (error) {\n        return /** @type {{error:Error}} */ ({ error });\n    }\n};\n//# sourceMappingURL=agent.js.map", "export * from './connection.js'\n\nexport * from '@ucanto/interface'\nimport { Delegation, invoke, Schema, DAG, ok, error } from '@ucanto/core'\n\nexport const delegate = Delegation.delegate\nexport { invoke, ok, error, Schema, DAG }\n", "import * as API from '@ucanto/interface'\nimport { Signature, Message, Receipt, sha256 } from '@ucanto/core'\n\n/**\n * Creates a connection to a service.\n *\n * @template {Record<string, any>} T\n * @param {API.ConnectionOptions<T>} options\n * @returns {API.ConnectionView<T>}\n */\nexport const connect = options => new Connection(options)\n\n/**\n * @template {Record<string, any>} T\n * @implements {API.ConnectionView<T>}\n */\nclass Connection {\n  /**\n   * @param {API.ConnectionOptions<T>} options\n   */\n  constructor(options) {\n    this.id = options.id\n    this.options = options\n    this.codec = options.codec\n    this.channel = options.channel\n    this.hasher = options.hasher || sha256\n  }\n  /**\n   * Execute invocations.\n   *\n   * @template {API.Capability} C\n   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n   * @param {I} invocations\n   * @returns {Promise<API.InferReceipts<I, T>>}\n   */\n  async execute(...invocations) {\n    return execute(invocations, this)\n  }\n}\n\n/**\n * @template {API.Capability} C\n * @template {Record<string, any>} T\n * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n * @param {API.Connection<T>} connection\n * @param {I} invocations\n * @returns {Promise<API.InferReceipts<I, T>>}\n */\nexport const execute = async (invocations, connection) => {\n  const input = await Message.build({ invocations })\n  const request = await connection.codec.encode(input, connection)\n  const response = await connection.channel.request(request)\n  // We may fail to decode the response if content type is not supported\n  // or if data was corrupted. We do not want to throw in such case however,\n  // because client will get an Error object as opposed to a receipt, to retain\n  // consistent client API with two kinds of errors we encode caught error as\n  // a receipts per workflow invocation.\n  try {\n    const output = await connection.codec.decode(response)\n    const receipts = input.invocationLinks.map(link => output.get(link))\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  } catch (error) {\n    // No third party code is run during decode and we know\n    // we only throw an Error\n    const { message, name = 'Error', ...cause } = /** @type {Error} */ (error)\n    const receipts = []\n    for await (const ran of input.invocationLinks) {\n      const receipt = await Receipt.issue({\n        ran,\n        result: { error: { ...cause, name, message } },\n        // @ts-expect-error - we can not really sign a receipt without having\n        // an access to a signer which client does not have. In the future\n        // we will change client API requiring a signer to be passed in but\n        // for now we just use a dummy signer.\n        issuer: {\n          did() {\n            return connection.id.did()\n          },\n          sign() {\n            return Signature.createNonStandard('', new Uint8Array())\n          },\n        },\n      })\n\n      receipts.push(receipt)\n    }\n\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  }\n}\n", "export * as API from '@ucanto/interface'\nexport * as Delegation from './delegation.js'\nexport * as Invocation from './invocation.js'\nexport * as Message from './message.js'\nexport * as Receipt from './receipt.js'\nexport * as DAG from './dag.js'\nexport * as CBOR from './cbor.js'\nexport * as CAR from './car.js'\nexport { delegate, isDelegation } from './delegation.js'\nexport { invoke } from './invocation.js'\nexport {\n  create as createLink,\n  createLegacy as createLegacyLink,\n  isLink,\n  parse as parseLink,\n  decode as decodeLink,\n} from './link.js'\nexport { sha256 } from 'multiformats/hashes/sha2'\nexport { base58btc } from 'multiformats/bases/base58'\nexport * as UCAN from '@ipld/dag-ucan'\nexport * as DID from '@ipld/dag-ucan/did'\nexport * as Signature from '@ipld/dag-ucan/signature'\nexport * from './result.js'\nexport * as Schema from './schema.js'\n", "import * as UCAN from '@ipld/dag-ucan'\nimport * as API from '@ucanto/interface'\nimport * as Link from './link.js'\nimport * as DAG from './dag.js'\nimport * as CAR from './car.js'\nimport * as CBOR from './cbor.js'\nimport * as Schema from './schema.js'\nimport { ok, error } from './result.js'\n\n/**\n * @deprecated\n * Import `isLink` from module directly\n */\nexport const isLink =\n  /** @type {(value:API.Proof) => value is API.UCANLink} */\n  (Link.isLink)\n\n/**\n *\n * @param {API.Proof} proof\n * @return {proof is API.Delegation}\n */\nexport const isDelegation = proof => !Link.isLink(proof)\n\n/**\n * Takes one or more delegations and returns all delegated capabilities in\n * UCAN 0.10 format, expanding all the special forms like `with: ucan:*` and\n * `can: *` to explicit forms.\n *\n * Note that this function only considers included proofs and ignores linked\n * proofs. It is up to the user of this function to resolve whatever proofs it\n * needs and build delegation with them before calling this function.\n *\n * Also note that this function does not validate the delegations and may\n * produce result containing capabilities that escalate, which for the validator\n * perspective is no different from not including such capabilities.\n *\n * @template {[API.Delegation, ...API.Delegation[]]} T\n * @param {T} delegations\n * @returns {API.InferAllowedFromDelegations<T>}\n */\nexport const allows = (...delegations) => {\n  /** @type {API.Allows} */\n  let allow = {}\n  for (const delegation of delegations) {\n    for (const { with: uri, can, nb } of iterateCapabilities(delegation)) {\n      const resource = allow[uri] || (allow[uri] = {})\n      const abilities = resource[can] || (resource[can] = [])\n      abilities.push({ ...nb })\n    }\n  }\n\n  return /** @type {API.InferAllowedFromDelegations<T>} */ (allow)\n}\n\n/**\n * Function takes a delegation and iterates over all the capabilities expanding\n * all the special forms like `with: ucan:*` and `can: *`.\n *\n * Note that this function only considers proofs that are included in the\n * delegation, linked proofs will not be resolved nor considered. It is up to\n * the user of this function to resolve whatever proofs it needs to consider\n * before calling this function.\n *\n * @param {API.Delegation} delegation\n * @returns {Iterable<API.Capability>}\n */\nconst iterateCapabilities = function* ({ issuer, capabilities, proofs }) {\n  for (const own of capabilities) {\n    // If `with` field is set to  `ucan:*` it implies re-delegation of all own\n    // and delegated capabilities.\n    if (own.with === 'ucan:*') {\n      // Fist we include own capabilities. Note that we can not expand `can`\n      // because it implicitly covers all possible options in the universe.\n      yield {\n        ...own,\n        with: issuer.did(),\n      }\n\n      // Next we iterate over all delegated capabilities including ones that\n      // match ability in the `own.can` field.\n      for (const proof of proofs) {\n        // We only consider proofs that are included and ignore linked proofs.\n        if (isDelegation(proof)) {\n          for (const capability of iterateCapabilities(proof)) {\n            // We attempt to match `capability.can` against `own.can` field\n            // if there is a match we include the capability otherwise we skip\n            const can = matchAbility(capability.can, own.can)\n            if (can) {\n              yield {\n                ...capability,\n                can,\n                // We do not know capability semantics so it is impossible\n                // for us to eliminate capabilities that do not satisfy imposed\n                // caveats (`own.nb`). Therefore we optimistically assume that\n                // `own.nb` further constraints `capability.nb` and do a shallow\n                // merge of the two. As a result we may include capabilities\n                // that during validation will be considered invalid due to\n                // constraint violations. While that is not ideal validator\n                // will treat them as if they were omitted and therefore it\n                // is a reasonable compromise.\n                nb: { ...capability.nb, ...Object(own.nb) },\n              }\n            }\n          }\n        }\n      }\n    } else {\n      yield own\n    }\n  }\n}\n\n/**\n * Function takes `can` field from the delegated capability and attempts to\n * match it against `can` field of the claimed capability. If there is a match\n * the function returns more specific `can` field of two, otherwise it returns\n * `null`.\n *\n * @param {API.Ability} provided\n * @param {API.Ability} claimed\n */\nconst matchAbility = (provided, claimed) => {\n  // If provided capability delegates all abilities we can derive any `can`\n  // from it so we return `claimed` as is.\n  if (provided === '*') {\n    return claimed\n  }\n  // If claimed capability delegates all abilities that includes any `can`\n  // so we return `provided` as is.\n  if (claimed === '*') {\n    return provided\n  }\n  // If claimed `can` is a pattern that includes `provided` `can` we return\n  // `provided` as is.\n  if (claimed.endsWith('/*') && provided.startsWith(claimed.slice(0, -1))) {\n    return provided\n  }\n  // If provided `can` is a pattern that includes `claimed` `can` we can derive\n  // `claimed` from it so we return `claimed` as is.\n  if (provided.endsWith('/*') && claimed.startsWith(provided.slice(0, -1))) {\n    return claimed\n  }\n  // If `can` fields are concrete and the same we have a match and can return it.\n  if (provided === claimed) {\n    return provided\n  }\n  // otherwise two are incompatible and we return null.\n  return null\n}\n\n/**\n * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of\n * this as UCAN interface of the CAR.\n *\n * @template {API.Capabilities} C\n * @implements {API.Delegation<C>}\n * @extends {DelegationView<C>}\n */\nexport class Delegation {\n  /**\n   * @param {API.UCANBlock<C>} root\n   * @param {DAG.BlockStore} [blocks]\n   */\n  constructor(root, blocks = new Map()) {\n    this.root = root\n    this.blocks = blocks\n\n    Object.defineProperties(this, {\n      blocks: {\n        enumerable: false,\n      },\n    })\n  }\n\n  /**\n   * @returns {API.AttachedLinkSet}\n   */\n  get attachedLinks() {\n    const _attachedLinks = new Set()\n    const ucanView = this.data\n\n    // Get links from capabilities nb\n    for (const capability of ucanView.capabilities) {\n      /** @type {Link[]} */\n      const links = getLinksFromObject(capability)\n\n      for (const link of links) {\n        _attachedLinks.add(`${link}`)\n      }\n    }\n\n    // Get links from facts values\n    for (const fact of ucanView.facts) {\n      if (Link.isLink(fact)) {\n        _attachedLinks.add(`${fact}`)\n      } else {\n        /** @type {Link[]} */\n        // @ts-expect-error isLink does not infer value type\n        const links = Object.values(fact).filter(e => Link.isLink(e))\n\n        for (const link of links) {\n          _attachedLinks.add(`${link}`)\n        }\n      }\n    }\n\n    return _attachedLinks\n  }\n\n  get version() {\n    return this.data.version\n  }\n  get signature() {\n    return this.data.signature\n  }\n  get cid() {\n    return this.root.cid\n  }\n  link() {\n    return this.root.cid\n  }\n  get asCID() {\n    return this.cid\n  }\n  get bytes() {\n    return this.root.bytes\n  }\n  get data() {\n    const data = decode(this.root)\n    Object.defineProperties(this, { data: { value: data, enumerable: false } })\n    return data\n  }\n  /**\n   * Attach a block to the delegation DAG so it would be included in the\n   * block iterator.\n   *  You can only attach blocks that are referenced from the `capabilities`\n   * or `facts`.\n   *\n   * @param {API.Block} block\n   */\n  attach(block) {\n    if (!this.attachedLinks.has(`${block.cid.link()}`)) {\n      throw new Error(`given block with ${block.cid} is not an attached link`)\n    }\n    this.blocks.set(`${block.cid}`, block)\n  }\n  export() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @returns {API.Await<API.Result<Uint8Array, Error>>}\n   */\n  archive() {\n    return archive(this)\n  }\n\n  iterateIPLDBlocks() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @type {API.Proof[]}\n   */\n  get proofs() {\n    return proofs(this)\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get issuer() {\n    return this.data.issuer\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get audience() {\n    return this.data.audience\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return /** @type {C} */ (this.data.capabilities)\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    return this.data.expiration\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.data.notBefore\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.data.nonce\n  }\n\n  /**\n   * @returns {API.Fact[]}\n   */\n  get facts() {\n    return this.data.facts\n  }\n\n  /**\n   * Iterate over the proofs\n   *\n   * @returns {IterableIterator<API.Delegation>}\n   */\n  iterate() {\n    return it(this)\n  }\n\n  delegate() {\n    return this\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  /**\n   * @returns {API.DelegationJSON<this>}\n   */\n  toJSON() {\n    return /** @type {any} */ ({\n      ...this.data.toJSON(),\n      '/': this.cid.toString(),\n      prf: this.proofs.map(proof =>\n        isDelegation(proof) ? proof : { '/': proof.toString() }\n      ),\n    })\n  }\n}\n\n/**\n * Writes given `Delegation` chain into a content addressed archive (CAR)\n * buffer and returns it.\n *\n * @param {API.Delegation} delegation}\n * @returns {Promise<API.Result<Uint8Array, Error>>}\n */\nexport const archive = async delegation => {\n  try {\n    // Iterate over all of the blocks in the DAG and add them to the\n    // block store.\n    const store = new Map()\n    for (const block of delegation.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    // Then we we create a descriptor block to describe what this DAG represents\n    // and it to the block store as well.\n    const variant = await CBOR.write({\n      [`ucan@${delegation.version}`]: delegation.root.cid,\n    })\n    store.set(`${variant.cid}`, variant)\n\n    // And finally we encode the whole thing into a CAR.\n    const bytes = CAR.encode({\n      roots: [variant],\n      blocks: store,\n    })\n\n    return ok(bytes)\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\nexport const ArchiveSchema = Schema.variant({\n  'ucan@0.9.1': /** @type {Schema.Schema<API.UCANLink>} */ (\n    Schema.link({ version: 1 })\n  ),\n})\n\n/**\n * Extracts a `Delegation` chain from a given content addressed archive (CAR)\n * buffer. Assumes that the CAR contains a single root block corresponding to\n * the delegation variant.\n *\n * @param {Uint8Array} archive\n */\nexport const extract = async archive => {\n  try {\n    const { roots, blocks } = CAR.decode(archive)\n    const [root] = roots\n    if (root == null) {\n      return Schema.error('CAR archive does not contain a root block')\n    }\n    const { bytes } = root\n    const variant = CBOR.decode(bytes)\n    const [, link] = ArchiveSchema.match(variant)\n    return ok(view({ root: link, blocks }))\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\n/**\n * @param {API.Delegation} delegation\n * @returns {IterableIterator<API.Delegation>}\n */\nconst it = function* (delegation) {\n  for (const proof of delegation.proofs) {\n    if (isDelegation(proof)) {\n      yield* it(proof)\n      yield proof\n    }\n  }\n}\n\nconst decodeCache = new WeakMap()\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} block\n * @returns {UCAN.View<C>}\n */\nconst decode = ({ bytes }) => {\n  const data = decodeCache.get(bytes)\n  if (!data) {\n    const data = UCAN.decode(bytes)\n    decodeCache.set(bytes, data)\n    return data\n  }\n  return data\n}\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {API.Capabilities} C\n * @param {API.DelegationOptions<C>} data\n * @param {API.EncodeOptions} [options]\n * @returns {Promise<API.Delegation<C>>}\n */\n\nexport const delegate = async (\n  { issuer, audience, proofs = [], attachedBlocks = new Map(), ...input },\n  options\n) => {\n  const links = []\n  const blocks = new Map()\n  for (const proof of proofs) {\n    if (!isDelegation(proof)) {\n      links.push(proof)\n    } else {\n      links.push(proof.cid)\n      for (const block of proof.export()) {\n        blocks.set(block.cid.toString(), block)\n      }\n    }\n  }\n\n  const data = await UCAN.issue({\n    ...input,\n    issuer,\n    audience,\n    proofs: links,\n  })\n  const { cid, bytes } = await UCAN.write(data, options)\n  decodeCache.set(cid, data)\n\n  /** @type {API.Delegation<C>} */\n  const delegation = new Delegation({ cid, bytes }, blocks)\n  Object.defineProperties(delegation, { proofs: { value: proofs } })\n\n  for (const block of attachedBlocks.values()) {\n    delegation.attach(block)\n  }\n\n  return delegation\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @param {API.AttachedLinkSet} attachedLinks\n * @returns {IterableIterator<API.Block>}\n */\n\nexport const exportDAG = function* (root, blocks, attachedLinks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  for (const link of attachedLinks.values()) {\n    const block = blocks.get(link)\n\n    if (block) {\n      // @ts-expect-error can get blocks with v0 and v1\n      yield block\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @returns {IterableIterator<API.Block>}\n */\nconst exportSubDAG = function* (root, blocks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {Iterable<API.Block>} dag\n * @returns {API.Delegation<C>}\n */\nexport const importDAG = dag => {\n  /** @type {Array<[string, API.Block]>} */\n  let entries = []\n  for (const block of dag) {\n    entries.push([block.cid.toString(), block])\n  }\n\n  const last = entries.pop()\n  if (!last) {\n    throw new RangeError('Empty DAG can not be turned into a delegation')\n  } else {\n    const [, root] = last\n\n    return new Delegation(\n      /** @type {API.UCANBlock<C>} */ (root),\n      new Map(entries)\n    )\n  }\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {object} dag\n * @param {API.UCANBlock<C>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Delegation<C>}\n */\nexport const create = ({ root, blocks }) => new Delegation(root, blocks)\n\n/**\n * @template {API.Capabilities} C\n * @template [E=never]\n * @param {object} dag\n * @param {API.UCANLink<C>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {E} [fallback]\n * @returns {API.Delegation<C>|E}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  return create({ root: block, blocks })\n}\n\n/**\n * @param {API.Delegation} delegation\n */\nconst proofs = delegation => {\n  /** @type {API.Proof[]} */\n  const proofs = []\n  const { root, blocks } = delegation\n  // Iterate over proof links and materialize Delegation views.\n  for (const link of decode(root).proofs) {\n    // Check if linked proof is included in our blocks if so create delegation\n    // view otherwise use a link\n    const root = /** @type {UCAN.Block} */ (blocks.get(link.toString()))\n    proofs.push(root ? create({ root, blocks }) : link)\n  }\n\n  // we cache result of this computation as this property may get accessed\n  // more than once.\n  Object.defineProperty(delegation, 'proofs', { value: proofs })\n  return proofs\n}\n\n/**\n * @param {API.Capability<API.Ability, `${string}:${string}`, unknown>} obj\n */\nfunction getLinksFromObject(obj) {\n  /** @type {Link[]} */\n  const links = []\n\n  /**\n   * @param {object} obj\n   */\n  function recurse(obj) {\n    for (const key in obj) {\n      // @ts-expect-error record type not inferred\n      const value = obj[key]\n      if (Link.isLink(value)) {\n        // @ts-expect-error isLink does not infer value type\n        links.push(value)\n      } else if (value && typeof value === 'object') {\n        recurse(value)\n      }\n    }\n  }\n\n  recurse(obj)\n\n  return links\n}\n\nexport { Delegation as View }\n", "import * as UCAN from \"./ucan.js\"\nimport * as CBOR from \"./codec/cbor.js\"\nimport * as JWT from \"./codec/jwt.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport { readPayload } from \"./schema.js\"\nimport { parse as parseDID } from \"./did.js\"\nimport { parse as parseJWT } from \"./parser.js\"\nimport { formatSignPayload } from \"./formatter.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { create as createLink } from \"multiformats/link\"\nimport { format as formatDID } from \"./did.js\"\n\nexport * from \"./ucan.js\"\n\nexport const VERSION = \"0.9.1\"\nexport const name = \"dag-ucan\"\nexport const code = /** @type {UCAN.Code} */ (CBOR.code)\n\n/**\n * We cast sha256 to workaround typescripts limited inference problem when using\n * sha256 as default. If hasher is omitted type `A` should match sha256.code\n * but TS fails to deduce that.\n * @type {UCAN.MultihashHasher<any>}\n */\nconst defaultHasher = sha256\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ucan => (ucan.jwt ? JWT.encode(ucan) : CBOR.encode(ucan))\n\n/**\n * Decodes binary encoded UCAN. It assumes UCAN is in primary IPLD\n * representation and attempts to decode it with DAG-CBOR, if that\n * fails it falls back to secondary representation and parses it as\n * a JWT.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.UCAN<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  try {\n    return CBOR.decode(bytes)\n  } catch (_) {\n    return JWT.decode(/** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */ (bytes))\n  }\n}\n\n/**\n * Convenience function to create a CID for the given UCAN. If UCAN is\n * in JWT representation get CID with RAW multicodec, while UCANs in IPLD\n * representation get UCAN multicodec code.\n *\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.View<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} [options]\n */\nexport const link = async (ucan, options) => {\n  const { cid } = await write(ucan, options)\n  return cid\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.UCAN<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} options\n * @returns {Promise<UCAN.Block<C, UCAN.Code, A>>}\n */\nexport const write = async (ucan, { hasher = defaultHasher } = {}) => {\n  const [code, bytes] = ucan.jwt\n    ? [/** @type {UCAN.Code} */ (JWT.code), JWT.encode(ucan)]\n    : [/** @type {UCAN.Code} */ (CBOR.code), CBOR.encode(ucan)]\n  const digest = await hasher.digest(bytes)\n\n  return {\n    bytes,\n    cid: createLink(code, digest),\n    data: ucan,\n  }\n}\n\n/**\n * Parses UCAN formatted as JWT string. Returns UCAN view in IPLD representation\n * when serializing it back would produce original string, otherwise returns UCAN\n * view in secondary JWT representation which is not as compact, but it retains\n * key order and whitespaces so it could be formatted back to same JWT string.\n * View will have `type` field with either `\"IPLD\"` or `\"JWT\"` value telling\n * in which representation UCAN is.\n *\n * Note: Parsing does not perform validation of capabilities or semantics of the\n * UCAN, it only ensures structure is spec compliant and throws `ParseError`\n * if it is not.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.View<C>}\n */\nexport const parse = jwt => {\n  const model = parseJWT(jwt)\n\n  // If formatting UCAN produces same jwt string we can use IPLD representation\n  // otherwise we need to fallback to raw representation. This decision will\n  // affect how we `encode` the UCAN.\n  return CBOR.format(model) === jwt\n    ? CBOR.from(model)\n    : JWT.from({ ...model, jwt: /** @type {UCAN.JWT<C>} */ (jwt) })\n}\n\n/**\n * Takes UCAN object and formats it into JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ucan => (ucan.jwt ? JWT.format(ucan) : CBOR.format(ucan))\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {number} A\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCANOptions<C, A>} options\n * @returns {Promise<UCAN.View<C>>}\n */\nexport const issue = async ({\n  issuer,\n  audience,\n  capabilities,\n  lifetimeInSeconds = 30,\n  expiration = now() + lifetimeInSeconds,\n  notBefore,\n  facts = [],\n  proofs = [],\n  nonce,\n}) => {\n  const v = VERSION\n  const data = readPayload({\n    iss: parseDID(issuer.did()),\n    aud: parseDID(audience.did()),\n    att: capabilities,\n    fct: facts,\n    exp: expiration,\n    nbf: notBefore,\n    prf: proofs,\n    nnc: nonce,\n  })\n  const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm)\n\n  return CBOR.from({\n    ...data,\n    v,\n    s: await issuer.sign(payload),\n  })\n}\n\n/**\n *\n * @param {UCAN.Payload} payload\n * @param {UCAN.Version} version\n * @param {string} algorithm\n * @returns\n */\nconst encodeSignaturePayload = (payload, version, algorithm) =>\n  UTF8.encode(formatSignPayload(payload, version, algorithm))\n\n/**\n * Verifies UCAN signature.\n *\n * @param {UCAN.View} ucan\n * @param {UCAN.Verifier} verifier\n */\nexport const verifySignature = (ucan, verifier) =>\n  formatDID(ucan.issuer) === verifier.did() &&\n  verifier.verify(\n    encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm),\n    ucan.signature\n  )\n\n/**\n * Check if a UCAN is expired.\n *\n * @param {UCAN.View} ucan\n */\nexport const isExpired = ucan => ucan.expiration <= now()\n\n/**\n * Check if a UCAN is not active yet.\n * @param {UCAN.View} ucan\n */\nexport const isTooEarly = ucan =>\n  ucan.notBefore != null && now() <= ucan.notBefore\n\n/**\n * Returns UTC Unix timestamp for comparing it against time window of the UCAN.\n */\nexport const now = () => Math.floor(Date.now() / 1000)\n", "// This is an unfortunate replacement for @sindresorhus/is that we need to\n// re-implement for performance purposes. In particular the is.observable()\n// check is expensive, and unnecessary for our purposes. The values returned\n// are compatible with @sindresorhus/is, however.\n\nconst typeofs = [\n  'string',\n  'number',\n  'bigint',\n  'symbol'\n]\n\nconst objectTypeNames = [\n  'Function',\n  'Generator',\n  'AsyncGenerator',\n  'GeneratorFunction',\n  'AsyncGeneratorFunction',\n  'AsyncFunction',\n  'Observable',\n  'Array',\n  'Buffer',\n  'Object',\n  'RegExp',\n  'Date',\n  'Error',\n  'Map',\n  'Set',\n  'WeakMap',\n  'WeakSet',\n  'ArrayBuffer',\n  'SharedArrayBuffer',\n  'DataView',\n  'Promise',\n  'URL',\n  'HTMLElement',\n  'Int8Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'Int16Array',\n  'Uint16Array',\n  'Int32Array',\n  'Uint32Array',\n  'Float32Array',\n  'Float64Array',\n  'BigInt64Array',\n  'BigUint64Array'\n]\n\n/**\n * @param {any} value\n * @returns {string}\n */\nexport function is (value) {\n  if (value === null) {\n    return 'null'\n  }\n  if (value === undefined) {\n    return 'undefined'\n  }\n  if (value === true || value === false) {\n    return 'boolean'\n  }\n  const typeOf = typeof value\n  if (typeofs.includes(typeOf)) {\n    return typeOf\n  }\n  /* c8 ignore next 4 */\n  // not going to bother testing this, it's not going to be valid anyway\n  if (typeOf === 'function') {\n    return 'Function'\n  }\n  if (Array.isArray(value)) {\n    return 'Array'\n  }\n  if (isBuffer(value)) {\n    return 'Buffer'\n  }\n  const objectType = getObjectType(value)\n  if (objectType) {\n    return objectType\n  }\n  /* c8 ignore next */\n  return 'Object'\n}\n\n/**\n * @param {any} value\n * @returns {boolean}\n */\nfunction isBuffer (value) {\n  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value)\n}\n\n/**\n * @param {any} value\n * @returns {string|undefined}\n */\nfunction getObjectType (value) {\n  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1)\n  if (objectTypeNames.includes(objectTypeName)) {\n    return objectTypeName\n  }\n  /* c8 ignore next */\n  return undefined\n}\n", "class Type {\n  /**\n   * @param {number} major\n   * @param {string} name\n   * @param {boolean} terminal\n   */\n  constructor (major, name, terminal) {\n    this.major = major\n    this.majorEncoded = major << 5\n    this.name = name\n    this.terminal = terminal\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Type[${this.major}].${this.name}`\n  }\n\n  /**\n   * @param {Type} typ\n   * @returns {number}\n   */\n  compare (typ) {\n    /* c8 ignore next 1 */\n    return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0\n  }\n}\n\n// convert to static fields when better supported\nType.uint = new Type(0, 'uint', true)\nType.negint = new Type(1, 'negint', true)\nType.bytes = new Type(2, 'bytes', true)\nType.string = new Type(3, 'string', true)\nType.array = new Type(4, 'array', false)\nType.map = new Type(5, 'map', false)\nType.tag = new Type(6, 'tag', false) // terminal?\nType.float = new Type(7, 'float', true)\nType.false = new Type(7, 'false', true)\nType.true = new Type(7, 'true', true)\nType.null = new Type(7, 'null', true)\nType.undefined = new Type(7, 'undefined', true)\nType.break = new Type(7, 'break', true)\n// Type.indefiniteLength = new Type(0, 'indefiniteLength', true)\n\nclass Token {\n  /**\n   * @param {Type} type\n   * @param {any} [value]\n   * @param {number} [encodedLength]\n   */\n  constructor (type, value, encodedLength) {\n    this.type = type\n    this.value = value\n    this.encodedLength = encodedLength\n    /** @type {Uint8Array|undefined} */\n    this.encodedBytes = undefined\n    /** @type {Uint8Array|undefined} */\n    this.byteValue = undefined\n  }\n\n  /* c8 ignore next 3 */\n  toString () {\n    return `Token[${this.type}].${this.value}`\n  }\n}\n\nexport { Type, Token }\n", "// Use Uint8Array directly in the browser, use Buffer in Node.js but don't\n// speak its name directly to avoid bundlers pulling in the `Buffer` polyfill\n\n// @ts-ignore\nexport const useBuffer = globalThis.process &&\n  // @ts-ignore\n  !globalThis.process.browser &&\n  // @ts-ignore\n  globalThis.Buffer &&\n  // @ts-ignore\n  typeof globalThis.Buffer.isBuffer === 'function'\n\nconst textDecoder = new TextDecoder()\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {Uint8Array} buf\n * @returns {boolean}\n */\nfunction isBuffer (buf) {\n  // @ts-ignore\n  return useBuffer && globalThis.Buffer.isBuffer(buf)\n}\n\n/**\n * @param {Uint8Array|number[]} buf\n * @returns {Uint8Array}\n */\nexport function asU8A (buf) {\n  /* c8 ignore next */\n  if (!(buf instanceof Uint8Array)) {\n    return Uint8Array.from(buf)\n  }\n  return isBuffer(buf) ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf\n}\n\nexport const toString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(bytes.subarray(start, end)).toString('utf8')\n        : utf8Slice(bytes, start, end)\n    }\n  /* c8 ignore next 11 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return end - start > 64\n        ? textDecoder.decode(bytes.subarray(start, end))\n        : utf8Slice(bytes, start, end)\n    }\n\nexport const fromString = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64\n        ? // eslint-disable-line operator-linebreak\n      // @ts-ignore\n        globalThis.Buffer.from(string)\n        : utf8ToBytes(string)\n    }\n  /* c8 ignore next 7 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {string} string\n     */\n    (string) => {\n      return string.length > 64 ? textEncoder.encode(string) : utf8ToBytes(string)\n    }\n\n/**\n * Buffer variant not fast enough for what we need\n * @param {number[]} arr\n * @returns {Uint8Array}\n */\nexport const fromArray = (arr) => {\n  return Uint8Array.from(arr)\n}\n\nexport const slice = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      if (isBuffer(bytes)) {\n        return new Uint8Array(bytes.subarray(start, end))\n      }\n      return bytes.slice(start, end)\n    }\n  /* c8 ignore next 9 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} bytes\n     * @param {number} start\n     * @param {number} end\n     */\n    (bytes, start, end) => {\n      return bytes.slice(start, end)\n    }\n\nexport const concat = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      // might get a stray plain Array here\n      /* c8 ignore next 1 */\n      chunks = chunks.map((c) => c instanceof Uint8Array\n        ? c\n        // this case is occasionally missed during test runs so becomes coverage-flaky\n        /* c8 ignore next 4 */\n        : // eslint-disable-line operator-linebreak\n        // @ts-ignore\n        globalThis.Buffer.from(c))\n      // @ts-ignore\n      return asU8A(globalThis.Buffer.concat(chunks, length))\n    }\n  /* c8 ignore next 19 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array[]} chunks\n     * @param {number} length\n     * @returns {Uint8Array}\n     */\n    (chunks, length) => {\n      const out = new Uint8Array(length)\n      let off = 0\n      for (let b of chunks) {\n        if (off + b.length > out.length) {\n          // final chunk that's bigger than we need\n          b = b.subarray(0, out.length - off)\n        }\n        out.set(b, off)\n        off += b.length\n      }\n      return out\n    }\n\nexport const alloc = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      // we always write over the contents we expose so this should be safe\n      // @ts-ignore\n      return globalThis.Buffer.allocUnsafe(size)\n    }\n  /* c8 ignore next 8 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {number} size\n     * @returns {Uint8Array}\n     */\n    (size) => {\n      return new Uint8Array(size)\n    }\n\nexport const toHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(toBytes(d)).toString('hex')\n    }\n  /* c8 ignore next 12 */\n  : // eslint-disable-line operator-linebreak\n    /**\n     * @param {Uint8Array} d\n     * @returns {string}\n     */\n    (d) => {\n      if (typeof d === 'string') {\n        return d\n      }\n      // @ts-ignore not smart enough to figure this out\n      return Array.prototype.reduce.call(toBytes(d), (p, c) => `${p}${c.toString(16).padStart(2, '0')}`, '')\n    }\n\nexport const fromHex = useBuffer\n  ? // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      // @ts-ignore\n      return globalThis.Buffer.from(hex, 'hex')\n    }\n  /* c8 ignore next 17 */\n  : // eslint-disable-line operator-linebreak\n  /**\n   * @param {string|Uint8Array} hex\n   * @returns {Uint8Array}\n   */\n    (hex) => {\n      if (hex instanceof Uint8Array) {\n        return hex\n      }\n      if (!hex.length) {\n        return new Uint8Array(0)\n      }\n      return new Uint8Array(hex.split('')\n        .map((/** @type {string} */ c, /** @type {number} */ i, /** @type {string[]} */ d) => i % 2 === 0 ? `0x${c}${d[i + 1]}` : '')\n        .filter(Boolean)\n        .map((/** @type {string} */ e) => parseInt(e, 16)))\n    }\n\n/**\n * @param {Uint8Array|ArrayBuffer|ArrayBufferView} obj\n * @returns {Uint8Array}\n */\nfunction toBytes (obj) {\n  if (obj instanceof Uint8Array && obj.constructor.name === 'Uint8Array') {\n    return obj\n  }\n  if (obj instanceof ArrayBuffer) {\n    return new Uint8Array(obj)\n  }\n  if (ArrayBuffer.isView(obj)) {\n    return new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength)\n  }\n  /* c8 ignore next */\n  throw new Error('Unknown type, must be binary type')\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compare (b1, b2) {\n  /* c8 ignore next 5 */\n  if (isBuffer(b1) && isBuffer(b2)) {\n    // probably not possible to get here in the current API\n    // @ts-ignore Buffer\n    return b1.compare(b2)\n  }\n  for (let i = 0; i < b1.length; i++) {\n    if (b1[i] === b2[i]) {\n      continue\n    }\n    return b1[i] < b2[i] ? -1 : 1\n  } /* c8 ignore next 3 */\n  return 0\n}\n\n// The below code is taken from https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143\n// Licensed Apache-2.0.\n\n/**\n * @param {string} str\n * @returns {number[]}\n */\nfunction utf8ToBytes (str) {\n  const out = []\n  let p = 0\n  for (let i = 0; i < str.length; i++) {\n    let c = str.charCodeAt(i)\n    if (c < 128) {\n      out[p++] = c\n    } else if (c < 2048) {\n      out[p++] = (c >> 6) | 192\n      out[p++] = (c & 63) | 128\n    } else if (\n      ((c & 0xFC00) === 0xD800) && (i + 1) < str.length &&\n      ((str.charCodeAt(i + 1) & 0xFC00) === 0xDC00)) {\n      // Surrogate Pair\n      c = 0x10000 + ((c & 0x03FF) << 10) + (str.charCodeAt(++i) & 0x03FF)\n      out[p++] = (c >> 18) | 240\n      out[p++] = ((c >> 12) & 63) | 128\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    } else {\n      out[p++] = (c >> 12) | 224\n      out[p++] = ((c >> 6) & 63) | 128\n      out[p++] = (c & 63) | 128\n    }\n  }\n  return out\n}\n\n// The below code is mostly taken from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n\n/**\n * @param {Uint8Array} buf\n * @param {number} offset\n * @param {number} end\n * @returns {string}\n */\nfunction utf8Slice (buf, offset, end) {\n  const res = []\n\n  while (offset < end) {\n    const firstByte = buf[offset]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n    if (offset + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[offset + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[offset + 1]\n          thirdByte = buf[offset + 2]\n          fourthByte = buf[offset + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    /* c8 ignore next 5 */\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xfffd\n      bytesPerSequence = 1\n    } else if (codePoint > 0xffff) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3ff | 0xd800)\n      codePoint = 0xdc00 | codePoint & 0x3ff\n    }\n\n    res.push(codePoint)\n    offset += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\n/**\n * @param {number[]} codePoints\n * @returns {string}\n */\nexport function decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n  /* c8 ignore next 10 */\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n", "/**\n * Bl is a list of byte chunks, similar to https://github.com/rvagg/bl but for\n * writing rather than reading.\n * A Bl object accepts set() operations for individual bytes and copyTo() for\n * inserting byte arrays. These write operations don't automatically increment\n * the internal cursor so its \"length\" won't be changed. Instead, increment()\n * must be called to extend its length to cover the inserted data.\n * The toBytes() call will convert all internal memory to a single Uint8Array of\n * the correct length, truncating any data that is stored but hasn't been\n * included by an increment().\n * get() can retrieve a single byte.\n * All operations (except toBytes()) take an \"offset\" argument that will perform\n * the write at the offset _from the current cursor_. For most operations this\n * will be `0` to write at the current cursor position but it can be ahead of\n * the current cursor. Negative offsets probably work but are untested.\n */\n\n// TODO: ipjs doesn't support this, only for test files: https://github.com/mikeal/ipjs/blob/master/src/package/testFile.js#L39\nimport { alloc, concat, slice } from './byte-utils.js'\n\n// the ts-ignores in this file are almost all for the `Uint8Array|number[]` duality that exists\n// for perf reasons. Consider better approaches to this or removing it entirely, it is quite\n// risky because of some assumptions about small chunks === number[] and everything else === Uint8Array.\n\nconst defaultChunkSize = 256\n\nexport class Bl {\n  /**\n   * @param {number} [chunkSize]\n   */\n  constructor (chunkSize = defaultChunkSize) {\n    this.chunkSize = chunkSize\n    /** @type {number} */\n    this.cursor = 0\n    /** @type {number} */\n    this.maxCursor = -1\n    /** @type {(Uint8Array|number[])[]} */\n    this.chunks = []\n    // keep the first chunk around if we can to save allocations for future encodes\n    /** @type {Uint8Array|number[]|null} */\n    this._initReuseChunk = null\n  }\n\n  reset () {\n    this.cursor = 0\n    this.maxCursor = -1\n    if (this.chunks.length) {\n      this.chunks = []\n    }\n    if (this._initReuseChunk !== null) {\n      this.chunks.push(this._initReuseChunk)\n      this.maxCursor = this._initReuseChunk.length - 1\n    }\n  }\n\n  /**\n   * @param {Uint8Array|number[]} bytes\n   */\n  push (bytes) {\n    let topChunk = this.chunks[this.chunks.length - 1]\n    const newMax = this.cursor + bytes.length\n    if (newMax <= this.maxCursor + 1) {\n      // we have at least one chunk and we can fit these bytes into that chunk\n      const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n      // @ts-ignore\n      topChunk.set(bytes, chunkPos)\n    } else {\n      // can't fit it in\n      if (topChunk) {\n        // trip the last chunk to `cursor` if we need to\n        const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1\n        if (chunkPos < topChunk.length) {\n          // @ts-ignore\n          this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos)\n          this.maxCursor = this.cursor - 1\n        }\n      }\n      if (bytes.length < 64 && bytes.length < this.chunkSize) {\n        // make a new chunk and copy the new one into it\n        topChunk = alloc(this.chunkSize)\n        this.chunks.push(topChunk)\n        this.maxCursor += topChunk.length\n        if (this._initReuseChunk === null) {\n          this._initReuseChunk = topChunk\n        }\n        // @ts-ignore\n        topChunk.set(bytes, 0)\n      } else {\n        // push the new bytes in as its own chunk\n        this.chunks.push(bytes)\n        this.maxCursor += bytes.length\n      }\n    }\n    this.cursor += bytes.length\n  }\n\n  /**\n   * @param {boolean} [reset]\n   * @returns {Uint8Array}\n   */\n  toBytes (reset = false) {\n    let byts\n    if (this.chunks.length === 1) {\n      const chunk = this.chunks[0]\n      if (reset && this.cursor > chunk.length / 2) {\n        /* c8 ignore next 2 */\n        // @ts-ignore\n        byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor)\n        this._initReuseChunk = null\n        this.chunks = []\n      } else {\n        // @ts-ignore\n        byts = slice(chunk, 0, this.cursor)\n      }\n    } else {\n      // @ts-ignore\n      byts = concat(this.chunks, this.cursor)\n    }\n    if (reset) {\n      this.reset()\n    }\n    return byts\n  }\n}\n", "const decodeErrPrefix = 'CBOR decode error:'\nconst encodeErrPrefix = 'CBOR encode error:'\n\nconst uintMinorPrefixBytes = []\nuintMinorPrefixBytes[23] = 1\nuintMinorPrefixBytes[24] = 2\nuintMinorPrefixBytes[25] = 3\nuintMinorPrefixBytes[26] = 5\nuintMinorPrefixBytes[27] = 9\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} need\n */\nfunction assertEnoughData (data, pos, need) {\n  if (data.length - pos < need) {\n    throw new Error(`${decodeErrPrefix} not enough data for type`)\n  }\n}\n\nexport {\n  decodeErrPrefix,\n  encodeErrPrefix,\n  uintMinorPrefixBytes,\n  assertEnoughData\n}\n", "/* globals BigInt */\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix, assertEnoughData } from './common.js'\n\nexport const uintBoundaries = [24, 256, 65536, 4294967296, BigInt('18446744073709551616')]\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint8 (data, offset, options) {\n  assertEnoughData(data, offset, 1)\n  const value = data[offset]\n  if (options.strict === true && value < uintBoundaries[0]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint16 (data, offset, options) {\n  assertEnoughData(data, offset, 2)\n  const value = (data[offset] << 8) | data[offset + 1]\n  if (options.strict === true && value < uintBoundaries[1]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number}\n */\nexport function readUint32 (data, offset, options) {\n  assertEnoughData(data, offset, 4)\n  const value = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  if (options.strict === true && value < uintBoundaries[2]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  return value\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} offset\n * @param {DecodeOptions} options\n * @returns {number|bigint}\n */\nexport function readUint64 (data, offset, options) {\n  // assume BigInt, convert back to Number if within safe range\n  assertEnoughData(data, offset, 8)\n  const hi = (data[offset] * 16777216 /* 2 ** 24 */) + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3]\n  const lo = (data[offset + 4] * 16777216 /* 2 ** 24 */) + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7]\n  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo)\n  if (options.strict === true && value < uintBoundaries[3]) {\n    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`)\n  }\n  if (value <= Number.MAX_SAFE_INTEGER) {\n    return Number(value)\n  }\n  if (options.allowBigInt === true) {\n    return value\n  }\n  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n}\n\n/* not required thanks to quick[] list\nconst oneByteTokens = new Array(24).fill(0).map((v, i) => new Token(Type.uint, i, 1))\nexport function decodeUintCompact (data, pos, minor, options) {\n  return oneByteTokens[minor]\n}\n*/\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint8 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint16 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint32 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUint64 (data, pos, _minor, options) {\n  return new Token(Type.uint, readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeUint (buf, token) {\n  return encodeUintValue(buf, 0, token.value)\n}\n\n/**\n * @param {Bl} buf\n * @param {number} major\n * @param {number|bigint} uint\n */\nexport function encodeUintValue (buf, major, uint) {\n  if (uint < uintBoundaries[0]) {\n    const nuint = Number(uint)\n    // pack into one byte, minor=0, additional=value\n    buf.push([major | nuint])\n  } else if (uint < uintBoundaries[1]) {\n    const nuint = Number(uint)\n    // pack into two byte, minor=0, additional=24\n    buf.push([major | 24, nuint])\n  } else if (uint < uintBoundaries[2]) {\n    const nuint = Number(uint)\n    // pack into three byte, minor=0, additional=25\n    buf.push([major | 25, nuint >>> 8, nuint & 0xff])\n  } else if (uint < uintBoundaries[3]) {\n    const nuint = Number(uint)\n    // pack into five byte, minor=0, additional=26\n    buf.push([major | 26, (nuint >>> 24) & 0xff, (nuint >>> 16) & 0xff, (nuint >>> 8) & 0xff, nuint & 0xff])\n  } else {\n    const buint = BigInt(uint)\n    if (buint < uintBoundaries[4]) {\n      // pack into nine byte, minor=0, additional=27\n      const set = [major | 27, 0, 0, 0, 0, 0, 0, 0]\n      // simulate bitwise above 32 bits\n      let lo = Number(buint & BigInt(0xffffffff))\n      let hi = Number(buint >> BigInt(32) & BigInt(0xffffffff))\n      set[8] = lo & 0xff\n      lo = lo >> 8\n      set[7] = lo & 0xff\n      lo = lo >> 8\n      set[6] = lo & 0xff\n      lo = lo >> 8\n      set[5] = lo & 0xff\n      set[4] = hi & 0xff\n      hi = hi >> 8\n      set[3] = hi & 0xff\n      hi = hi >> 8\n      set[2] = hi & 0xff\n      hi = hi >> 8\n      set[1] = hi & 0xff\n      buf.push(set)\n    } else {\n      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeUint.encodedSize = function encodedSize (token) {\n  return encodeUintValue.encodedSize(token.value)\n}\n\n/**\n * @param {number} uint\n * @returns {number}\n */\nencodeUintValue.encodedSize = function encodedSize (uint) {\n  if (uint < uintBoundaries[0]) {\n    return 1\n  }\n  if (uint < uintBoundaries[1]) {\n    return 2\n  }\n  if (uint < uintBoundaries[2]) {\n    return 3\n  }\n  if (uint < uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeUint.compareTokens = function compareTokens (tok1, tok2) {\n  return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : /* c8 ignore next */ 0\n}\n", "/* eslint-env es2020 */\n\nimport { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint8 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint16 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint32 (data, pos, _minor, options) {\n  return new Token(Type.negint, -1 - uint.readUint32(data, pos + 1, options), 5)\n}\n\nconst neg1b = BigInt(-1)\nconst pos1b = BigInt(1)\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeNegint64 (data, pos, _minor, options) {\n  const int = uint.readUint64(data, pos + 1, options)\n  if (typeof int !== 'bigint') {\n    const value = -1 - int\n    if (value >= Number.MIN_SAFE_INTEGER) {\n      return new Token(Type.negint, value, 9)\n    }\n  }\n  if (options.allowBigInt !== true) {\n    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)\n  }\n  return new Token(Type.negint, neg1b - BigInt(int), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeNegint (buf, token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  uint.encodeUintValue(buf, token.type.majorEncoded, unsigned)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeNegint.encodedSize = function encodedSize (token) {\n  const negint = token.value\n  const unsigned = (typeof negint === 'bigint' ? (negint * neg1b - pos1b) : (negint * -1 - 1))\n  /* c8 ignore next 4 */\n  // handled by quickEncode, we shouldn't get here but it's included for completeness\n  if (unsigned < uint.uintBoundaries[0]) {\n    return 1\n  }\n  if (unsigned < uint.uintBoundaries[1]) {\n    return 2\n  }\n  if (unsigned < uint.uintBoundaries[2]) {\n    return 3\n  }\n  if (unsigned < uint.uintBoundaries[3]) {\n    return 5\n  }\n  return 9\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeNegint.compareTokens = function compareTokens (tok1, tok2) {\n  // opposite of the uint comparison since we store the uint version in bytes\n  return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : /* c8 ignore next */ 0\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { compare, fromString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length) {\n  assertEnoughData(data, pos, prefix + length)\n  const buf = slice(data, pos + prefix, pos + prefix + length)\n  return new Token(Type.bytes, buf, prefix + length)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeBytesCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBytes64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * `encodedBytes` allows for caching when we do a byte version of a string\n * for key sorting purposes\n * @param {Token} token\n * @returns {Uint8Array}\n */\nfunction tokenBytes (token) {\n  if (token.encodedBytes === undefined) {\n    token.encodedBytes = token.type === Type.string ? fromString(token.value) : token.value\n  }\n  // @ts-ignore c'mon\n  return token.encodedBytes\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeBytes (buf, token) {\n  const bytes = tokenBytes(token)\n  uint.encodeUintValue(buf, token.type.majorEncoded, bytes.length)\n  buf.push(bytes)\n}\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeBytes.encodedSize = function encodedSize (token) {\n  const bytes = tokenBytes(token)\n  return uint.encodeUintValue.encodedSize(bytes.length) + bytes.length\n}\n\n/**\n * @param {Token} tok1\n * @param {Token} tok2\n * @returns {number}\n */\nencodeBytes.compareTokens = function compareTokens (tok1, tok2) {\n  return compareBytes(tokenBytes(tok1), tokenBytes(tok2))\n}\n\n/**\n * @param {Uint8Array} b1\n * @param {Uint8Array} b2\n * @returns {number}\n */\nexport function compareBytes (b1, b2) {\n  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2)\n}\n", "import { Token, Type } from './token.js'\nimport { assertEnoughData, decodeErrPrefix } from './common.js'\nimport * as uint from './0uint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { toString, slice } from './byte-utils.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} prefix\n * @param {number} length\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction toToken (data, pos, prefix, length, options) {\n  const totLength = prefix + length\n  assertEnoughData(data, pos, totLength)\n  const tok = new Token(Type.string, toString(data, pos + prefix, pos + totLength), totLength)\n  if (options.retainStringBytes === true) {\n    tok.byteValue = slice(data, pos + prefix, pos + totLength)\n  }\n  return tok\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeStringCompact (data, pos, minor, options) {\n  return toToken(data, pos, 1, minor, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options), options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options), options)\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeString64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`)\n  }\n  return toToken(data, pos, 9, l, options)\n}\n\nexport const encodeString = encodeBytes\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.array, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeArrayCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArray64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeArrayIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeArray (buf, token) {\n  uint.encodeUintValue(buf, Type.array.majorEncoded, token.value)\n}\n\n// using an array as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeArray.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeArray.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport { decodeErrPrefix } from './common.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} prefix\n * @param {number} length\n * @returns {Token}\n */\nfunction toToken (_data, _pos, prefix, length) {\n  return new Token(Type.map, length, prefix)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeMapCompact (data, pos, minor, _options) {\n  return toToken(data, pos, 1, minor)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap8 (data, pos, _minor, options) {\n  return toToken(data, pos, 2, uint.readUint8(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap16 (data, pos, _minor, options) {\n  return toToken(data, pos, 3, uint.readUint16(data, pos + 1, options))\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap32 (data, pos, _minor, options) {\n  return toToken(data, pos, 5, uint.readUint32(data, pos + 1, options))\n}\n\n// TODO: maybe we shouldn't support this ..\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMap64 (data, pos, _minor, options) {\n  const l = uint.readUint64(data, pos + 1, options)\n  if (typeof l === 'bigint') {\n    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`)\n  }\n  return toToken(data, pos, 9, l)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeMapIndefinite (data, pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return toToken(data, pos, 1, Infinity)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeMap (buf, token) {\n  uint.encodeUintValue(buf, Type.map.majorEncoded, token.value)\n}\n\n// using a map as a map key, are you sure about this? we can only sort\n// by map length here, it's up to the encoder to decide to look deeper\nencodeMap.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeMap.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} minor\n * @param {DecodeOptions} _options\n * @returns {Token}\n */\nexport function decodeTagCompact (_data, _pos, minor, _options) {\n  return new Token(Type.tag, minor, 1)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag8 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint8(data, pos + 1, options), 2)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag16 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint16(data, pos + 1, options), 3)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag32 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint32(data, pos + 1, options), 5)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeTag64 (data, pos, _minor, options) {\n  return new Token(Type.tag, uint.readUint64(data, pos + 1, options), 9)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n */\nexport function encodeTag (buf, token) {\n  uint.encodeUintValue(buf, Type.tag.majorEncoded, token.value)\n}\n\nencodeTag.compareTokens = uint.encodeUint.compareTokens\n\n/**\n * @param {Token} token\n * @returns {number}\n */\nencodeTag.encodedSize = function encodedSize (token) {\n  return uint.encodeUintValue.encodedSize(token.value)\n}\n", "// TODO: shift some of the bytes logic to bytes-utils so we can use Buffer\n// where possible\n\nimport { Token, Type } from './token.js'\nimport { decodeErrPrefix } from './common.js'\nimport { encodeUint } from './0uint.js'\n\n/**\n * @typedef {import('./bl.js').Bl} Bl\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n */\n\nconst MINOR_FALSE = 20\nconst MINOR_TRUE = 21\nconst MINOR_NULL = 22\nconst MINOR_UNDEFINED = 23\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeUndefined (_data, _pos, _minor, options) {\n  if (options.allowUndefined === false) {\n    throw new Error(`${decodeErrPrefix} undefined values are not supported`)\n  } else if (options.coerceUndefinedToNull === true) {\n    return new Token(Type.null, null, 1)\n  }\n  return new Token(Type.undefined, undefined, 1)\n}\n\n/**\n * @param {Uint8Array} _data\n * @param {number} _pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeBreak (_data, _pos, _minor, options) {\n  if (options.allowIndefinite === false) {\n    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`)\n  }\n  return new Token(Type.break, undefined, 1)\n}\n\n/**\n * @param {number} value\n * @param {number} bytes\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nfunction createToken (value, bytes, options) {\n  if (options) {\n    if (options.allowNaN === false && Number.isNaN(value)) {\n      throw new Error(`${decodeErrPrefix} NaN values are not supported`)\n    }\n    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {\n      throw new Error(`${decodeErrPrefix} Infinity values are not supported`)\n    }\n  }\n  return new Token(Type.float, value, bytes)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat16 (data, pos, _minor, options) {\n  return createToken(readFloat16(data, pos + 1), 3, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat32 (data, pos, _minor, options) {\n  return createToken(readFloat32(data, pos + 1), 5, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} _minor\n * @param {DecodeOptions} options\n * @returns {Token}\n */\nexport function decodeFloat64 (data, pos, _minor, options) {\n  return createToken(readFloat64(data, pos + 1), 9, options)\n}\n\n/**\n * @param {Bl} buf\n * @param {Token} token\n * @param {EncodeOptions} options\n */\nexport function encodeFloat (buf, token, options) {\n  const float = token.value\n\n  if (float === false) {\n    buf.push([Type.float.majorEncoded | MINOR_FALSE])\n  } else if (float === true) {\n    buf.push([Type.float.majorEncoded | MINOR_TRUE])\n  } else if (float === null) {\n    buf.push([Type.float.majorEncoded | MINOR_NULL])\n  } else if (float === undefined) {\n    buf.push([Type.float.majorEncoded | MINOR_UNDEFINED])\n  } else {\n    let decoded\n    let success = false\n    if (!options || options.float64 !== true) {\n      encodeFloat16(float)\n      decoded = readFloat16(ui8a, 1)\n      if (float === decoded || Number.isNaN(float)) {\n        ui8a[0] = 0xf9\n        buf.push(ui8a.slice(0, 3))\n        success = true\n      } else {\n        encodeFloat32(float)\n        decoded = readFloat32(ui8a, 1)\n        if (float === decoded) {\n          ui8a[0] = 0xfa\n          buf.push(ui8a.slice(0, 5))\n          success = true\n        }\n      }\n    }\n    if (!success) {\n      encodeFloat64(float)\n      decoded = readFloat64(ui8a, 1)\n      ui8a[0] = 0xfb\n      buf.push(ui8a.slice(0, 9))\n    }\n  }\n}\n\n/**\n * @param {Token} token\n * @param {EncodeOptions} options\n * @returns {number}\n */\nencodeFloat.encodedSize = function encodedSize (token, options) {\n  const float = token.value\n\n  if (float === false || float === true || float === null || float === undefined) {\n    return 1\n  }\n\n  if (!options || options.float64 !== true) {\n    encodeFloat16(float)\n    let decoded = readFloat16(ui8a, 1)\n    if (float === decoded || Number.isNaN(float)) {\n      return 3\n    }\n    encodeFloat32(float)\n    decoded = readFloat32(ui8a, 1)\n    if (float === decoded) {\n      return 5\n    }\n  }\n  return 9\n}\n\nconst buffer = new ArrayBuffer(9)\nconst dataView = new DataView(buffer, 1)\nconst ui8a = new Uint8Array(buffer, 0)\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat16 (inp) {\n  if (inp === Infinity) {\n    dataView.setUint16(0, 0x7c00, false)\n  } else if (inp === -Infinity) {\n    dataView.setUint16(0, 0xfc00, false)\n  } else if (Number.isNaN(inp)) {\n    dataView.setUint16(0, 0x7e00, false)\n  } else {\n    dataView.setFloat32(0, inp)\n    const valu32 = dataView.getUint32(0)\n    const exponent = (valu32 & 0x7f800000) >> 23\n    const mantissa = valu32 & 0x7fffff\n\n    /* c8 ignore next 6 */\n    if (exponent === 0xff) {\n      // too big, Infinity, but this should be hard (impossible?) to trigger\n      dataView.setUint16(0, 0x7c00, false)\n    } else if (exponent === 0x00) {\n      // 0.0, -0.0 and subnormals, shouldn't be possible to get here because 0.0 should be counted as an int\n      dataView.setUint16(0, ((inp & 0x80000000) >> 16) | (mantissa >> 13), false)\n    } else { // standard numbers\n      // chunks of logic here borrowed from https://github.com/PJK/libcbor/blob/c78f437182533e3efa8d963ff4b945bb635c2284/src/cbor/encoding.c#L127\n      const logicalExponent = exponent - 127\n      // Now we know that 2^exponent <= 0 logically\n      /* c8 ignore next 6 */\n      if (logicalExponent < -24) {\n        /* No unambiguous representation exists, this float is not a half float\n          and is too small to be represented using a half, round off to zero.\n          Consistent with the reference implementation. */\n        // should be difficult (impossible?) to get here in JS\n        dataView.setUint16(0, 0)\n      } else if (logicalExponent < -14) {\n        /* Offset the remaining decimal places by shifting the significand, the\n          value is lost. This is an implementation decision that works around the\n          absence of standard half-float in the language. */\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | /* sign bit */ (1 << (24 + logicalExponent)), false)\n      } else {\n        dataView.setUint16(0, ((valu32 & 0x80000000) >> 16) | ((logicalExponent + 15) << 10) | (mantissa >> 13), false)\n      }\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat16 (ui8a, pos) {\n  if (ui8a.length - pos < 2) {\n    throw new Error(`${decodeErrPrefix} not enough data for float16`)\n  }\n\n  const half = (ui8a[pos] << 8) + ui8a[pos + 1]\n  if (half === 0x7c00) {\n    return Infinity\n  }\n  if (half === 0xfc00) {\n    return -Infinity\n  }\n  if (half === 0x7e00) {\n    return NaN\n  }\n  const exp = (half >> 10) & 0x1f\n  const mant = half & 0x3ff\n  let val\n  if (exp === 0) {\n    val = mant * (2 ** -24)\n  } else if (exp !== 31) {\n    val = (mant + 1024) * (2 ** (exp - 25))\n  /* c8 ignore next 4 */\n  } else {\n    // may not be possible to get here\n    val = mant === 0 ? Infinity : NaN\n  }\n  return (half & 0x8000) ? -val : val\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat32 (inp) {\n  dataView.setFloat32(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat32 (ui8a, pos) {\n  if (ui8a.length - pos < 4) {\n    throw new Error(`${decodeErrPrefix} not enough data for float32`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 4).getFloat32(0, false)\n}\n\n/**\n * @param {number} inp\n */\nfunction encodeFloat64 (inp) {\n  dataView.setFloat64(0, inp, false)\n}\n\n/**\n * @param {Uint8Array} ui8a\n * @param {number} pos\n * @returns {number}\n */\nfunction readFloat64 (ui8a, pos) {\n  if (ui8a.length - pos < 8) {\n    throw new Error(`${decodeErrPrefix} not enough data for float64`)\n  }\n  const offset = (ui8a.byteOffset || 0) + pos\n  return new DataView(ui8a.buffer, offset, 8).getFloat64(0, false)\n}\n\n/**\n * @param {Token} _tok1\n * @param {Token} _tok2\n * @returns {number}\n */\nencodeFloat.compareTokens = encodeUint.compareTokens\n/*\nencodeFloat.compareTokens = function compareTokens (_tok1, _tok2) {\n  return _tok1\n  throw new Error(`${encodeErrPrefix} cannot use floats as map keys`)\n}\n*/\n", "import { Token, Type } from './token.js'\nimport * as uint from './0uint.js'\nimport * as negint from './1negint.js'\nimport * as bytes from './2bytes.js'\nimport * as string from './3string.js'\nimport * as array from './4array.js'\nimport * as map from './5map.js'\nimport * as tag from './6tag.js'\nimport * as float from './7float.js'\nimport { decodeErrPrefix } from './common.js'\nimport { fromArray } from './byte-utils.js'\n\n/**\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n */\n\n/**\n * @param {Uint8Array} data\n * @param {number} pos\n * @param {number} minor\n */\nfunction invalidMinor (data, pos, minor) {\n  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`)\n}\n\n/**\n * @param {string} msg\n * @returns {()=>any}\n */\nfunction errorer (msg) {\n  return () => { throw new Error(`${decodeErrPrefix} ${msg}`) }\n}\n\n/** @type {((data:Uint8Array, pos:number, minor:number, options?:DecodeOptions) => any)[]} */\nexport const jump = []\n\n// unsigned integer, 0x00..0x17 (0..23)\nfor (let i = 0; i <= 0x17; i++) {\n  jump[i] = invalidMinor // uint.decodeUintCompact, handled by quick[]\n}\njump[0x18] = uint.decodeUint8 // unsigned integer, one-byte uint8_t follows\njump[0x19] = uint.decodeUint16 // unsigned integer, two-byte uint16_t follows\njump[0x1a] = uint.decodeUint32 // unsigned integer, four-byte uint32_t follows\njump[0x1b] = uint.decodeUint64 // unsigned integer, eight-byte uint64_t follows\njump[0x1c] = invalidMinor\njump[0x1d] = invalidMinor\njump[0x1e] = invalidMinor\njump[0x1f] = invalidMinor\n// negative integer, -1-0x00..-1-0x17 (-1..-24)\nfor (let i = 0x20; i <= 0x37; i++) {\n  jump[i] = invalidMinor // negintDecode, handled by quick[]\n}\njump[0x38] = negint.decodeNegint8 // negative integer, -1-n one-byte uint8_t for n follows\njump[0x39] = negint.decodeNegint16 // negative integer, -1-n two-byte uint16_t for n follows\njump[0x3a] = negint.decodeNegint32 // negative integer, -1-n four-byte uint32_t for follows\njump[0x3b] = negint.decodeNegint64 // negative integer, -1-n eight-byte uint64_t for follows\njump[0x3c] = invalidMinor\njump[0x3d] = invalidMinor\njump[0x3e] = invalidMinor\njump[0x3f] = invalidMinor\n// byte string, 0x00..0x17 bytes follow\nfor (let i = 0x40; i <= 0x57; i++) {\n  jump[i] = bytes.decodeBytesCompact\n}\njump[0x58] = bytes.decodeBytes8 // byte string, one-byte uint8_t for n, and then n bytes follow\njump[0x59] = bytes.decodeBytes16 // byte string, two-byte uint16_t for n, and then n bytes follow\njump[0x5a] = bytes.decodeBytes32 // byte string, four-byte uint32_t for n, and then n bytes follow\njump[0x5b] = bytes.decodeBytes64 // byte string, eight-byte uint64_t for n, and then n bytes follow\njump[0x5c] = invalidMinor\njump[0x5d] = invalidMinor\njump[0x5e] = invalidMinor\njump[0x5f] = errorer('indefinite length bytes/strings are not supported') // byte string, byte strings follow, terminated by \"break\"\n// UTF-8 string 0x00..0x17 bytes follow\nfor (let i = 0x60; i <= 0x77; i++) {\n  jump[i] = string.decodeStringCompact\n}\njump[0x78] = string.decodeString8 // UTF-8 string, one-byte uint8_t for n, and then n bytes follow\njump[0x79] = string.decodeString16 // UTF-8 string, two-byte uint16_t for n, and then n bytes follow\njump[0x7a] = string.decodeString32 // UTF-8 string, four-byte uint32_t for n, and then n bytes follow\njump[0x7b] = string.decodeString64 // UTF-8 string, eight-byte uint64_t for n, and then n bytes follow\njump[0x7c] = invalidMinor\njump[0x7d] = invalidMinor\njump[0x7e] = invalidMinor\njump[0x7f] = errorer('indefinite length bytes/strings are not supported') // UTF-8 strings follow, terminated by \"break\"\n// array, 0x00..0x17 data items follow\nfor (let i = 0x80; i <= 0x97; i++) {\n  jump[i] = array.decodeArrayCompact\n}\njump[0x98] = array.decodeArray8 // array, one-byte uint8_t for n, and then n data items follow\njump[0x99] = array.decodeArray16 // array, two-byte uint16_t for n, and then n data items follow\njump[0x9a] = array.decodeArray32 // array, four-byte uint32_t for n, and then n data items follow\njump[0x9b] = array.decodeArray64 // array, eight-byte uint64_t for n, and then n data items follow\njump[0x9c] = invalidMinor\njump[0x9d] = invalidMinor\njump[0x9e] = invalidMinor\njump[0x9f] = array.decodeArrayIndefinite // array, data items follow, terminated by \"break\"\n// map, 0x00..0x17 pairs of data items follow\nfor (let i = 0xa0; i <= 0xb7; i++) {\n  jump[i] = map.decodeMapCompact\n}\njump[0xb8] = map.decodeMap8 // map, one-byte uint8_t for n, and then n pairs of data items follow\njump[0xb9] = map.decodeMap16 // map, two-byte uint16_t for n, and then n pairs of data items follow\njump[0xba] = map.decodeMap32 // map, four-byte uint32_t for n, and then n pairs of data items follow\njump[0xbb] = map.decodeMap64 // map, eight-byte uint64_t for n, and then n pairs of data items follow\njump[0xbc] = invalidMinor\njump[0xbd] = invalidMinor\njump[0xbe] = invalidMinor\njump[0xbf] = map.decodeMapIndefinite // map, pairs of data items follow, terminated by \"break\"\n// tags\nfor (let i = 0xc0; i <= 0xd7; i++) {\n  jump[i] = tag.decodeTagCompact\n}\njump[0xd8] = tag.decodeTag8\njump[0xd9] = tag.decodeTag16\njump[0xda] = tag.decodeTag32\njump[0xdb] = tag.decodeTag64\njump[0xdc] = invalidMinor\njump[0xdd] = invalidMinor\njump[0xde] = invalidMinor\njump[0xdf] = invalidMinor\n// 0xe0..0xf3 simple values, unsupported\nfor (let i = 0xe0; i <= 0xf3; i++) {\n  jump[i] = errorer('simple values are not supported')\n}\njump[0xf4] = invalidMinor // false, handled by quick[]\njump[0xf5] = invalidMinor // true, handled by quick[]\njump[0xf6] = invalidMinor // null, handled by quick[]\njump[0xf7] = float.decodeUndefined // undefined\njump[0xf8] = errorer('simple values are not supported') // simple value, one byte follows, unsupported\njump[0xf9] = float.decodeFloat16 // half-precision float (two-byte IEEE 754)\njump[0xfa] = float.decodeFloat32 // single-precision float (four-byte IEEE 754)\njump[0xfb] = float.decodeFloat64 // double-precision float (eight-byte IEEE 754)\njump[0xfc] = invalidMinor\njump[0xfd] = invalidMinor\njump[0xfe] = invalidMinor\njump[0xff] = float.decodeBreak // \"break\" stop code\n\n/** @type {Token[]} */\nexport const quick = []\n// ints <24\nfor (let i = 0; i < 24; i++) {\n  quick[i] = new Token(Type.uint, i, 1)\n}\n// negints >= -24\nfor (let i = -1; i >= -24; i--) {\n  quick[31 - i] = new Token(Type.negint, i, 1)\n}\n// empty bytes\nquick[0x40] = new Token(Type.bytes, new Uint8Array(0), 1)\n// empty string\nquick[0x60] = new Token(Type.string, '', 1)\n// empty list\nquick[0x80] = new Token(Type.array, 0, 1)\n// empty map\nquick[0xa0] = new Token(Type.map, 0, 1)\n// false\nquick[0xf4] = new Token(Type.false, false, 1)\n// true\nquick[0xf5] = new Token(Type.true, true, 1)\n// null\nquick[0xf6] = new Token(Type.null, null, 1)\n\n/**\n * @param {Token} token\n * @returns {Uint8Array|undefined}\n */\nexport function quickEncodeToken (token) {\n  switch (token.type) {\n    case Type.false:\n      return fromArray([0xf4])\n    case Type.true:\n      return fromArray([0xf5])\n    case Type.null:\n      return fromArray([0xf6])\n    case Type.bytes:\n      if (!token.value.length) {\n        return fromArray([0x40])\n      }\n      return\n    case Type.string:\n      if (token.value === '') {\n        return fromArray([0x60])\n      }\n      return\n    case Type.array:\n      if (token.value === 0) {\n        return fromArray([0x80])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.map:\n      if (token.value === 0) {\n        return fromArray([0xa0])\n      }\n      /* c8 ignore next 2 */\n      // shouldn't be possible if this were called when there was only one token\n      return\n    case Type.uint:\n      if (token.value < 24) {\n        return fromArray([Number(token.value)])\n      }\n      return\n    case Type.negint:\n      if (token.value >= -24) {\n        return fromArray([31 - Number(token.value)])\n      }\n  }\n}\n", "import { is } from './is.js'\nimport { Token, Type } from './token.js'\nimport { Bl } from './bl.js'\nimport { encodeErrPrefix } from './common.js'\nimport { quickEncodeToken } from './jump.js'\nimport { asU8A, compare } from './byte-utils.js'\n\nimport { encodeUint } from './0uint.js'\nimport { encodeNegint } from './1negint.js'\nimport { encodeBytes } from './2bytes.js'\nimport { encodeString } from './3string.js'\nimport { encodeArray } from './4array.js'\nimport { encodeMap } from './5map.js'\nimport { encodeTag } from './6tag.js'\nimport { encodeFloat } from './7float.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').OptionalTypeEncoder} OptionalTypeEncoder\n * @typedef {import('../interface').Reference} Reference\n * @typedef {import('../interface').StrictTypeEncoder} StrictTypeEncoder\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n}\n\n/** @type {EncodeOptions} */\nexport const rfc8949EncodeOptions = Object.freeze({\n  float64: true,\n  mapSorter: rfc8949MapSorter,\n  quickEncodeToken\n})\n\n/** @returns {TokenTypeEncoder[]} */\nexport function makeCborEncoders () {\n  const encoders = []\n  encoders[Type.uint.major] = encodeUint\n  encoders[Type.negint.major] = encodeNegint\n  encoders[Type.bytes.major] = encodeBytes\n  encoders[Type.string.major] = encodeString\n  encoders[Type.array.major] = encodeArray\n  encoders[Type.map.major] = encodeMap\n  encoders[Type.tag.major] = encodeTag\n  encoders[Type.float.major] = encodeFloat\n  return encoders\n}\n\nconst cborEncoders = makeCborEncoders()\n\nconst buf = new Bl()\n\n/** @implements {Reference} */\nclass Ref {\n  /**\n   * @param {object|any[]} obj\n   * @param {Reference|undefined} parent\n   */\n  constructor (obj, parent) {\n    this.obj = obj\n    this.parent = parent\n  }\n\n  /**\n   * @param {object|any[]} obj\n   * @returns {boolean}\n   */\n  includes (obj) {\n    /** @type {Reference|undefined} */\n    let p = this\n    do {\n      if (p.obj === obj) {\n        return true\n      }\n    } while (p = p.parent) // eslint-disable-line\n    return false\n  }\n\n  /**\n   * @param {Reference|undefined} stack\n   * @param {object|any[]} obj\n   * @returns {Reference}\n   */\n  static createCheck (stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${encodeErrPrefix} object contains circular references`)\n    }\n    return new Ref(obj, stack)\n  }\n}\n\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n}\n\n/** @type {{[typeName: string]: StrictTypeEncoder}} */\nconst typeEncoders = {\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  number (obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj)\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  bigint (obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj)\n    } else {\n      return new Token(Type.negint, obj)\n    }\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Uint8Array (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  string (obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj)\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  boolean (obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  null (_obj, _typ, _options, _refStack) {\n    return simpleTokens.null\n  },\n\n  /**\n   * @param {any} _obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  undefined (_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  ArrayBuffer (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} _options\n   * @param {Reference} [_refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  DataView (obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} _typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Array (obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)]\n      }\n      return simpleTokens.emptyArray\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    const entries = []\n    let i = 0\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack)\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.array, obj.length), entries]\n  },\n\n  /**\n   * @param {any} obj\n   * @param {string} typ\n   * @param {EncodeOptions} options\n   * @param {Reference} [refStack]\n   * @returns {TokenOrNestedTokens}\n   */\n  Object (obj, typ, options, refStack) {\n    // could be an Object or a Map\n    const isMap = typ !== 'Object'\n    // it's slightly quicker to use Object.keys() than Object.entries()\n    const keys = isMap ? obj.keys() : Object.keys(obj)\n    const length = isMap ? obj.size : keys.length\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)]\n      }\n      return simpleTokens.emptyMap\n    }\n    refStack = Ref.createCheck(refStack, obj)\n    /** @type {TokenOrNestedTokens[]} */\n    const entries = []\n    let i = 0\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ]\n    }\n    sortMapEntries(entries, options)\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)]\n    }\n    return [new Token(Type.map, length), entries]\n  }\n}\n\ntypeEncoders.Map = typeEncoders.Object\ntypeEncoders.Buffer = typeEncoders.Uint8Array\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${typ}Array`] = typeEncoders.DataView\n}\n\n/**\n * @param {any} obj\n * @param {EncodeOptions} [options]\n * @param {Reference} [refStack]\n * @returns {TokenOrNestedTokens}\n */\nfunction objectToTokens (obj, options = {}, refStack) {\n  const typ = is(obj)\n  const customTypeEncoder = (options && options.typeEncoders && /** @type {OptionalTypeEncoder} */ options.typeEncoders[typ]) || typeEncoders[typ]\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack)\n    if (tokens != null) {\n      return tokens\n    }\n  }\n  const typeEncoder = typeEncoders[typ]\n  if (!typeEncoder) {\n    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`)\n  }\n  return typeEncoder(obj, typ, options, refStack)\n}\n\n/*\nCBOR key sorting is a mess.\n\nThe canonicalisation recommendation from https://tools.ietf.org/html/rfc7049#section-3.9\nincludes the wording:\n\n> The keys in every map must be sorted lowest value to highest.\n> Sorting is performed on the bytes of the representation of the key\n> data items without paying attention to the 3/5 bit splitting for\n> major types.\n> ...\n>  *  If two keys have different lengths, the shorter one sorts\n      earlier;\n>  *  If two keys have the same length, the one with the lower value\n      in (byte-wise) lexical order sorts earlier.\n\n1. It is not clear what \"bytes of the representation of the key\" means: is it\n   the CBOR representation, or the binary representation of the object itself?\n   Consider the int and uint difference here.\n2. It is not clear what \"without paying attention to\" means: do we include it\n   and compare on that? Or do we omit the special prefix byte, (mostly) treating\n   the key in its plain binary representation form.\n\nThe FIDO 2.0: Client To Authenticator Protocol spec takes the original CBOR\nwording and clarifies it according to their understanding.\nhttps://fidoalliance.org/specs/fido-v2.0-rd-20170927/fido-client-to-authenticator-protocol-v2.0-rd-20170927.html#message-encoding\n\n> The keys in every map must be sorted lowest value to highest. Sorting is\n> performed on the bytes of the representation of the key data items without\n> paying attention to the 3/5 bit splitting for major types. The sorting rules\n> are:\n>  * If the major types are different, the one with the lower value in numerical\n>    order sorts earlier.\n>  * If two keys have different lengths, the shorter one sorts earlier;\n>  * If two keys have the same length, the one with the lower value in\n>    (byte-wise) lexical order sorts earlier.\n\nSome other implementations, such as borc, do a full encode then do a\nlength-first, byte-wise-second comparison:\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/encoder.js#L358\nhttps://github.com/dignifiedquire/borc/blob/b6bae8b0bcde7c3976b0f0f0957208095c392a36/src/utils.js#L143-L151\n\nThis has the benefit of being able to easily handle arbitrary keys, including\ncomplex types (maps and arrays).\n\nWe'll opt for the FIDO approach, since it affords some efficies since we don't\nneed a full encode of each key to determine order and can defer to the types\nto determine how to most efficiently order their values (i.e. int and uint\nordering can be done on the numbers, no need for byte-wise, for example).\n\nRecommendation: stick to single key types or you'll get into trouble, and prefer\nstring keys because it's much simpler that way.\n*/\n\n/**\n * @param {TokenOrNestedTokens[]} entries\n * @param {EncodeOptions} options\n */\nfunction sortMapEntries (entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter)\n  }\n}\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  // the key position ([0]) could have a single token or an array\n  // almost always it'll be a single token but complex key might get involved\n  /* c8 ignore next 2 */\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0]\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0]\n\n  // different key types\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type)\n  }\n\n  const major = keyToken1.type.major\n  // TODO: handle case where cmp === 0 but there are more keyToken e. complex type)\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2)\n  /* c8 ignore next 5 */\n  if (tcmp === 0) {\n    // duplicate key or complex type where the first token matched,\n    // i.e. a map or array and we're only comparing the opening token\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone')\n  }\n  return tcmp\n}\n\n/**\n * @typedef {Token & { _keyBytes?: Uint8Array }} TokenEx\n *\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction rfc8949MapSorter (e1, e2) {\n  if (e1[0] instanceof Token && e2[0] instanceof Token) {\n    const t1 = /** @type {TokenEx} */ (e1[0])\n    const t2 = /** @type {TokenEx} */ (e2[0])\n\n    if (!t1._keyBytes) {\n      t1._keyBytes = encodeRfc8949(t1.value)\n    }\n\n    if (!t2._keyBytes) {\n      t2._keyBytes = encodeRfc8949(t2.value)\n    }\n\n    return compare(t1._keyBytes, t2._keyBytes)\n  }\n\n  throw new Error('rfc8949MapSorter: complex key types are not supported yet')\n}\n\n/**\n * @param {any} data\n * @returns {Uint8Array}\n */\nfunction encodeRfc8949 (data) {\n  return encodeCustom(data, cborEncoders, rfc8949EncodeOptions)\n}\n\n/**\n * @param {Bl} buf\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n */\nfunction tokensToEncoded (buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options)\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options)\n  }\n}\n\n/**\n * @param {any} data\n * @param {TokenTypeEncoder[]} encoders\n * @param {EncodeOptions} options\n * @returns {Uint8Array}\n */\nfunction encodeCustom (data, encoders, options) {\n  const tokens = objectToTokens(data, options)\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens)\n    if (quickBytes) {\n      return quickBytes\n    }\n    const encoder = encoders[tokens.type.major]\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options)\n      const buf = new Bl(size)\n      encoder(buf, tokens, options)\n      /* c8 ignore next 4 */\n      // this would be a problem with encodedSize() functions\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`)\n      }\n      return asU8A(buf.chunks[0])\n    }\n  }\n  buf.reset()\n  tokensToEncoded(buf, tokens, encoders, options)\n  return buf.toBytes(true)\n}\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  return encodeCustom(data, cborEncoders, options)\n}\n\nexport { objectToTokens, encode, encodeCustom, Ref }\n", "import { decodeErrPrefix } from './common.js'\nimport { Type } from './token.js'\nimport { jump, quick } from './jump.js'\n\n/**\n * @typedef {import('./token.js').Token} Token\n * @typedef {import('../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../interface').DecodeTokenizer} DecodeTokenizer\n */\n\nconst defaultDecodeOptions = {\n  strict: false,\n  allowIndefinite: true,\n  allowUndefined: true,\n  allowBigInt: true\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokeniser {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  next () {\n    const byt = this.data[this._pos]\n    let token = quick[byt]\n    if (token === undefined) {\n      const decoder = jump[byt]\n      /* c8 ignore next 4 */\n      // if we're here then there's something wrong with our jump or quick lists!\n      if (!decoder) {\n        throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, '0')})`)\n      }\n      const minor = byt & 31\n      token = decoder(this.data, this._pos, minor, this.options)\n    }\n    // @ts-ignore we get to assume encodedLength is set (crossing fingers slightly)\n    this._pos += token.encodedLength\n    return token\n  }\n}\n\nconst DONE = Symbol.for('DONE')\nconst BREAK = Symbol.for('BREAK')\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToArray (token, tokeniser, options) {\n  const arr = []\n  for (let i = 0; i < token.value; i++) {\n    const value = tokensToObject(tokeniser, options)\n    if (value === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length array\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)\n    }\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`)\n    }\n    arr[i] = value\n  }\n  return arr\n}\n\n/**\n * @param {Token} token\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokenToMap (token, tokeniser, options) {\n  const useMaps = options.useMaps === true\n  const obj = useMaps ? undefined : {}\n  const m = useMaps ? new Map() : undefined\n  for (let i = 0; i < token.value; i++) {\n    const key = tokensToObject(tokeniser, options)\n    if (key === BREAK) {\n      if (token.value === Infinity) {\n        // normal end to indefinite length map\n        break\n      }\n      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)\n    }\n    if (key === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`)\n    }\n    if (useMaps !== true && typeof key !== 'string') {\n      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`)\n    }\n    if (options.rejectDuplicateMapKeys === true) {\n      // @ts-ignore\n      if ((useMaps && m.has(key)) || (!useMaps && (key in obj))) {\n        throw new Error(`${decodeErrPrefix} found repeat map key \"${key}\"`)\n      }\n    }\n    const value = tokensToObject(tokeniser, options)\n    if (value === DONE) {\n      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`)\n    }\n    if (useMaps) {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      m.set(key, value)\n    } else {\n      // @ts-ignore TODO reconsider this .. maybe needs to be strict about key types\n      obj[key] = value\n    }\n  }\n  // @ts-ignore c'mon man\n  return useMaps ? m : obj\n}\n\n/**\n * @param {DecodeTokenizer} tokeniser\n * @param {DecodeOptions} options\n * @returns {any|BREAK|DONE}\n */\nfunction tokensToObject (tokeniser, options) {\n  // should we support array as an argument?\n  // check for tokenIter[Symbol.iterator] and replace tokenIter with what that returns?\n  if (tokeniser.done()) {\n    return DONE\n  }\n\n  const token = tokeniser.next()\n\n  if (token.type === Type.break) {\n    return BREAK\n  }\n\n  if (token.type.terminal) {\n    return token.value\n  }\n\n  if (token.type === Type.array) {\n    return tokenToArray(token, tokeniser, options)\n  }\n\n  if (token.type === Type.map) {\n    return tokenToMap(token, tokeniser, options)\n  }\n\n  if (token.type === Type.tag) {\n    if (options.tags && typeof options.tags[token.value] === 'function') {\n      const tagged = tokensToObject(tokeniser, options)\n      return options.tags[token.value](tagged)\n    }\n    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`)\n  }\n  /* c8 ignore next */\n  throw new Error('unsupported')\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  if (!(data instanceof Uint8Array)) {\n    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`)\n  }\n  options = Object.assign({}, defaultDecodeOptions, options)\n  const tokeniser = options.tokenizer || new Tokeniser(data, options)\n  const decoded = tokensToObject(tokeniser, options)\n  if (decoded === DONE) {\n    throw new Error(`${decodeErrPrefix} did not find any content to decode`)\n  }\n  if (decoded === BREAK) {\n    throw new Error(`${decodeErrPrefix} got unexpected break`)\n  }\n  return [decoded, data.subarray(tokeniser.pos())]\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  const [decoded, remainder] = decodeFirst(data, options)\n  if (remainder.length > 0) {\n    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`)\n  }\n  return decoded\n}\n\nexport { Tokeniser, tokensToObject, decode, decodeFirst }\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\n/**\n * @param {Map<any, any>} map\n * @returns {null}\n */\nfunction mapEncoder (map) {\n  for (const key of map.keys()) {\n    if (typeof key !== 'string' || key.length === 0) {\n      throw new Error('Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded')\n    }\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Map: mapEncoder,\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n", "export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {import('./ucan').ToString<T>} text\n * @returns {import('./ucan').ByteView<T>}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n * @template T\n * @param {import('./ucan').ByteView<T>} bytes\n * @returns {import('./ucan').ToString<T>}\n */\nexport const decode = bytes => decoder.decode(bytes)\n", "import { CID, format, toJSON, fromJSON } from './cid.js'\nimport type * as API from './link/interface.js'\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nconst DAG_PB_CODE = 0x70\n// eslint-disable-next-line\nconst SHA_256_CODE = 0x12\n\n/**\n * Simplified version of `create` for CIDv0.\n */\nexport function createLegacy (digest: API.MultihashDigest<typeof SHA_256_CODE>): API.LegacyLink {\n  return CID.create(0, DAG_PB_CODE, digest)\n}\n\n/**\n * Simplified version of `create` for CIDv1.\n *\n * @param code - Content encoding format code.\n * @param digest - Miltihash of the content.\n */\nexport function create <Data, Code extends number, Alg extends number> (code: Code, digest: API.MultihashDigest<Alg>): API.Link<Data, Code, Alg> {\n  return CID.create(1, code, digest)\n}\n\n/**\n * Type predicate returns true if value is the link.\n */\nexport function isLink <L extends API.Link<unknown, number, number, 0 | 1>> (value: unknown | L): value is L & CID {\n  if (value == null) {\n    return false\n  }\n\n  const withSlash = value as { '/'?: Uint8Array, bytes: Uint8Array }\n\n  if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {\n    return true\n  }\n\n  const withAsCID = value as { asCID?: unknown }\n\n  if (withAsCID.asCID === value) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * Takes cid in a string representation and creates an instance. If `base`\n * decoder is not provided will use a default from the configuration. It will\n * throw an error if encoding of the CID is not compatible with supplied (or\n * a default decoder).\n */\nexport function parse <Prefix extends string, Data, Code extends number, Alg extends number, Ver extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>, base?: API.MultibaseDecoder<Prefix>): API.Link<Data, Code, Alg, Ver> {\n  return CID.parse(source, base)\n}\n\nexport { format, toJSON, fromJSON }\n\n/**\n * Decoded a CID from its binary representation. The byte array must contain\n * only the CID with no additional bytes.\n *\n * An error will be thrown if the bytes provided do not contain a valid\n * binary representation of a CID.\n */\nexport function decode <Data, Code extends number, Alg extends number, Ver extends API.Version> (bytes: API.ByteView<API.Link<Data, Code, Alg, Ver>>): API.Link<Data, Code, Alg, Ver> {\n  return CID.decode(bytes)\n}\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\nimport type { DigestOptions } from './hasher.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array, options?: DigestOptions): Digest.Digest<typeof code, number> {\n  if (options?.truncate != null && options.truncate !== input.byteLength) {\n    if (options.truncate < 0 || options.truncate > input.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`)\n    }\n\n    input = input.subarray(0, options.truncate)\n  }\n\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "import * as UCAN from \"./ucan.js\"\nimport { base58btc } from \"multiformats/bases/base58\"\nimport { varint } from \"multiformats\"\nimport * as UTF8 from \"./utf8.js\"\n\nconst DID_PREFIX = \"did:\"\nconst DID_PREFIX_SIZE = DID_PREFIX.length\nconst DID_KEY_PREFIX = `did:key:`\nconst DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length\n\nexport const ED25519 = 0xed\nexport const RSA = 0x1205\nexport const P256 = 0x1200\nexport const P384 = 0x1201\nexport const P521 = 0x1202\nexport const SECP256K1 = 0xe7\nexport const BLS12381G1 = 0xea\nexport const BLS12381G2 = 0xeb\nexport const DID_CORE = 0x0d1d\nconst METHOD_OFFSET = varint.encodingLength(DID_CORE)\n\n/**\n * @typedef {typeof ED25519|typeof RSA|typeof P256|typeof P384|typeof P521|typeof DID_CORE} Code\n */\n\n/**\n * Parses a DID string into a DID buffer view\n *\n * @template {UCAN.DID} ID\n * @param {ID|UCAN.ToString<unknown>} did\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const parse = did => {\n  if (!did.startsWith(DID_PREFIX)) {\n    throw new RangeError(`Invalid DID \"${did}\", must start with 'did:'`)\n  } else if (did.startsWith(DID_KEY_PREFIX)) {\n    const key = base58btc.decode(did.slice(DID_KEY_PREFIX_SIZE))\n    return decode(key)\n  } else {\n    const suffix = UTF8.encode(did.slice(DID_PREFIX_SIZE))\n    const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET)\n    varint.encodeTo(DID_CORE, bytes)\n    bytes.set(suffix, METHOD_OFFSET)\n    return new DID(bytes)\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} id\n * @returns {ID}\n */\nexport const format = id => id.did()\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.PrincipalView<ID>|UCAN.ByteView<UCAN.Principal<ID>>|UCAN.Principal<ID>|ID|UCAN.ToJSONString<unknown>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const from = principal => {\n  if (principal instanceof DID) {\n    return principal\n  } else if (principal instanceof Uint8Array) {\n    return decode(principal)\n  } else if (typeof principal === \"string\") {\n    return parse(principal)\n  } else {\n    return parse(principal.did())\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.ByteView<UCAN.Principal<ID>>} bytes\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const decode = bytes => {\n  const [code] = varint.decode(bytes)\n  const { buffer, byteOffset, byteLength } = bytes\n  switch (code) {\n    case P256:\n      if (bytes.length > 35) {\n        throw new RangeError(`Only p256-pub compressed is supported.`)\n      }\n    case ED25519:\n    case RSA:\n    case P384:\n    case P521:\n    case BLS12381G1:\n    case BLS12381G2:\n    case SECP256K1:\n      return /** @type {UCAN.PrincipalView<any>} */ (\n        new DIDKey(buffer, byteOffset, byteLength)\n      )\n    case DID_CORE:\n      return new DID(buffer, byteOffset, byteLength)\n    default:\n      throw new RangeError(\n        `Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`\n      )\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const encode = principal => parse(principal.did())\n\n/**\n * @template {UCAN.DID} ID\n * @implements {UCAN.PrincipalView<ID>}\n * @extends {Uint8Array}\n */\nclass DID extends Uint8Array {\n  /**\n   * @returns {ID}\n   */\n  did() {\n    const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET)\n    return /** @type {ID} */ (`did:${UTF8.decode(bytes)}`)\n  }\n\n  toJSON() {\n    return this.did()\n  }\n}\n\n/**\n * @implements {UCAN.PrincipalView<UCAN.DID<\"key\">>}\n * @extends {DID<UCAN.DID<\"key\">>}\n */\nclass DIDKey extends DID {\n  /**\n   * @return {`did:key:${string}`}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n}\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n", "import { coerce } from '../bytes.js'\nimport type { ArrayBufferView, ByteView } from './interface.js'\n\nexport const name = 'raw'\nexport const code = 0x55\n\nexport function encode (node: Uint8Array): ByteView<Uint8Array> {\n  return coerce(node)\n}\n\nexport function decode (data: ByteView<Uint8Array> | ArrayBufferView<Uint8Array>): Uint8Array {\n  return coerce(data)\n}\n", "import * as UCAN from \"./ucan.js\"\nimport { varint } from \"multiformats\"\nimport { base64url, base64 } from \"multiformats/bases/base64\"\nimport * as UTF8 from \"./utf8.js\"\n\nexport const NON_STANDARD = 0xd000\nexport const ES256K = 0xd0e7\nexport const BLS12381G1 = 0xd0ea\nexport const BLS12381G2 = 0xd0eb\nexport const EdDSA = 0xd0ed\nexport const ES256 = 0xd01200\nexport const ES384 = 0xd01201\nexport const ES512 = 0xd01202\nexport const RS256 = 0xd01205\nexport const EIP191 = 0xd191\n\n/**\n * @param {number} code\n * @returns {string}\n */\nconst codeName = code => {\n  switch (code) {\n    case ES256K:\n      return \"ES256K\"\n    case BLS12381G1:\n      return \"BLS12381G1\"\n    case BLS12381G2:\n      return \"BLS12381G2\"\n    case EdDSA:\n      return \"EdDSA\"\n    case ES256:\n      return \"ES256\"\n    case ES384:\n      return \"ES384\"\n    case ES512:\n      return \"ES512\"\n    case RS256:\n      return \"RS256\"\n    case EIP191:\n      return \"EIP191\"\n    default:\n      throw new RangeError(\n        `Unknown signature algorithm code 0x${code.toString(16)}`\n      )\n  }\n}\n\n/**\n *\n * @param {string} name\n */\nexport const nameCode = name => {\n  switch (name) {\n    case \"ES256K\":\n      return ES256K\n    case \"BLS12381G1\":\n      return BLS12381G1\n    case \"BLS12381G2\":\n      return BLS12381G2\n    case \"EdDSA\":\n      return EdDSA\n    case \"ES256\":\n      return ES256\n    case \"ES384\":\n      return ES384\n    case \"ES512\":\n      return ES512\n    case \"RS256\":\n      return RS256\n    case \"EIP191\":\n      return EIP191\n    default:\n      return NON_STANDARD\n  }\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @implements {UCAN.SignatureView<T, A>}\n */\nexport class Signature extends Uint8Array {\n  get code() {\n    const [code] = varint.decode(this)\n    Object.defineProperties(this, { code: { value: code } })\n    return /** @type {A} */ (code)\n  }\n\n  get size() {\n    const value = size(this)\n    Object.defineProperties(this, { size: { value } })\n    return value\n  }\n  get algorithm() {\n    const value = algorithm(this)\n    Object.defineProperties(this, { algorithm: { value } })\n    return value\n  }\n\n  get raw() {\n    const { buffer, byteOffset, size, code } = this\n    const codeSize = varint.encodingLength(code)\n    const rawSize = varint.encodingLength(size)\n    const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size)\n    Object.defineProperties(this, { raw: { value } })\n    return value\n  }\n\n  /**\n   * Verify that this signature was created by the given key.\n   *\n   * @param {UCAN.Crypto.Verifier<A>} signer\n   * @param {UCAN.ByteView<T>} payload\n   */\n  async verify(signer, payload) {\n    try {\n      if ((await signer.verify(payload, this)) === true) {\n        return { ok: {} }\n      } else {\n        throw new Error(\"Invalid signature\")\n      }\n    } catch (cause) {\n      return { error: /** @type {Error} */ (cause) }\n    }\n  }\n\n  toJSON() {\n    return toJSON(this)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst algorithm = signature => {\n  const { code, raw, buffer, byteOffset } = signature\n  if (code === NON_STANDARD) {\n    const offset =\n      raw.byteLength +\n      varint.encodingLength(code) +\n      varint.encodingLength(raw.byteLength)\n    const bytes = new Uint8Array(buffer, byteOffset + offset)\n    return UTF8.decode(bytes)\n  } else {\n    return codeName(code)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst size = signature => {\n  const offset = varint.encodingLength(signature.code)\n  const [size] = varint.decode(\n    new Uint8Array(signature.buffer, signature.byteOffset + offset)\n  )\n  return size\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {A} code\n * @param {Uint8Array} raw\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const create = (code, raw) => {\n  const _ = codeName(code)\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n\n  /** @type {Signature<T, A>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength)\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  Object.defineProperties(signature, {\n    code: { value: code },\n    size: { value: raw.byteLength },\n  })\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T>}\n */\nexport const createNamed = (name, raw) => {\n  const code = nameCode(name)\n  return code === NON_STANDARD\n    ? createNonStandard(name, raw)\n    : create(code, raw)\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T, typeof NON_STANDARD>}\n */\nexport const createNonStandard = (name, raw) => {\n  const code = NON_STANDARD\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n  const nameBytes = UTF8.encode(name)\n  /** @type {Signature<T, typeof NON_STANDARD>} */\n  const signature = new Signature(\n    codeSize + rawSize + raw.byteLength + nameBytes.byteLength\n  )\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  signature.set(nameBytes, codeSize + rawSize + raw.byteLength)\n\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const view = bytes =>\n  new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const decode = bytes => {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        bytes\n      )}`\n    )\n  }\n\n  /** @type {UCAN.SignatureView<T, A>} */\n  const signature = view(bytes)\n  const { code, algorithm, raw } = signature\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.Signature<T, A>} signature\n * @returns {UCAN.ByteView<UCAN.Signature<T, A>>}\n */\nexport const encode = signature => decode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.Signature<T, A>} signature\n * @param {UCAN.MultibaseEncoder<Prefix>} [base]\n * @returns {UCAN.ToString<UCAN.Signature<T, A>>}\n */\nexport const format = (signature, base) => (base || base64url).encode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.ToString<UCAN.Signature<T, A>>} signature\n * @param {UCAN.MultibaseDecoder<Prefix>} [base]\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const parse = (signature, base) =>\n  /** @type {UCAN.SignatureView<T, A>} */ (\n    decode((base || base64url).decode(signature))\n  )\n\n/**\n * @template {UCAN.Signature} Signature\n * @param {Signature} signature\n * @returns {UCAN.SignatureJSON<Signature>}\n */\nexport const toJSON = signature => ({\n  \"/\": { bytes: base64.baseEncode(signature) },\n})\n\n/**\n * @template {unknown} T\n * @template {UCAN.SigAlg} A\n * @param {UCAN.SignatureJSON<UCAN.Signature<T, A>>} json\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const fromJSON = json => decode(base64.baseDecode(json[\"/\"].bytes))\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import * as UCAN from \"./ucan.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport * as Link from \"multiformats/link\"\nimport { identity } from \"multiformats/hashes/identity\"\nimport * as DID from \"./did.js\"\nimport * as raw from \"multiformats/codecs/raw\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal,\n    readProof,\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readJWTPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal: readStringPrincipal,\n    readProof: readStringProof,\n  })\n/**\n *\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @param {object} readers\n * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal\n * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof\n * @returns {UCAN.Payload<C>}\n */\nconst readPayloadWith = (data, { readPrincipal, readProof }) => ({\n  iss: readPrincipal(data.iss, \"iss\"),\n  aud: readPrincipal(data.aud, \"aud\"),\n  att: readCapabilities(data.att, \"att\"),\n  prf: readOptionalArray(data.prf, readProof, \"prf\") || [],\n  exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, \"exp\"),\n  nbf: readOptional(data.nbf, readInt, \"nbf\"),\n  fct: readOptionalArray(data.fct, readFact, \"fct\") || [],\n  nnc: readOptional(data.nnc, readString, \"nnc\"),\n})\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>|unknown} source\n */\nexport const readSignature = source => {\n  if (source instanceof Uint8Array) {\n    return Signature.decode(source)\n  } else {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        source\n      )}`\n    )\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} name\n * @returns {number}\n */\nexport const readInt = (input, name) =>\n  Number.isInteger(input)\n    ? /** @type {number} */ (input)\n    : ParseError.throw(\n        `Expected ${name} to be integer, instead got ${JSON.stringify(input)}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\n\nexport const readCapability = (input, context) =>\n  readStruct(input, asCapability, context)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {unknown|C} input\n * @param {string} context\n * @returns {C}\n */\nexport const readCapabilities = (input, context) =>\n  /** @type {C} */ (readArray(input, readCapability, context))\n\n/**\n * @template {UCAN.Capability} C\n * @param {object & {can?:unknown, with?:unknown}|C} input\n * @returns {C}\n */\nexport const asCapability = input =>\n  /** @type {C} */ ({\n    ...input,\n    can: readAbility(input.can),\n    with: readResource(input.with),\n  })\n\n/**\n * @param {unknown} input\n */\nconst readAbility = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'can: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : input.slice(1, -1).includes(\"/\")\n    ? /** @type {UCAN.Ability} */ (input.toLocaleLowerCase())\n    : input === \"*\"\n    ? input\n    : ParseError.throw(\n        `Capability has invalid 'can: \"${input}\"', value must have at least one path segment`\n      )\n\n/**\n * @param {unknown} input\n */\nconst readResource = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'with: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : parseURL(input) ||\n      ParseError.throw(\n        `Capability has invalid 'with: \"${input}\"', value must be a valid URI string`\n      )\n\n/**\n * @param {string} input\n */\nconst parseURL = input => {\n  try {\n    new URL(input)\n    return input\n  } catch (_) {\n    return null\n  }\n}\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T[]}\n */\nexport const readArray = (input, read, context) =>\n  Array.isArray(input)\n    ? input.map((element, n) => read(element, `${context}[${n}]`))\n    : ParseError.throw(`${context} must be an array`)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context: string) => T} reader\n * @param {string} context\n * @returns {T[]|undefined}\n */\nexport const readOptionalArray = (input, reader, context) =>\n  input === undefined ? input : readArray(input, reader, context)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:object) => T} reader\n * @param {string} context\n * @returns {T}\n */\nexport const readStruct = (input, reader, context) =>\n  input != null && typeof input === \"object\"\n    ? reader(input)\n    : ParseError.throw(\n        `${context} must be of type object, instead got ${input}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Fact}\n */\nexport const readFact = (input, context) => readStruct(input, Object, context)\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readProof = (source, context) =>\n  Link.isLink(source)\n    ? /** @type {UCAN.Link} */ (source)\n    : fail(\n        `Expected ${context} to be IPLD link, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readStringProof = (source, context) =>\n  parseProof(readString(source, context))\n\n/**\n * @param {string} source\n * @returns {UCAN.Link}\n */\nconst parseProof = source => {\n  // First we attempt to read proof as CID, if we fail fallback to reading it as\n  // an inline proof.\n  try {\n    return Link.parse(source)\n  } catch (error) {\n    return Link.create(raw.code, identity.digest(UTF8.encode(source)))\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\nexport const readPrincipal = (input, context) =>\n  DID.decode(readBytes(input, context))\n\n/**\n * @param {unknown} source\n * @param {string} context\n */\nexport const readStringPrincipal = (source, context) =>\n  DID.parse(readString(source, context))\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} [context]\n * @returns {T|undefined}\n */\nexport const readOptional = (source, read, context = \"Field\") =>\n  source !== undefined ? read(source, context) : undefined\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T|null}\n */\nexport const readNullable = (source, read, context) =>\n  source === null ? null : read(source, context)\n\n/**\n * @param {unknown} source\n * @param {string} [context]\n * @returns {string}\n */\nexport const readString = (source, context = \"Field\") =>\n  typeof source === \"string\"\n    ? source\n    : fail(`${context} has invalid value ${source}`)\n\n/**\n *\n * @param {unknown} source\n * @param {string} context\n * @returns {Uint8Array}\n */\nexport const readBytes = (source, context) =>\n  source instanceof Uint8Array\n    ? source\n    : fail(\n        `Expected ${context} to be Uint8Array, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Version}\n */\nexport const readVersion = (input, context) =>\n  /\\d+\\.\\d+\\.\\d+/.test(/** @type {string} */ (input))\n    ? /** @type {UCAN.Version} */ (input)\n    : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`)\n\n/**\n * @template {string|number|boolean|null} T\n * @param {unknown} input\n * @param {T} literal\n * @param {string} context\n * @returns {T}\n */\nexport const readLiteral = (input, literal, context) =>\n  input === literal\n    ? literal\n    : ParseError.throw(\n        `Expected ${context} to be a ${JSON.stringify(\n          literal\n        )} instead got ${JSON.stringify(input)}`\n      )\n\nexport class ParseError extends TypeError {\n  get name() {\n    return \"ParseError\"\n  }\n  /**\n   * @param {string} message\n   * @returns {never}\n   */\n  static throw(message) {\n    throw new this(message)\n  }\n}\n\n/**\n * @param {string} reason\n */\nexport const fail = reason => ParseError.throw(reason)\n\nexport { fail as throw }\n", "import { Type } from '../token.js'\nimport { encodeCustom } from '../encode.js'\nimport { encodeErrPrefix } from '../common.js'\nimport { asU8A, fromString } from '../byte-utils.js'\n\n/**\n * @typedef {import('../../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../token').Token} Token\n * @typedef {import('../bl').Bl} Bl\n */\n\nclass JSONEncoder extends Array {\n  constructor () {\n    super()\n    /** @type {{type:Type,elements:number}[]} */\n    this.inRecursive = []\n  }\n\n  /**\n   * @param {Bl} buf\n   */\n  prefix (buf) {\n    const recurs = this.inRecursive[this.inRecursive.length - 1]\n    if (recurs) {\n      if (recurs.type === Type.array) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          buf.push([44]) // ','\n        }\n      }\n      if (recurs.type === Type.map) {\n        recurs.elements++\n        if (recurs.elements !== 1) { // >first\n          if (recurs.elements % 2 === 1) { // key\n            buf.push([44]) // ','\n          } else {\n            buf.push([58]) // ':'\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.uint.major] (buf, token) {\n    this.prefix(buf)\n    const is = String(token.value)\n    const isa = []\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n    }\n    buf.push(isa)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.negint.major] (buf, token) {\n    // @ts-ignore hack\n    this[Type.uint.major](buf, token)\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.bytes.major] (_buf, _token) {\n    throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.string.major] (buf, token) {\n    this.prefix(buf)\n    // buf.push(34) // '\"'\n    // encodeUtf8(token.value, byts)\n    // buf.push(34) // '\"'\n    const byts = fromString(JSON.stringify(token.value))\n    buf.push(byts.length > 32 ? asU8A(byts) : byts)\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.array.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.array, elements: 0 })\n    buf.push([91]) // '['\n  }\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} _token\n   */\n  [Type.map.major] (buf, _token) {\n    this.prefix(buf)\n    this.inRecursive.push({ type: Type.map, elements: 0 })\n    buf.push([123]) // '{'\n  }\n\n  /**\n   * @param {Bl} _buf\n   * @param {Token} _token\n   */\n  [Type.tag.major] (_buf, _token) {}\n\n  /**\n   * @param {Bl} buf\n   * @param {Token} token\n   */\n  [Type.float.major] (buf, token) {\n    if (token.type.name === 'break') {\n      const recurs = this.inRecursive.pop()\n      if (recurs) {\n        if (recurs.type === Type.array) {\n          buf.push([93]) // ']'\n        } else if (recurs.type === Type.map) {\n          buf.push([125]) // '}'\n        /* c8 ignore next 3 */\n        } else {\n          throw new Error('Unexpected recursive type; this should not happen!')\n        }\n        return\n      }\n      /* c8 ignore next 2 */\n      throw new Error('Unexpected break; this should not happen!')\n    }\n    if (token.value === undefined) {\n      throw new Error(`${encodeErrPrefix} unsupported type: undefined`)\n    }\n\n    this.prefix(buf)\n    if (token.type.name === 'true') {\n      buf.push([116, 114, 117, 101]) // 'true'\n      return\n    } else if (token.type.name === 'false') {\n      buf.push([102, 97, 108, 115, 101]) // 'false'\n      return\n    } else if (token.type.name === 'null') {\n      buf.push([110, 117, 108, 108]) // 'null'\n      return\n    }\n\n    // number\n    const is = String(token.value)\n    const isa = []\n    let dp = false\n    for (let i = 0; i < is.length; i++) {\n      isa[i] = is.charCodeAt(i)\n      if (!dp && (isa[i] === 46 || isa[i] === 101 || isa[i] === 69)) { // '[.eE]'\n        dp = true\n      }\n    }\n    if (!dp) { // need a decimal point for floats\n      isa.push(46) // '.'\n      isa.push(48) // '0'\n    }\n    buf.push(isa)\n  }\n}\n\n// The below code is mostly taken and modified from https://github.com/feross/buffer\n// Licensed MIT. Copyright (c) Feross Aboukhadijeh\n// function encodeUtf8 (string, byts) {\n//   let codePoint\n//   const length = string.length\n//   let leadSurrogate = null\n\n//   for (let i = 0; i < length; ++i) {\n//     codePoint = string.charCodeAt(i)\n\n//     // is surrogate component\n//     if (codePoint > 0xd7ff && codePoint < 0xe000) {\n//       // last char was a lead\n//       if (!leadSurrogate) {\n//         // no lead yet\n//         /* c8 ignore next 9 */\n//         if (codePoint > 0xdbff) {\n//           // unexpected trail\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         } else if (i + 1 === length) {\n//           // unpaired lead\n//           byts.push(0xef, 0xbf, 0xbd)\n//           continue\n//         }\n\n//         // valid lead\n//         leadSurrogate = codePoint\n\n//         continue\n//       }\n\n//       // 2 leads in a row\n//       /* c8 ignore next 5 */\n//       if (codePoint < 0xdc00) {\n//         byts.push(0xef, 0xbf, 0xbd)\n//         leadSurrogate = codePoint\n//         continue\n//       }\n\n//       // valid surrogate pair\n//       codePoint = (leadSurrogate - 0xd800 << 10 | codePoint - 0xdc00) + 0x10000\n//     /* c8 ignore next 4 */\n//     } else if (leadSurrogate) {\n//       // valid bmp char, but last char was a lead\n//       byts.push(0xef, 0xbf, 0xbd)\n//     }\n\n//     leadSurrogate = null\n\n//     // encode utf8\n//     if (codePoint < 0x80) {\n//       // special JSON escapes\n//       switch (codePoint) {\n//         case 8: // '\\b'\n//           byts.push(92, 98) // '\\\\b'\n//           continue\n//         case 9: // '\\t'\n//           byts.push(92, 116) // '\\\\t'\n//           continue\n//         case 10: // '\\n'\n//           byts.push(92, 110) // '\\\\n'\n//           continue\n//         case 12: // '\\f'\n//           byts.push(92, 102) // '\\\\f'\n//           continue\n//         case 13: // '\\r'\n//           byts.push(92, 114) // '\\\\r'\n//           continue\n//         case 34: // '\"'\n//           byts.push(92, 34) // '\\\\\"'\n//           continue\n//         case 92: // '\\\\'\n//           byts.push(92, 92) // '\\\\\\\\'\n//           continue\n//       }\n\n//       byts.push(codePoint)\n//     } else if (codePoint < 0x800) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0x6 | 0xc0,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else if (codePoint < 0x10000) {\n//       /* c8 ignore next 1 */\n//       byts.push(\n//         codePoint >> 0xc | 0xe0,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     /* c8 ignore next 9 */\n//     } else if (codePoint < 0x110000) {\n//       byts.push(\n//         codePoint >> 0x12 | 0xf0,\n//         codePoint >> 0xc & 0x3f | 0x80,\n//         codePoint >> 0x6 & 0x3f | 0x80,\n//         codePoint & 0x3f | 0x80\n//       )\n//     } else {\n//       /* c8 ignore next 2 */\n//       throw new Error('Invalid code point')\n//     }\n//   }\n// }\n\n/**\n * @param {(Token|Token[])[]} e1\n * @param {(Token|Token[])[]} e2\n * @returns {number}\n */\nfunction mapSorter (e1, e2) {\n  if (Array.isArray(e1[0]) || Array.isArray(e2[0])) {\n    throw new Error(`${encodeErrPrefix} complex map keys are not supported`)\n  }\n  const keyToken1 = e1[0]\n  const keyToken2 = e2[0]\n  if (keyToken1.type !== Type.string || keyToken2.type !== Type.string) {\n    throw new Error(`${encodeErrPrefix} non-string map keys are not supported`)\n  }\n  if (keyToken1 < keyToken2) {\n    return -1\n  }\n  if (keyToken1 > keyToken2) {\n    return 1\n  }\n  /* c8 ignore next 1 */\n  throw new Error(`${encodeErrPrefix} unexpected duplicate map keys, this is not supported`)\n}\n\nconst defaultEncodeOptions = { addBreakTokens: true, mapSorter }\n\n/**\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {Uint8Array}\n */\nfunction encode (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  // @ts-ignore TokenTypeEncoder[] requires compareTokens() on each encoder, we don't use them here\n  return encodeCustom(data, new JSONEncoder(), options)\n}\n\nexport { encode }\n", "import { decode as _decode, decodeFirst as _decodeFirst } from '../decode.js'\nimport { Token, Type } from '../token.js'\nimport { decodeCodePointsArray } from '../byte-utils.js'\nimport { decodeErrPrefix } from '../common.js'\n\n/**\n * @typedef {import('../../interface').DecodeOptions} DecodeOptions\n * @typedef {import('../../interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {DecodeOptions} options\n   */\n  constructor (data, options = {}) {\n    this._pos = 0\n    this.data = data\n    this.options = options\n    /** @type {string[]} */\n    this.modeStack = ['value']\n    this.lastToken = ''\n  }\n\n  pos () {\n    return this._pos\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this._pos >= this.data.length\n  }\n\n  /**\n   * @returns {number}\n   */\n  ch () {\n    return this.data[this._pos]\n  }\n\n  /**\n   * @returns {string}\n   */\n  currentMode () {\n    return this.modeStack[this.modeStack.length - 1]\n  }\n\n  skipWhitespace () {\n    let c = this.ch()\n    // @ts-ignore\n    while (c === 32 /* ' ' */ || c === 9 /* '\\t' */ || c === 13 /* '\\r' */ || c === 10 /* '\\n' */) {\n      c = this.data[++this._pos]\n    }\n  }\n\n  /**\n   * @param {number[]} str\n   */\n  expect (str) {\n    if (this.data.length - this._pos < str.length) {\n      throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this._pos}`)\n    }\n    for (let i = 0; i < str.length; i++) {\n      if (this.data[this._pos++] !== str[i]) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}, expected to find '${String.fromCharCode(...str)}'`)\n      }\n    }\n  }\n\n  parseNumber () {\n    const startPos = this._pos\n    let negative = false\n    let float = false\n\n    /**\n     * @param {number[]} chars\n     */\n    const swallow = (chars) => {\n      while (!this.done()) {\n        const ch = this.ch()\n        if (chars.includes(ch)) {\n          this._pos++\n        } else {\n          break\n        }\n      }\n    }\n\n    // lead\n    if (this.ch() === 45) { // '-'\n      negative = true\n      this._pos++\n    }\n    if (this.ch() === 48) { // '0'\n      this._pos++\n      if (this.ch() === 46) { // '.'\n        this._pos++\n        float = true\n      } else {\n        return new Token(Type.uint, 0, this._pos - startPos)\n      }\n    }\n    swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    if (negative && this._pos === startPos + 1) {\n      throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n    }\n    if (!this.done() && this.ch() === 46) { // '.'\n      if (float) {\n        throw new Error(`${decodeErrPrefix} unexpected token at position ${this._pos}`)\n      }\n      float = true\n      this._pos++\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    if (!this.done() && (this.ch() === 101 || this.ch() === 69)) { // '[eE]'\n      float = true\n      this._pos++\n      if (!this.done() && (this.ch() === 43 || this.ch() === 45)) { // '+', '-'\n        this._pos++\n      }\n      swallow([48, 49, 50, 51, 52, 53, 54, 55, 56, 57]) // DIGIT\n    }\n    // @ts-ignore\n    const numStr = String.fromCharCode.apply(null, this.data.subarray(startPos, this._pos))\n    const num = parseFloat(numStr)\n    if (float) {\n      return new Token(Type.float, num, this._pos - startPos)\n    }\n    if (this.options.allowBigInt !== true || Number.isSafeInteger(num)) {\n      return new Token(num >= 0 ? Type.uint : Type.negint, num, this._pos - startPos)\n    }\n    return new Token(num >= 0 ? Type.uint : Type.negint, BigInt(numStr), this._pos - startPos)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseString () {\n    /* c8 ignore next 4 */\n    if (this.ch() !== 34) { // '\"'\n      // this would be a programming error\n      throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}; this shouldn't happen`)\n    }\n    this._pos++\n\n    // check for simple fast-path, all printable ascii, no escapes\n    // >0x10000 elements may fail fn.apply() (http://stackoverflow.com/a/22747272/680742)\n    for (let i = this._pos, l = 0; i < this.data.length && l < 0x10000; i++, l++) {\n      const ch = this.data[i]\n      if (ch === 92 || ch < 32 || ch >= 128) { // '\\', ' ', control-chars or non-trivial\n        break\n      }\n      if (ch === 34) { // '\"'\n        // @ts-ignore\n        const str = String.fromCharCode.apply(null, this.data.subarray(this._pos, i))\n        this._pos = i + 1\n        return new Token(Type.string, str, l)\n      }\n    }\n\n    const startPos = this._pos\n    const chars = []\n\n    const readu4 = () => {\n      if (this._pos + 4 >= this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this._pos}`)\n      }\n      let u4 = 0\n      for (let i = 0; i < 4; i++) {\n        let ch = this.ch()\n        if (ch >= 48 && ch <= 57) { // '0' && '9'\n          ch -= 48\n        } else if (ch >= 97 && ch <= 102) { // 'a' && 'f'\n          ch = ch - 97 + 10\n        } else if (ch >= 65 && ch <= 70) { // 'A' && 'F'\n          ch = ch - 65 + 10\n        } else {\n          throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this._pos}`)\n        }\n        u4 = u4 * 16 + ch\n        this._pos++\n      }\n      return u4\n    }\n\n    // mostly taken from feross/buffer and adjusted to fit\n    const readUtf8Char = () => {\n      const firstByte = this.ch()\n      let codePoint = null\n      /* c8 ignore next 1 */\n      let bytesPerSequence = (firstByte > 0xef) ? 4 : (firstByte > 0xdf) ? 3 : (firstByte > 0xbf) ? 2 : 1\n\n      if (this._pos + bytesPerSequence > this.data.length) {\n        throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this._pos}`)\n      }\n\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        /* c8 ignore next 6 */\n        // this case is dealt with by the caller function\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = this.data[this._pos + 1]\n          if ((secondByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1f) << 0x6 | (secondByte & 0x3f)\n            if (tempCodePoint > 0x7f) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0xc | (secondByte & 0x3f) << 0x6 | (thirdByte & 0x3f)\n            /* c8 ignore next 3 */\n            if (tempCodePoint > 0x7ff && (tempCodePoint < 0xd800 || tempCodePoint > 0xdfff)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = this.data[this._pos + 1]\n          thirdByte = this.data[this._pos + 2]\n          fourthByte = this.data[this._pos + 3]\n          if ((secondByte & 0xc0) === 0x80 && (thirdByte & 0xc0) === 0x80 && (fourthByte & 0xc0) === 0x80) {\n            tempCodePoint = (firstByte & 0xf) << 0x12 | (secondByte & 0x3f) << 0xc | (thirdByte & 0x3f) << 0x6 | (fourthByte & 0x3f)\n            if (tempCodePoint > 0xffff && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n\n      /* c8 ignore next 5 */\n      if (codePoint === null) {\n        // we did not generate a valid codePoint so insert a\n        // replacement char (U+FFFD) and advance only 1 byte\n        codePoint = 0xfffd\n        bytesPerSequence = 1\n      } else if (codePoint > 0xffff) {\n        // encode to utf16 (surrogate pair dance)\n        codePoint -= 0x10000\n        chars.push(codePoint >>> 10 & 0x3ff | 0xd800)\n        codePoint = 0xdc00 | codePoint & 0x3ff\n      }\n\n      chars.push(codePoint)\n      this._pos += bytesPerSequence\n    }\n\n    // TODO: could take the approach of a quick first scan for special chars like encoding/json/decode.go#unquoteBytes\n    // and converting all of the ascii chars from the base array in bulk\n    while (!this.done()) {\n      const ch = this.ch()\n      let ch1\n      switch (ch) {\n        case 92: // '\\'\n          this._pos++\n          if (this.done()) {\n            throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this._pos}`)\n          }\n          ch1 = this.ch()\n          this._pos++\n          switch (ch1) {\n            case 34: // '\"'\n            case 39: // '\\''\n            case 92: // '\\'\n            case 47: // '/'\n              chars.push(ch1)\n              break\n            case 98: // 'b'\n              chars.push(8)\n              break\n            case 116: // 't'\n              chars.push(9)\n              break\n            case 110: // 'n'\n              chars.push(10)\n              break\n            case 102: // 'f'\n              chars.push(12)\n              break\n            case 114: // 'r'\n              chars.push(13)\n              break\n            case 117: // 'u'\n              chars.push(readu4())\n              break\n            default:\n              throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this._pos}`)\n          }\n          break\n        case 34: // '\"'\n          this._pos++\n          return new Token(Type.string, decodeCodePointsArray(chars), this._pos - startPos)\n        default:\n          if (ch < 32) { // ' '\n            throw new Error(`${decodeErrPrefix} invalid control character at position ${this._pos}`)\n          } else if (ch < 0x80) {\n            chars.push(ch)\n            this._pos++\n          } else {\n            readUtf8Char()\n          }\n      }\n    }\n\n    throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this._pos}`)\n  }\n\n  /**\n   * @returns {Token}\n   */\n  parseValue () {\n    switch (this.ch()) {\n      case 123: // '{'\n        this.modeStack.push('obj-start')\n        this._pos++\n        return new Token(Type.map, Infinity, 1)\n      case 91: // '['\n        this.modeStack.push('array-start')\n        this._pos++\n        return new Token(Type.array, Infinity, 1)\n      case 34: { // '\"'\n        return this.parseString()\n      }\n      case 110: // 'n' / null\n        this.expect([110, 117, 108, 108]) // 'null'\n        return new Token(Type.null, null, 4)\n      case 102: // 'f' / // false\n        this.expect([102, 97, 108, 115, 101]) // 'false'\n        return new Token(Type.false, false, 5)\n      case 116: // 't' / // true\n        this.expect([116, 114, 117, 101]) // 'true'\n        return new Token(Type.true, true, 4)\n      case 45: // '-'\n      case 48: // '0'\n      case 49: // '1'\n      case 50: // '2'\n      case 51: // '3'\n      case 52: // '4'\n      case 53: // '5'\n      case 54: // '6'\n      case 55: // '7'\n      case 56: // '8'\n      case 57: // '9'\n        return this.parseNumber()\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}`)\n    }\n  }\n\n  /**\n   * @returns {Token}\n   */\n  next () {\n    this.skipWhitespace()\n    switch (this.currentMode()) {\n      case 'value':\n        this.modeStack.pop()\n        return this.parseValue()\n      case 'array-value': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      case 'array-start': {\n        this.modeStack.pop()\n        if (this.ch() === 93) { // ']'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        this.modeStack.push('array-value')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      // @ts-ignore\n      case 'obj-key':\n        if (this.ch() === 125) { // '}'\n          this.modeStack.pop()\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        if (this.ch() !== 44) { // ','\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.skipWhitespace()\n      case 'obj-start': { // eslint-disable-line no-fallthrough\n        this.modeStack.pop()\n        if (this.ch() === 125) { // '}'\n          this._pos++\n          this.skipWhitespace()\n          return new Token(Type.break, undefined, 1)\n        }\n        const token = this.parseString()\n        this.skipWhitespace()\n        if (this.ch() !== 58) { // ':'\n          throw new Error(`${decodeErrPrefix} unexpected character at position ${this._pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`)\n        }\n        this._pos++\n        this.modeStack.push('obj-value')\n        return token\n      }\n      case 'obj-value': {\n        this.modeStack.pop()\n        this.modeStack.push('obj-key')\n        this.skipWhitespace()\n        return this.parseValue()\n      }\n      /* c8 ignore next 2 */\n      default:\n        throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this._pos}; this shouldn't happen`)\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {any}\n */\nfunction decode (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decode(data, options)\n}\n\n/**\n * @param {Uint8Array} data\n * @param {DecodeOptions} [options]\n * @returns {[any, Uint8Array]}\n */\nfunction decodeFirst (data, options) {\n  options = Object.assign({ tokenizer: new Tokenizer(data, options) }, options)\n  return _decodeFirst(data, options)\n}\n\nexport { decode, decodeFirst, Tokenizer }\n", "/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n", "import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport * as json from \"@ipld/dag-json\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = model => {\n  const header = formatHeader(model.v, model.s.algorithm)\n  const payload = formatPayload(model)\n  const signature = formatSignature(model.s)\n  return /** @type {UCAN.JWT<C>} */ (`${header}.${payload}.${signature}`)\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} payload\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatSignPayload = (payload, version, alg) =>\n  `${formatHeader(version, alg)}.${formatPayload(payload)}`\n\n/**\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatHeader = (version, alg) =>\n  base64url.baseEncode(encodeHeader(version, alg))\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n */\nexport const formatPayload = data => base64url.baseEncode(encodePayload(data))\n\n/**\n * @param {UCAN.Signature<string>} signature\n */\nexport const formatSignature = signature => base64url.baseEncode(signature.raw)\n\n/**\n * @param {UCAN.Version} v\n * @param {string} alg\n * @returns {UCAN.ByteView<UCAN.JWTHeader>}\n */\nconst encodeHeader = (v, alg) =>\n  json.encode({\n    alg,\n    ucv: v,\n    typ: \"JWT\",\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}\n */\nconst encodePayload = data =>\n  json.encode({\n    iss: DID.format(data.iss),\n    aud: DID.format(data.aud),\n    att: data.att,\n    exp: data.exp,\n    prf: data.prf.map(encodeProof),\n    // leave out optionals and empty fields\n    ...(data.fct.length > 0 && { fct: data.fct }),\n    ...(data.nnc && { nnc: data.nnc }),\n    ...(data.nbf && { nbf: data.nbf }),\n  })\n\n/**\n * @param {UCAN.Link} proof\n * @returns {UCAN.ToString<UCAN.Link>}\n */\nconst encodeProof = proof =>\n  /** @type {UCAN.ToString<UCAN.Link>} */ (proof.toString())\n", "import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport { encode as encodeJSON } from \"@ipld/dag-json\"\nimport { decode as decodeUTF8 } from \"./utf8.js\"\n\n/**\n * @param {unknown} data\n */\nconst toJSON = data => JSON.parse(decodeUTF8(encodeJSON(data)))\n\n/**\n * @template {UCAN.Capabilities} C\n */\nexport class View {\n  /**\n   * @param {UCAN.UCAN<C>} model\n   */\n  constructor(model) {\n    /** @readonly */\n    this.model = model\n  }\n\n  get version() {\n    return this.model.v\n  }\n\n  get issuer() {\n    return DID.from(this.model.iss)\n  }\n\n  get audience() {\n    return DID.from(this.model.aud)\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return this.model.att\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    const { exp } = this.model\n    return exp === null ? Infinity : exp\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.model.nbf\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.model.nnc\n  }\n\n  /**\n   * @returns {UCAN.Fact[]}\n   */\n  get facts() {\n    return this.model.fct\n  }\n\n  /**\n   * @returns {UCAN.Link[]}\n   */\n\n  get proofs() {\n    return this.model.prf\n  }\n\n  get signature() {\n    return this.model.s\n  }\n\n  // compatibility with UCAN.UCAN\n  get jwt() {\n    return this.model.jwt\n  }\n  get s() {\n    return this.model.s\n  }\n  get v() {\n    return this.model.v\n  }\n  get iss() {\n    return this.model.iss\n  }\n  get aud() {\n    return this.model.aud\n  }\n  get att() {\n    return this.model.att\n  }\n  get exp() {\n    return this.model.exp\n  }\n  get nbf() {\n    return this.model.nbf\n  }\n  get nnc() {\n    return this.model.nnc\n  }\n  get fct() {\n    return this.model.fct\n  }\n  get prf() {\n    return this.model.prf\n  }\n\n  /**\n   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}\n   */\n  toJSON() {\n    const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model\n\n    return {\n      iss,\n      aud,\n      v,\n      s,\n      exp,\n      ...toJSON({\n        att,\n        prf,\n        ...(fct.length > 0 && { fct }),\n      }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n    }\n  }\n}\n", "import * as UCAN from \"../ucan.js\"\nimport * as CBOR from \"@ipld/dag-cbor\"\nimport { readPayload, readVersion, readSignature } from \"../schema.js\"\nimport { format } from \"../formatter.js\"\nimport * as Signature from \"../signature.js\"\nimport { View } from \"../view.js\"\n\nexport const name = \"dag-ucan\"\nexport const code = CBOR.code\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromModel<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new CBORView(model)\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.ByteView<UCAN.Model<C>>}\n */\nexport const encode = model => {\n  const { fct, nnc, nbf, ...payload } = readPayload(model)\n\n  return /** @type {Uint8Array} */ (\n    CBOR.encode({\n      // leave out optionals unless they are set\n      ...(fct.length > 0 && { fct }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n      ...payload,\n      // add version and signature\n      v: readVersion(model.v, \"v\"),\n      s: encodeSignature(model.s, \"s\"),\n    })\n  )\n}\n\n/**\n * @param {UCAN.Signature} signature\n * @param {string} context\n */\nconst encodeSignature = (signature, context) => {\n  try {\n    return Signature.encode(signature)\n  } catch (cause) {\n    throw new Error(\n      `Expected signature ${context}, instead got ${JSON.stringify(signature)}`,\n      // @ts-expect-error - types don't know about second arg\n      { cause }\n    )\n  }\n}\n\n/**\n * Decodes UCAN in primary CBOR representation. It does not validate UCAN, it's\n * signature or proof chain. This is to say decoded UCAN may be invalid.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.Model<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const model = CBOR.decode(bytes)\n  return new CBORView({\n    ...readPayload(model),\n    v: readVersion(model.v, \"v\"),\n    s: readSignature(model.s),\n  })\n}\n\nexport { format }\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass CBORView extends View {\n  /** @type {UCAN.MulticodecCode<typeof code, \"CBOR\">} */\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n", "import * as UCAN from \"./ucan.js\"\nimport * as json from \"@ipld/dag-json\"\nimport * as Schema from \"./schema.js\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport { createNamed as createSignature } from \"./signature.js\"\n\n/**\n * Parse JWT formatted UCAN. Note than no validation takes place here.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.Model<C>}\n */\nexport const parse = jwt => {\n  const segments = jwt.split(\".\")\n  const [header, payload, signature] =\n    segments.length === 3\n      ? segments\n      : Schema.throw(\n          `Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`\n        )\n\n  const { ucv, alg } = parseHeader(header)\n\n  return {\n    ...parsePayload(payload),\n    v: ucv,\n    s: createSignature(alg, base64url.baseDecode(signature)),\n  }\n}\n\n/**\n * @param {string} header\n */\nexport const parseHeader = header => {\n  const { ucv, alg, typ } = json.decode(base64url.baseDecode(header))\n\n  return {\n    typ: Schema.readLiteral(typ, \"JWT\", \"typ\"),\n    ucv: Schema.readVersion(ucv, \"ucv\"),\n    alg: Schema.readString(alg, \"alg\"),\n  }\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {string} source\n * @returns {UCAN.Payload<C>}\n */\nexport const parsePayload = source => {\n  /** @type {Record<string, unknown>} */\n  const payload = json.decode(base64url.baseDecode(source))\n  return Schema.readJWTPayload(payload)\n}\n", "import * as UCAN from \"../ucan.js\"\nimport * as UTF8 from \"../utf8.js\"\nimport { parse } from \"../parser.js\"\nimport { code } from \"multiformats/codecs/raw\"\nimport { View } from \"../view.js\"\n\nexport { code }\nexport const name = \"dag-ucan\"\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new JWTView(model)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.FromJWT<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const jwt = /** @type {UCAN.JWT<C>} */ (UTF8.decode(bytes))\n\n  return new JWTView({ ...parse(jwt), jwt })\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ({ jwt }) => UTF8.encode(jwt)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ({ jwt }) => jwt\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass JWTView extends View {\n  /**\n   * @param {UCAN.FromJWT<C>} model\n   */\n  constructor(model) {\n    super(model)\n    this.model = model\n  }\n  /** @type {UCAN.MulticodecCode<typeof code, \"Raw\">} */\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as API from '@ucanto/interface'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as MF from 'multiformats/interface'\nimport * as CBOR from './cbor.js'\nimport { identity } from 'multiformats/hashes/identity'\n\nexport { CBOR, sha256, identity }\n\n/**\n * Function takes arbitrary value and if it happens to be an `IPLDView`\n * it will iterate over it's blocks. It is just a convenience for traversing\n * arbitrary structures that may contain `IPLDView`s in them.\n * Note if you pass anything other than `IPLDView` it will not attempt\n * to find views nested inside them, instead it will just emit no blocks.\n *\n * @param {unknown} value\n * @returns {IterableIterator<API.Block>}\n */\nexport const iterate = function* (value) {\n  if (\n    value &&\n    typeof value === 'object' &&\n    'iterateIPLDBlocks' in value &&\n    typeof value.iterateIPLDBlocks === 'function'\n  ) {\n    yield* value.iterateIPLDBlocks()\n  }\n}\n\n/**\n * @template [T=unknown]\n * @typedef {Map<API.ToString<API.Link>, API.Block<T, number, number, 0>|API.Block<T, number, number, 1>>} BlockStore\n */\n\n/**\n * @template [T=unknown]\n * @param {API.Block<T>[]} blocks\n * @returns {API.BlockStore<T>}\n */\nexport const createStore = (blocks = []) => {\n  const store = new Map()\n  addEveryInto(blocks, store)\n  return store\n}\n\n/** @type {API.MulticodecCode<typeof identity.code, typeof identity.name>} */\nconst EMBED_CODE = identity.code\n\n/**\n * Gets block corresponding to the given CID from the store. If store does not\n * contain the block, `fallback` is returned. If `fallback` is not provided, it\n * will throw an error.\n *\n * @template {0|1} V\n * @template {T} U\n * @template T\n * @template {API.MulticodecCode} Format\n * @template {API.MulticodecCode} Alg\n * @template [E=never]\n * @param {API.Link<U, Format, Alg, V>} cid\n * @param {BlockStore<T>} store\n * @param {E} [fallback]\n * @returns {API.Block<U, Format, Alg, V>|E}\n */\nexport const get = (cid, store, fallback) => {\n  // If CID uses identity hash, we can return the block data directly\n  if (cid.multihash.code === EMBED_CODE) {\n    return { cid, bytes: cid.multihash.digest }\n  }\n\n  const block = /** @type {API.Block<U, Format, Alg, V>|undefined} */ (\n    store.get(`${cid}`)\n  )\n  return block ? block : fallback === undefined ? notFound(cid) : fallback\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {U} source\n * @template {API.MulticodecCode} [C=API.MulticodecCode<typeof CBOR.code, typeof CBOR.name>]\n * @param {object} options\n * @param {MF.BlockEncoder<C, U>} [options.codec]\n * @returns {API.Block<U, C, typeof EMBED_CODE> & { data: U }}\n */\nexport const embed = (source, { codec } = {}) => {\n  const encoder = /** @type {MF.BlockEncoder<C, U>}  */ (codec || CBOR)\n  const bytes = encoder.encode(source)\n  const digest = identity.digest(bytes)\n  return {\n    cid: createLink(encoder.code, digest),\n    bytes,\n    data: source,\n  }\n}\n\n/**\n * @param {API.Link<*, *, *, *>} link\n * @returns {never}\n */\nexport const notFound = link => {\n  throw new Error(`Block for the ${link} is not found`)\n}\n\n/**\n * @template T\n * @template {T} U\n * @template {API.MulticodecCode} C\n * @template {API.MulticodecCode} A\n * @param {U} source\n * @param {BlockStore<T>} store\n * @param {object} options\n * @param {MF.BlockEncoder<C, unknown>} [options.codec]\n * @param {MF.MultihashHasher<A>} [options.hasher]\n * @returns {Promise<API.Block<U, C, A> & { data: U }>}\n */\nexport const writeInto = async (source, store, options = {}) => {\n  const codec = /** @type {MF.BlockEncoder<C, U>} */ (options.codec || CBOR)\n  const hasher = /** @type {MF.MultihashHasher<A>} */ (options.hasher || sha256)\n\n  const bytes = codec.encode(source)\n  const digest = await hasher.digest(bytes)\n  /** @type {API.Link<U, typeof codec.code, typeof hasher.code>} */\n  const link = createLink(codec.code, digest)\n  store.set(/** @type {API.ToString<typeof link>} */ (link.toString()), {\n    bytes,\n    cid: link,\n  })\n\n  return { bytes, cid: link, data: source }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {API.Block<U>} block\n * @param {BlockStore<T>} store\n * @returns {API.Block<U>}\n */\nexport const addInto = ({ cid, bytes }, store) => {\n  store.set(/** @type {API.ToString<typeof cid>} */ (cid.toString()), {\n    bytes,\n    cid,\n  })\n\n  return { bytes, cid }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {Iterable<API.Block<U>>} source\n * @param {BlockStore<T>} store\n */\nexport const addEveryInto = (source, store) => {\n  for (const block of source) {\n    addInto(block, store)\n  }\n}\n", "import * as API from '@ucanto/interface'\nimport * as CBOR from '@ipld/dag-cbor'\nexport { code, name, decode } from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { create as createLink, isLink } from 'multiformats/link'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.dag-cbor\nexport const contentType = 'application/vnd.ipld.dag-cbor'\n\n/**\n * @param {unknown} data\n * @param {Set<unknown>} seen\n * @returns {unknown}\n */\nconst prepare = (data, seen) => {\n  if (seen.has(data)) {\n    throw new TypeError('Can not encode circular structure')\n  }\n  // top level undefined is ok\n  if (data === undefined && seen.size === 0) {\n    return null\n  }\n\n  if (data === null) {\n    return null\n  }\n\n  if (typeof data === 'symbol' && seen.size === 0) {\n    return null\n  }\n\n  if (isLink(data)) {\n    return data\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return data\n  }\n\n  if (Array.isArray(data)) {\n    seen.add(data)\n    const items = []\n    for (const item of data) {\n      items.push(\n        item === undefined || typeof item === 'symbol'\n          ? null\n          : prepare(item, seen)\n      )\n    }\n    return items\n  }\n\n  if (typeof (/** @type {{toJSON?:unknown}} */ (data).toJSON) === 'function') {\n    seen.add(data)\n    const json = /** @type {{toJSON():unknown}} */ (data).toJSON()\n    return prepare(json, seen)\n  }\n\n  if (typeof data === 'object') {\n    seen.add(data)\n    /** @type {Record<string, unknown>} */\n    const object = {}\n    for (const [key, value] of Object.entries(data)) {\n      if (value !== undefined && typeof value !== 'symbol') {\n        object[key] = prepare(value, new Set(seen))\n      }\n    }\n    return object\n  }\n\n  return data\n}\n\n/**\n * @template T\n * @param {T} data\n * @returns {CBOR.ByteView<T>}\n */\nexport const encode = data =>\n  /** @type {CBOR.ByteView<T>} */ (CBOR.encode(prepare(data, new Set())))\n\n/**\n * @template T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n * @returns {Promise<API.Link<T, typeof CBOR.code>>}\n *\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof CBOR.code>} */ (\n    createLink(CBOR.code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof CBOR.code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { cid, bytes }\n}\n", "import * as API from '@ucanto/interface'\nimport { CarBufferReader } from '@ipld/car/buffer-reader'\nimport * as CarBufferWriter from '@ipld/car/buffer-writer'\nimport { base32 } from 'multiformats/bases/base32'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.car\nexport const contentType = 'application/vnd.ipld.car'\nexport const name = 'CAR'\n\n/** @type {API.MulticodecCode<0x0202, 'CAR'>} */\nexport const code = 0x0202\n\n/**\n * @typedef {{\n * roots: API.IPLDBlock[]\n * blocks: Map<string, API.IPLDBlock>\n * }} Model\n */\n\nclass Writer {\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   * @param {number} byteLength\n   */\n  constructor(blocks = [], byteLength = 0) {\n    this.written = new Set()\n    this.blocks = blocks\n    this.byteLength = byteLength\n  }\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   */\n  write(...blocks) {\n    for (const block of blocks) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.push(block)\n        this.byteLength += CarBufferWriter.blockLength(\n          /** @type {any} */ (block)\n        )\n        this.written.add(id)\n      }\n    }\n    return this\n  }\n  /**\n   * @param {API.IPLDBlock[]} rootBlocks\n   */\n  flush(...rootBlocks) {\n    const roots = []\n    // We reverse the roots so that the first root is the last block in the CAR\n    for (const block of rootBlocks.reverse()) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.unshift(block)\n        this.byteLength += CarBufferWriter.blockLength({\n          cid: /** @type {CarBufferWriter.CID} */ (block.cid),\n          bytes: block.bytes,\n        })\n        this.written.add(id)\n      }\n\n      // We unshift here because we want to preserve the order of the roots\n      roots.unshift(/** @type {CarBufferWriter.CID} */ (block.cid))\n    }\n\n    this.byteLength += CarBufferWriter.headerLength({ roots })\n\n    const buffer = new ArrayBuffer(this.byteLength)\n    const writer = CarBufferWriter.createWriter(buffer, { roots })\n\n    for (const block of /** @type {CarBufferWriter.Block[]} */ (this.blocks)) {\n      writer.write(block)\n    }\n\n    return writer.close()\n  }\n}\n\nexport const createWriter = () => new Writer()\n\n/**\n * @template {Partial<Model>} T\n * @param {T} input\n * @returns {API.ByteView<T>}\n */\nexport const encode = ({ roots = [], blocks }) => {\n  const writer = new Writer()\n  if (blocks) {\n    writer.write(...blocks.values())\n  }\n  return writer.flush(...roots)\n}\n\n/**\n * @param {API.ByteView<Partial<Model>>} bytes\n * @returns {Model}\n */\nexport const decode = bytes => {\n  const reader = CarBufferReader.fromBytes(bytes)\n  /** @type {API.IPLDBlock[]} */\n  const roots = []\n  const blocks = new Map()\n\n  for (const root of reader.getRoots()) {\n    const block = /** @type {API.IPLDBlock} */ (reader.get(root))\n    if (block) {\n      roots.push(block)\n    }\n  }\n\n  for (const block of reader.blocks()) {\n    blocks.set(block.cid.toString(), block)\n  }\n\n  return { roots, blocks }\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof code, typeof hasher.code>} */ (\n    createLink(code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { bytes, cid }\n}\n", "import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding.js').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding.js').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n", "/* eslint-disable jsdoc/check-indentation, max-depth */\n\n/**\n * Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n *   roots optional [&Any]\n *   # roots is _not_ optional for CarV1 but we defer that check within code to\n *   # gracefully handle the V2 case where it's just {version:X}\n *   version Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * #   roots [&Any]\n * #   version Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /**\n         * @param obj\n         * @returns {undefined|null}\n         */ (/** @type {any} */ obj) => obj === null ? obj : undefined,\n  Int: /**\n        * @param obj\n        * @returns {undefined|number}\n        */ (/** @type {any} */ obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /**\n          * @param obj\n          * @returns {undefined|number}\n          */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /**\n           * @param obj\n           * @returns {undefined|string}\n           */ (/** @type {any} */ obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /**\n         * @param obj\n         * @returns {undefined|boolean}\n         */ (/** @type {any} */ obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /**\n          * @param obj\n          * @returns {undefined|Uint8Array}\n          */ (/** @type {any} */ obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /**\n         * @param obj\n         * @returns {undefined|object}\n         */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /**\n         * @param obj\n         * @returns {undefined|Array<any>}\n         */ (/** @type {any} */ obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /**\n        * @param obj\n        * @returns {undefined|object}\n        */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /**\n                                           * @param obj\n                                           * @returns {undefined|any}\n                                           */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /**\n                          * @param obj\n                          * @returns {undefined|any}\n                          */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Types.Int(obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /**\n                                           * @param obj\n                                           * @returns {undefined|any}\n                                           */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /**\n                          * @param obj\n                          * @returns {undefined|any}\n                          */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Reprs.Int(value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n}\n", "import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockHeader} BlockHeader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesBufferReader} BytesBufferReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n * @typedef {import('./coding.js').CarV2FixedHeader} CarV2FixedHeader\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name decoder.readHeader(reader)\n * @param {BytesBufferReader} reader\n * @param {number} [strictVersion]\n * @returns {CarHeader | CarV2Header}\n */\nexport function readHeader (reader, strictVersion) {\n  const length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * Reads CID sync\n *\n * @param {BytesBufferReader} reader\n * @returns {CID}\n */\nfunction readCid (reader) {\n  const first = reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(reader.upTo(8), reader)\n  const bytes = reader.exactly(getMultihashLength(reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesBufferReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesBufferReader} reader\n * @returns {BlockHeader}\n */\nexport function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * Returns Car header and blocks from a Uint8Array\n *\n * @param {Uint8Array} bytes\n * @returns {{ header : CarHeader | CarV2Header , blocks: Block[]}}\n */\nexport function fromBytes (bytes) {\n  let reader = bytesReader(bytes)\n  const header = readHeader(reader)\n  if (header.version === 2) {\n    const v1length = reader.pos - header.dataOffset\n    reader = limitReader(reader, header.dataSize - v1length)\n  }\n\n  const blocks = []\n  while (reader.upTo(8).length > 0) {\n    const { cid, blockLength } = readBlockHead(reader)\n\n    blocks.push({ cid, bytes: reader.exactly(blockLength, true) })\n  }\n\n  return {\n    header, blocks\n  }\n}\n\n/**\n * Creates a `BytesBufferReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesBufferReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n    },\n\n    exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Wraps a `BytesBufferReader` in a limiting `BytesBufferReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesBufferReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesBufferReader} reader\n * @param {number} byteLimit\n * @returns {BytesBufferReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      let bytes = reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    exactly (length, seek = false) {\n      const bytes = reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n", "import * as BufferDecoder from './buffer-decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarBufferReader} ICarBufferReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsBufferReader` interface:\n * {@link ICarBufferReader.getRoots `getRoots()`}. And the `BlockBufferReader` interface:\n * {@link ICarBufferReader.get `get()`}, {@link ICarBufferReader.has `has()`},\n * {@link ICarBufferReader.blocks `blocks()`} and\n * {@link ICarBufferReader.cids `cids()`}.\n *\n * Load this class with either `import { CarBufferReader } from '@ipld/car/buffer-reader'`\n * (`const { CarBufferReader } = require('@ipld/car/buffer-reader')`). Or\n * `import { CarBufferReader } from '@ipld/car'` (`const { CarBufferReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarBufferReader\n * @class\n * @implements {ICarBufferReader}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarBufferReader {\n  /**\n   * @constructs CarBufferReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._cids = undefined\n  }\n\n  /**\n   * @property {number} version of the CAR\n   * @memberof CarBufferReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {boolean}\n   */\n  has (key) {\n    return this._blocks.some(b => b.cid.equals(key))\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {Block | undefined}\n   */\n  get (key) {\n    return this._blocks.find(b => b.cid.equals(key))\n  }\n\n  /**\n   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {Block[]}\n   */\n  blocks () {\n    return this._blocks\n  }\n\n  /**\n   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  cids () {\n    if (!this._cids) {\n      this._cids = this._blocks.map(b => b.cid)\n    }\n    return this._cids\n  }\n\n  /**\n   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @static\n   * @memberof CarBufferReader\n   * @param {Uint8Array} bytes\n   * @returns {CarBufferReader}\n   */\n  static fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n\n    const { header, blocks } = BufferDecoder.fromBytes(bytes)\n    return new CarBufferReader(header, blocks)\n  }\n}\n\nexport const __browser = true\n", "import { makeCborEncoders, objectToTokens } from './encode.js'\nimport { quickEncodeToken } from './jump.js'\n\n/**\n * @typedef {import('../interface').EncodeOptions} EncodeOptions\n * @typedef {import('../interface').TokenTypeEncoder} TokenTypeEncoder\n * @typedef {import('../interface').TokenOrNestedTokens} TokenOrNestedTokens\n */\n\nconst cborEncoders = makeCborEncoders()\n\n/** @type {EncodeOptions} */\nconst defaultEncodeOptions = {\n  float64: false,\n  quickEncodeToken\n}\n\n/**\n * Calculate the byte length of the given data when encoded as CBOR with the\n * options provided.\n * This calculation will be accurate if the same options are used as when\n * performing a normal encode. Some encode options can change the encoding\n * output length.\n *\n * @param {any} data\n * @param {EncodeOptions} [options]\n * @returns {number}\n */\nexport function encodedLength (data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options)\n  options.mapSorter = undefined // won't change the length\n  const tokens = objectToTokens(data, options)\n  return tokensToLength(tokens, cborEncoders, options)\n}\n\n/**\n * Calculate the byte length of the data as represented by the given tokens when\n * encoded as CBOR with the options provided.\n * This function is for advanced users and would not normally be called\n * directly. See `encodedLength()` for appropriate use.\n *\n * @param {TokenOrNestedTokens} tokens\n * @param {TokenTypeEncoder[]} [encoders]\n * @param {EncodeOptions} [options]\n */\nexport function tokensToLength (tokens, encoders = cborEncoders, options = defaultEncodeOptions) {\n  if (Array.isArray(tokens)) {\n    let len = 0\n    for (const token of tokens) {\n      len += tokensToLength(token, encoders, options)\n    }\n    return len\n  } else {\n    const encoder = encoders[tokens.type.major]\n    /* c8 ignore next 3 */\n    if (encoder.encodedSize === undefined || typeof encoder.encodedSize !== 'function') {\n      throw new Error(`Encoder for ${tokens.type.name} does not have an encodedSize()`)\n    }\n    return encoder.encodedSize(tokens, options)\n  }\n}\n", "import * as CBOR from '@ipld/dag-cbor'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport varint from 'varint'\n\n/**\n * @typedef {import('./api.js').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarBufferWriter} Writer\n * @typedef {import('./api.js').CarBufferWriterOptions} Options\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n", "export * as URI from './schema/uri.js'\nexport * as Link from './schema/link.js'\nexport * as Principal from './schema/principal.js'\nexport * as DID from './schema/did.js'\nexport * as Text from './schema/text.js'\nexport * from './schema/schema.js'\nexport { match as link } from './schema/link.js'\nexport { match as principal } from './schema/principal.js'\nexport { match as did, matchBytes as didBytes } from './schema/did.js'\nexport { match as uri } from './schema/uri.js'\nexport { match as text } from './schema/text.js'\n", "import * as API from '@ucanto/interface'\nimport * as Schema from './schema.js'\n\n/**\n * @template {API.Protocol} [P=API.Protocol]\n * @typedef {{protocol: P}} Options\n */\n\n/**\n * @template {Options} O\n * @extends {Schema.API<API.URI<O['protocol']>, unknown, Partial<O>>}\n */\nclass URISchema extends Schema.API {\n  /**\n   * @param {unknown} input\n   * @param {Partial<O>} options\n   * @returns {Schema.ReadResult<API.URI<O['protocol']>>}\n   */\n  readWith(input, { protocol } = {}) {\n    if (typeof input !== 'string' && !(input instanceof URL)) {\n      return Schema.error(\n        `Expected URI but got ${input === null ? 'null' : typeof input}`\n      )\n    }\n\n    try {\n      const url = new URL(String(input))\n      if (protocol != null && url.protocol !== protocol) {\n        return Schema.error(`Expected ${protocol} URI instead got ${url.href}`)\n      } else {\n        return { ok: /** @type {API.URI<O['protocol']>} */ (url.href) }\n      }\n    } catch (_) {\n      return Schema.error(`Invalid URI`)\n    }\n  }\n}\n\nconst schema = new URISchema({})\n\n/**\n * @returns {Schema.Schema<API.URI, unknown>}\n */\nexport const uri = () => schema\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @template {API.Protocol} P\n * @template {Options<P>} O\n * @param {O} options\n * @returns {Schema.Schema<API.URI<O['protocol']>, unknown>}\n */\nexport const match = options => new URISchema(options)\n\n/**\n * @template {string} [Scheme=string]\n * @param {`${Scheme}:${string}`} input\n */\nexport const from = input =>\n  /** @type {API.URI<`${Scheme}:`>} */ (schema.from(input))\n", "import * as API from '@ucanto/interface'\n\n/**\n * Creates the success result containing given `value`. Throws if\n * `null` or `undefined` passed to encourage use of units instead.\n *\n * @template {{}|string|boolean|number} T\n * @param {T} value\n * @returns {{ok: T, error?:undefined}}\n */\nexport const ok = value => {\n  if (value == null) {\n    throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`)\n  } else {\n    return { ok: value }\n  }\n}\n\n/**\n * Creates the failing result containing given `cause` of error.\n * Throws if `cause` is `null` or `undefined` to encourage\n * passing descriptive errors instead.\n *\n * @template {{}|string|boolean|number} X\n * @param {X} cause\n * @returns {{ok?:undefined, error:X}}\n */\nexport const error = cause => {\n  if (cause == null) {\n    throw new TypeError(\n      `error(${cause}) is not allowed, consider passing an error instead`\n    )\n  } else {\n    return { error: cause }\n  }\n}\n\n/**\n * Crash the program with a given `message`. This function is\n * intended to be used in places where it is impossible to\n * recover from an error. It is similar to `panic` function in\n * Rust.\n *\n * @param {string} message\n */\nexport const panic = message => {\n  throw new Failure(message)\n}\n/**\n * Creates the failing result containing an error with a given\n * `message`. Unlike `error` function it creates a very generic\n *  error with `message` & `stack` fields. The `error` function\n * is recommended over `fail` for all but the most basic use cases.\n *\n * @param {string} message\n * @returns {{error:API.Failure, ok?:undefined}}\n */\nexport const fail = message => ({ error: new Failure(message) })\n\n/**\n * @implements {API.Failure}\n */\nexport class Failure extends Error {\n  describe() {\n    return this.toString()\n  }\n  get message() {\n    return this.describe()\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return { name, message, stack }\n  }\n}\n", "import * as Schema from './type.js'\nimport { ok, Failure } from '../result.js'\nexport * from './type.js'\n\nexport { ok }\n/**\n * @abstract\n * @template [T=unknown]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {Schema.Base<T, I, Settings>}\n * @implements {Schema.Schema<T, I>}\n */\nexport class API {\n  /**\n   * @param {Settings} settings\n   */\n  constructor(settings) {\n    this.settings = settings\n  }\n\n  toString() {\n    return `new ${this.constructor.name}()`\n  }\n  /**\n   * @abstract\n   * @param {I} input\n   * @param {Settings} settings\n   * @returns {Schema.ReadResult<T>}\n   */\n  /* c8 ignore next 3 */\n  readWith(input, settings) {\n    throw new Error(`Abstract method readWith must be implemented by subclass`)\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<T>}\n   */\n  read(input) {\n    return this.readWith(input, this.settings)\n  }\n\n  /**\n   * @param {unknown} value\n   * @returns {value is T}\n   */\n  is(value) {\n    return !this.read(/** @type {I} */ (value))?.error\n  }\n\n  /**\n   * @param {unknown} value\n   * @return {T}\n   */\n  from(value) {\n    const result = this.read(/** @type {I} */ (value))\n    if (result.error) {\n      throw result.error\n    } else {\n      return result.ok\n    }\n  }\n\n  /**\n   * @returns {Schema.Schema<T|undefined, I>}\n   */\n  optional() {\n    return optional(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T|null, I>}\n   */\n  nullable() {\n    return nullable(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T[], I>}\n   */\n  array() {\n    return array(this)\n  }\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T | U, I>}\n   */\n\n  or(schema) {\n    return or(this, schema)\n  }\n\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T & U, I>}\n   */\n  and(schema) {\n    return and(this, schema)\n  }\n\n  /**\n   * @template {T} U\n   * @param {Schema.Reader<U, T>} schema\n   * @returns {Schema.Schema<U, I>}\n   */\n  refine(schema) {\n    return refine(this, schema)\n  }\n\n  /**\n   * @template {string} Kind\n   * @param {Kind} [kind]\n   * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}\n   */\n  brand(kind) {\n    return /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */ (this)\n  }\n\n  /**\n   * @param {Schema.NotUndefined<T>} value\n   * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}\n   */\n  default(value) {\n    //  this.from will throw if wrong default is provided\n    const fallback = this.from(value)\n    // we also check that fallback is not undefined because that is the point\n    // of having a fallback\n    if (fallback === undefined) {\n      throw new Error(`Value of type undefined is not a valid default`)\n    }\n\n    const schema = new Default({\n      reader: /** @type {Schema.Reader<T, I>} */ (this),\n      value: /** @type {Schema.NotUndefined<T>} */ (fallback),\n    })\n\n    return /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */ (\n      schema\n    )\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {API<never, I>}\n * @implements {Schema.Schema<never, I>}\n */\nclass Never extends API {\n  toString() {\n    return 'never()'\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<never>}\n   */\n  read(input) {\n    return typeError({ expect: 'never', actual: input })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<never, I>}\n */\nexport const never = () => new Never()\n\n/**\n * @template [I=unknown]\n * @extends API<unknown, I, void>\n * @implements {Schema.Schema<unknown, I>}\n */\nclass Unknown extends API {\n  /**\n   * @param {I} input\n   */\n  read(input) {\n    return /** @type {Schema.ReadResult<unknown>}*/ ({ ok: input })\n  }\n  toString() {\n    return 'unknown()'\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<unknown, I>}\n */\nexport const unknown = () => new Unknown()\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<null|O, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<null|O, I>}\n */\nclass Nullable extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    if (result.error) {\n      return input === null\n        ? { ok: null }\n        : {\n            error: new UnionError({\n              causes: [\n                result.error,\n                typeError({ expect: 'null', actual: input }).error,\n              ],\n            }),\n          }\n    } else {\n      return result\n    }\n  }\n  toString() {\n    return `${this.settings}.nullable()`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|null, I>}\n */\nexport const nullable = schema => new Nullable(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O|undefined, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<O|undefined, I>}\n */\nclass Optional extends API {\n  optional() {\n    return this\n  }\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   * @returns {Schema.ReadResult<O|undefined>}\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    return result.error && input === undefined ? { ok: undefined } : result\n  }\n  toString() {\n    return `${this.settings}.optional()`\n  }\n}\n\n/**\n * @template {unknown} O\n * @template [I=unknown]\n * @extends {API<O, I, {reader:Schema.Reader<O, I>, value:O & Schema.NotUndefined<O>}>}\n * @implements {Schema.DefaultSchema<O, I>}\n */\nclass Default extends API {\n  /**\n   * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}\n   */\n  optional() {\n    // Short circuit here as we there is no point in wrapping this in optional.\n    return /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */ (\n      this\n    )\n  }\n  /**\n   * @param {I} input\n   * @param {object} options\n   * @param {Schema.Reader<O|undefined, I>} options.reader\n   * @param {O} options.value\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { reader, value }) {\n    if (input === undefined) {\n      return /** @type {Schema.ReadResult<O>} */ ({ ok: value })\n    } else {\n      const result = reader.read(input)\n\n      return result.error\n        ? result\n        : result.ok !== undefined\n        ? // We just checked that result.ok is not undefined but still needs\n          // reassurance\n          /** @type {Schema.ReadResult<O>} */ (result)\n        : { ok: value }\n    }\n  }\n  toString() {\n    return `${this.settings.reader}.default(${JSON.stringify(\n      this.settings.value\n    )})`\n  }\n\n  get value() {\n    return this.settings.value\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|undefined, I>}\n */\nexport const optional = schema => new Optional(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O[], I, Schema.Reader<O, I>>}\n * @implements {Schema.ArraySchema<O, I>}\n */\nclass ArrayOf extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} schema\n   */\n  readWith(input, schema) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    /** @type {O[]} */\n    const results = []\n    for (const [index, value] of input.entries()) {\n      const result = schema.read(value)\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results.push(result.ok)\n      }\n    }\n    return { ok: results }\n  }\n  get element() {\n    return this.settings\n  }\n  toString() {\n    return `array(${this.element})`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.ArraySchema<O, I>}\n */\nexport const array = schema => new ArrayOf(schema)\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferTuple<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nclass Tuple extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferTuple<U>>}\n   */\n  readWith(input, shape) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    if (input.length !== this.shape.length) {\n      return error(`Array must contain exactly ${this.shape.length} elements`)\n    }\n\n    const results = []\n    for (const [index, reader] of shape.entries()) {\n      const result = reader.read(input[index])\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results[index] = result.ok\n      }\n    }\n\n    return { ok: /** @type {Schema.InferTuple<U>} */ (results) }\n  }\n\n  /** @type {U} */\n  get shape() {\n    return this.settings\n  }\n\n  toString() {\n    return `tuple([${this.shape.map(reader => reader.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} shape\n * @returns {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nexport const tuple = shape => new Tuple(shape)\n\n/**\n * @template V\n * @template {string} K\n * @template [I=unknown]\n * @extends {API<Schema.Dictionary<K, V>, I, { key: Schema.Reader<K, string>, value: Schema.Reader<V, I> }>}\n * @implements {Schema.DictionarySchema<V, K, I>}\n */\nclass Dictionary extends API {\n  /**\n   * @param {I} input\n   * @param {object} schema\n   * @param {Schema.Reader<K, string>} schema.key\n   * @param {Schema.Reader<V, I>} schema.value\n   */\n  readWith(input, { key, value }) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'dictionary',\n        actual: input,\n      })\n    }\n\n    const dict = /** @type {Schema.Dictionary<K, V>} */ ({})\n\n    for (const [k, v] of Object.entries(input)) {\n      const keyResult = key.read(k)\n      if (keyResult.error) {\n        return memberError({ at: k, cause: keyResult.error })\n      }\n\n      const valueResult = value.read(v)\n      if (valueResult.error) {\n        return memberError({ at: k, cause: valueResult.error })\n      }\n\n      // skip undefined because they mess up CBOR and are generally useless.\n      if (valueResult.ok !== undefined) {\n        dict[keyResult.ok] = valueResult.ok\n      }\n    }\n\n    return { ok: dict }\n  }\n  get key() {\n    return this.settings.key\n  }\n  get value() {\n    return this.settings.value\n  }\n\n  partial() {\n    const { key, value } = this.settings\n    return new Dictionary({\n      key,\n      value: optional(value),\n    })\n  }\n  toString() {\n    return `dictionary(${this.settings})`\n  }\n}\n\n/**\n * @template {string} K\n * @template {unknown} V\n * @template [I=unknown]\n * @param {object} shape\n * @param {Schema.Reader<V, I>} shape.value\n * @param {Schema.Reader<K, string>} [shape.key]\n * @returns {Schema.DictionarySchema<V, K, I>}\n */\nexport const dictionary = ({ value, key }) =>\n  new Dictionary({\n    value,\n    key: key || /** @type {Schema.Reader<K, string>} */ (string()),\n  })\n\n/**\n * @template {[unknown, ...unknown[]]} T\n * @template [I=unknown]\n * @extends {API<T[number], I, {type: string, variants:Set<T[number]>}>}\n * @implements {Schema.Schema<T[number], I>}\n */\nclass Enum extends API {\n  /**\n   * @param {I} input\n   * @param {{type:string, variants:Set<T[number]>}} settings\n   * @returns {Schema.ReadResult<T[number]>}\n   */\n  readWith(input, { variants, type }) {\n    if (variants.has(input)) {\n      return /** @type {Schema.ReadResult<T[number]>} */ ({ ok: input })\n    } else {\n      return typeError({ expect: type, actual: input })\n    }\n  }\n  toString() {\n    return this.settings.type\n  }\n}\n\n/**\n * @template {string} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<U[number], I>}\n */\nconst createEnum = variants =>\n  new Enum({\n    type: variants.join('|'),\n    variants: new Set(variants),\n  })\nexport { createEnum as enum }\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferUnion<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nclass Union extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   */\n  readWith(input, variants) {\n    const causes = []\n    for (const reader of variants) {\n      const result = reader.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      } else {\n        return /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */ (result)\n      }\n    }\n    return { error: new UnionError({ causes }) }\n  }\n\n  get variants() {\n    return this.settings\n  }\n  toString() {\n    return `union([${this.variants.map(type => type.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nexport const union = variants => new Union(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T|U, I>}\n */\nexport const or = (left, right) => union([left, right])\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferIntersection<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nclass Intersection extends API {\n  /**\n   * @param {I} input\n   * @param {U} schemas\n   * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}\n   */\n  readWith(input, schemas) {\n    const causes = []\n    for (const schema of schemas) {\n      const result = schema.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      }\n    }\n\n    return causes.length > 0\n      ? { error: new IntersectionError({ causes }) }\n      : /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */ ({\n          ok: input,\n        })\n  }\n  toString() {\n    return `intersection([${this.settings\n      .map(type => type.toString())\n      .join(',')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nexport const intersection = variants => new Intersection(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T & U, I>}\n */\nexport const and = (left, right) => intersection([left, right])\n\n/**\n * @template [I=unknown]\n * @extends {API<boolean, I>}\n */\nclass Boolean extends API {\n  /**\n   * @param {I} input\n   */\n  readWith(input) {\n    switch (input) {\n      case true:\n      case false:\n        return { ok: /** @type {boolean} */ (input) }\n      default:\n        return typeError({\n          expect: 'boolean',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `boolean()`\n  }\n}\n\n/** @type {Schema.Schema<boolean, unknown>} */\nconst anyBoolean = new Boolean()\n\nexport const boolean = () => anyBoolean\n\n/**\n * @template {number} [O=number]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass UnknownNumber extends API {\n  /**\n   * @param {number} n\n   */\n  greaterThan(n) {\n    return this.refine(greaterThan(n))\n  }\n  /**\n   * @param {number} n\n   */\n  lessThan(n) {\n    return this.refine(lessThan(n))\n  }\n\n  /**\n   * @template {O} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.NumberSchema<U, I>}\n   */\n  refine(schema) {\n    return new RefinedNumber({ base: this, schema })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownNumber<number, I>}\n * @implements {Schema.NumberSchema<number, I>}\n */\nclass AnyNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<number>}\n   */\n  readWith(input) {\n    return typeof input === 'number'\n      ? { ok: input }\n      : typeError({ expect: 'number', actual: input })\n  }\n  toString() {\n    return `number()`\n  }\n}\n\n/** @type {Schema.NumberSchema<number, unknown>} */\nconst anyNumber = new AnyNumber()\nexport const number = () => anyNumber\n\n/**\n * @template {number} [T=number]\n * @template {T} [O=T]\n * @template [I=unknown]\n * @extends {UnknownNumber<O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass RefinedNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass LessThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input < number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} < ${number}`)\n    }\n  }\n  toString() {\n    return `lessThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const lessThan = n => new LessThan(n)\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass GreaterThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input > number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} > ${number}`)\n    }\n  }\n  toString() {\n    return `greaterThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const greaterThan = n => new GreaterThan(n)\n\nconst Integer = {\n  /**\n   * @param {number} input\n   * @returns {Schema.ReadResult<Schema.Integer>}\n   */\n  read(input) {\n    return Number.isInteger(input)\n      ? { ok: /** @type {Schema.Integer} */ (input) }\n      : typeError({\n          expect: 'integer',\n          actual: input,\n        })\n  },\n  toString() {\n    return `Integer`\n  },\n}\n\nconst anyInteger = anyNumber.refine(Integer)\nexport const integer = () => anyInteger\n\nconst MAX_UINT64 = 2n ** 64n - 1n\n\n/**\n * @template {bigint} [O=Schema.Uint64]\n * @template [I=unknown]\n * @extends {API<O, I, void>}\n * @implements {Schema.Schema<O, I>}\n */\nclass Uint64Schema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<O>}\n   */\n  read(input) {\n    switch (typeof input) {\n      case 'bigint':\n        return input > MAX_UINT64\n          ? error(`Integer is too big for uint64, ${input} > ${MAX_UINT64}`)\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {I & O} */ (input) }\n\n      case 'number':\n        return !Number.isInteger(input)\n          ? typeError({\n              expect: 'uint64',\n              actual: input,\n            })\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {O} */ (BigInt(input)) }\n\n      default:\n        return typeError({\n          expect: 'uint64',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `uint64`\n  }\n}\n\n/** @type {Schema.Schema<Schema.Uint64, unknown>} */\nconst Uint64 = new Uint64Schema()\n\n/**\n * Creates a schema for {@link Schema.Uint64} values represented as  a`bigint`.\n *\n *  Please note that while IPLD in principal considers the range of integers\n * to be infinite n practice, many libraries / codecs may choose to implement\n * things in such a way that numbers may have limited sizes.\n *\n * So please use this with caution and always ensure that used codecs do support\n * uint64.\n */\nexport const uint64 = () => Uint64\n\nconst Float = {\n  /**\n   * @param {number} number\n   * @returns {Schema.ReadResult<Schema.Float>}\n   */\n  read(number) {\n    return Number.isFinite(number)\n      ? { ok: /** @type {Schema.Float} */ (number) }\n      : typeError({\n          expect: 'Float',\n          actual: number,\n        })\n  },\n  toString() {\n    return 'Float'\n  },\n}\n\nconst anyFloat = anyNumber.refine(Float)\nexport const float = () => anyFloat\n\n/**\n * @template {string} [O=string]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n */\nclass UnknownString extends API {\n  /**\n   * @template {O|unknown} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.StringSchema<O & U, I>}\n   */\n  refine(schema) {\n    const other = /** @type {Schema.Reader<U, O>} */ (schema)\n    const rest = new RefinedString({\n      base: this,\n      schema: other,\n    })\n\n    return /** @type {Schema.StringSchema<O & U, I>} */ (rest)\n  }\n  /**\n   * @template {string} Prefix\n   * @param {Prefix} prefix\n   */\n  startsWith(prefix) {\n    return this.refine(startsWith(prefix))\n  }\n  /**\n   * @template {string} Suffix\n   * @param {Suffix} suffix\n   */\n  endsWith(suffix) {\n    return this.refine(endsWith(suffix))\n  }\n  toString() {\n    return `string()`\n  }\n}\n\n/**\n * @template O\n * @template {string} [T=string]\n * @template [I=unknown]\n * @extends {UnknownString<T & O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.StringSchema<O & T, I>}\n */\nclass RefinedString extends UnknownString {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<T & O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error\n      ? result\n      : /** @type {Schema.ReadResult<T & O>} */ (schema.read(result.ok))\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownString<string, I>}\n * @implements {Schema.StringSchema<string, I>}\n */\nclass AnyString extends UnknownString {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<string>}\n   */\n  readWith(input) {\n    return typeof input === 'string'\n      ? { ok: input }\n      : typeError({ expect: 'string', actual: input })\n  }\n}\n\n/** @type {Schema.StringSchema<string, unknown>} */\nconst anyString = new AnyString()\nexport const string = () => anyString\n\n/**\n * @template [I=unknown]\n * @extends {API<Uint8Array, I, void>}\n */\nclass BytesSchema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<Uint8Array>}\n   */\n  readWith(input) {\n    if (input instanceof Uint8Array) {\n      return { ok: input }\n    } else {\n      return typeError({ expect: 'Uint8Array', actual: input })\n    }\n  }\n}\n\n/** @type {Schema.Schema<Uint8Array, unknown>} */\nexport const Bytes = new BytesSchema()\nexport const bytes = () => Bytes\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @extends {API<Body & `${Prefix}${Body}`, Body, Prefix>}\n * @implements {Schema.Schema<Body & `${Prefix}${Body}`, Body>}\n */\nclass StartsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Prefix} prefix\n   */\n  readWith(input, prefix) {\n    const result = input.startsWith(prefix)\n      ? /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to start with \"${prefix}\" instead got \"${input}\"`)\n\n    return result\n  }\n  get prefix() {\n    return this.settings\n  }\n  toString() {\n    return `startsWith(\"${this.prefix}\")`\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @param {Prefix} prefix\n * @returns {Schema.Schema<`${Prefix}${string}`, string>}\n */\nexport const startsWith = prefix => new StartsWith(prefix)\n\n/**\n * @template {string} Suffix\n * @template {string} Body\n * @extends {API<Body & `${Body}${Suffix}`, Body, Suffix>}\n */\nclass EndsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Suffix} suffix\n   */\n  readWith(input, suffix) {\n    return input.endsWith(suffix)\n      ? /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to end with \"${suffix}\" instead got \"${input}\"`)\n  }\n  get suffix() {\n    return this.settings\n  }\n  toString() {\n    return `endsWith(\"${this.suffix}\")`\n  }\n}\n\n/**\n * @template {string} Suffix\n * @param {Suffix} suffix\n * @returns {Schema.Schema<`${string}${Suffix}`, string>}\n */\nexport const endsWith = suffix => new EndsWith(suffix)\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @extends {API<U, I, { base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }>}\n * @implements {Schema.Schema<U, I>}\n */\n\nclass Refine extends API {\n  /**\n   * @param {I} input\n   * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} base\n * @param {Schema.Reader<U, T>} schema\n * @returns {Schema.Schema<U, I>}\n */\nexport const refine = (base, schema) => new Refine({ base, schema })\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @extends {API<T, I, T>}\n * @implements {Schema.LiteralSchema<T, I>}\n */\nclass Literal extends API {\n  /**\n   * @param {I} input\n   * @param {T} expect\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, expect) {\n    return input !== /** @type {unknown} */ (expect)\n      ? { error: new LiteralError({ expect, actual: input }) }\n      : { ok: expect }\n  }\n  get value() {\n    return /** @type {Exclude<T, undefined>} */ (this.settings)\n  }\n  /**\n   * @template {Schema.NotUndefined<T>} U\n   * @param {U} value\n   */\n  default(value = /** @type {U} */ (this.value)) {\n    return super.default(value)\n  }\n  toString() {\n    return `literal(${toString(this.value)})`\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @param {T} value\n * @returns {Schema.LiteralSchema<T, I>}\n */\nexport const literal = value => new Literal(value)\n\n/**\n * @template {{[key:string]: Schema.Reader}} U\n * @template [I=unknown]\n * @extends {API<Schema.InferStruct<U>, I, U>}\n */\nclass Struct extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferStruct<U>>}\n   */\n  readWith(input, shape) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const source = /** @type {{[K in keyof U]: unknown}} */ (input)\n\n    const struct = /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */ ({})\n    const entries =\n      /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */ (\n        Object.entries(shape)\n      )\n\n    for (const [at, reader] of entries) {\n      const result = reader.read(source[at])\n      if (result.error) {\n        return memberError({ at, cause: result.error })\n      }\n      // skip undefined because they mess up CBOR and are generally useless.\n      else if (result.ok !== undefined) {\n        struct[at] = /** @type {Schema.Infer<U[typeof at]>} */ (result.ok)\n      }\n    }\n\n    return { ok: struct }\n  }\n\n  /**\n   * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}\n   */\n  partial() {\n    return new Struct(\n      Object.fromEntries(\n        Object.entries(this.shape).map(([key, value]) => [key, optional(value)])\n      )\n    )\n  }\n\n  /** @type {U} */\n  get shape() {\n    // @ts-ignore - We declared `settings` private but we access it here\n    return this.settings\n  }\n\n  toString() {\n    return [\n      `struct({ `,\n      ...Object.entries(this.shape)\n        .map(([key, schema]) => `${key}: ${schema}`)\n        .join(', '),\n      ` })`,\n    ].join('')\n  }\n\n  /**\n   * @param {Schema.InferStructSource<U>} data\n   */\n  create(data) {\n    return this.from(data || {})\n  }\n\n  /**\n   * @template {{[key:string]: Schema.Reader}} E\n   * @param {E} extension\n   * @returns {Schema.StructSchema<U & E, I>}\n   */\n  extend(extension) {\n    return new Struct({ ...this.shape, ...extension })\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template {{[key:string]: T|Schema.Reader}} U\n * @template {{[K in keyof U]: U[K] extends Schema.Reader ? U[K] : Schema.LiteralSchema<U[K] & T>}} V\n * @template [I=unknown]\n * @param {U} fields\n * @returns {Schema.StructSchema<V, I>}\n */\nexport const struct = fields => {\n  const shape =\n    /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */ ({})\n  /** @type {[keyof U & string, T|Schema.Reader][]} */\n  const entries = Object.entries(fields)\n\n  for (const [key, field] of entries) {\n    switch (typeof field) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n        shape[key] = literal(field)\n        break\n      case 'object':\n        shape[key] = field === null ? literal(null) : field\n        break\n      default:\n        throw new Error(\n          `Invalid struct field \"${key}\", expected schema or literal, instead got ${typeof field}`\n        )\n    }\n  }\n\n  return new Struct(/** @type {V} */ (shape))\n}\n\n/**\n * @template {Schema.VariantChoices} U\n * @template [I=unknown]\n * @extends {API<Schema.InferVariant<U>, I, U>}\n * @implements {Schema.VariantSchema<U, I>}\n */\nclass Variant extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   * @returns {Schema.ReadResult<Schema.InferVariant<U>>}\n   */\n  readWith(input, variants) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const keys = /** @type {Array<keyof input & keyof variants & string>} */ (\n      Object.keys(input)\n    )\n\n    const [key] = keys.length === 1 ? keys : []\n    const reader = key ? variants[key] : undefined\n\n    if (reader) {\n      const result = reader.read(input[key])\n      return result.error\n        ? memberError({ at: key, cause: result.error })\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ [key]: result.ok }) }\n    } else if (variants._) {\n      const result = variants._.read(input)\n      return result.error\n        ? result\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ _: result.ok }) }\n    } else if (key) {\n      return error(\n        `Expected an object with one of the these keys: ${Object.keys(variants)\n          .sort()\n          .join(', ')} instead got object with key ${key}`\n      )\n    } else {\n      return error(\n        'Expected an object with a single key instead got object with keys ' +\n          keys.sort().join(', ')\n      )\n    }\n  }\n\n  /**\n   * @template [E=never]\n   * @param {I} input\n   * @param {E} [fallback]\n   */\n  match(input, fallback) {\n    const result = this.read(input)\n    if (result.error) {\n      if (fallback !== undefined) {\n        return [null, fallback]\n      } else {\n        throw result.error\n      }\n    } else {\n      const [key] = Object.keys(result.ok)\n      const value = result.ok[key]\n      return /** @type {any} */ ([key, value])\n    }\n  }\n\n  /**\n   * @template {Schema.InferVariant<U>} O\n   * @param {O} source\n   * @returns {O}\n   */\n  create(source) {\n    return /** @type {O} */ (this.from(source))\n  }\n}\n\n/**\n * Defines a schema for the `Variant` type. It takes an object where\n * keys denote branches of the variant and values are schemas for the values of\n * those branches. The schema will only match objects with a single key and\n * value that matches the schema for that key. If the object has more than one\n * key or the key does not match any of the keys in the schema then the schema\n * will fail.\n *\n * The `_` branch is a special case. If such branch is present then it will be\n * used as a fallback for any object that does not match any of the variant\n * branches. The `_` branch will be used even if the object has more than one\n * key. Unlike other branches the `_` branch will receive the entire object as\n * input and not just the value of the key. Usually the `_` branch can be set\n * to `Schema.unknown` or `Schema.dictionary` to facilitate exhaustive matching.\n *\n * @example\n * ```ts\n * const Shape = Variant({\n *    circle: Schema.struct({ radius: Schema.integer() }),\n *    rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() })\n * })\n *\n * const demo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *    }\n * }\n *\n * const ExhaustiveShape = Variant({\n *   circle: Schema.struct({ radius: Schema.integer() }),\n *   rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() }),\n *  _: Schema.dictionary({ value: Schema.unknown() })\n * })\n *\n * const exhastiveDemo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *     case: \"_\":\n *       return `Unknown shape ${JSON.stringify(value)}`\n *    }\n * }\n * ```\n *\n * @template {Schema.VariantChoices} Choices\n * @template [In=unknown]\n * @param {Choices} variants\n * @returns {Schema.VariantSchema<Choices, In>}\n */\nexport const variant = variants => new Variant(variants)\n\n/**\n * @param {string} message\n * @returns {{error: Schema.Error, ok?: undefined}}\n */\nexport const error = message => ({ error: new SchemaError(message) })\n\nclass SchemaError extends Failure {\n  get name() {\n    return 'SchemaError'\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return this.name\n  }\n}\n\nclass TypeError extends SchemaError {\n  /**\n   * @param {{expect:string, actual:unknown}} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'TypeError'\n  }\n  describe() {\n    return `Expected value of type ${this.expect} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\n/**\n * @param {object} data\n * @param {string} data.expect\n * @param {unknown} data.actual\n * @returns {{ error: Schema.Error }}\n */\nexport const typeError = data => ({ error: new TypeError(data) })\n\n/**\n *\n * @param {unknown} value\n */\nexport const toString = value => {\n  const type = typeof value\n  switch (type) {\n    case 'boolean':\n    case 'string':\n      return JSON.stringify(value)\n    // if these types we do not want JSON.stringify as it may mess things up\n    // eg turn NaN and Infinity to null\n    case 'bigint':\n      return `${value}n`\n    case 'number':\n    case 'symbol':\n    case 'undefined':\n      return String(value)\n    case 'object':\n      return value === null\n        ? 'null'\n        : Array.isArray(value)\n        ? 'array'\n        : Symbol.toStringTag in /** @type {object} */ (value)\n        ? value[Symbol.toStringTag]\n        : 'object'\n    default:\n      return type\n  }\n}\n\nclass LiteralError extends SchemaError {\n  /**\n   * @param {{\n   * expect:string|number|boolean|null\n   * actual:unknown\n   * }} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'LiteralError'\n  }\n  describe() {\n    return `Expected literal ${toString(this.expect)} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\nclass ElementError extends SchemaError {\n  /**\n   * @param {{at:number, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'ElementError'\n  }\n  describe() {\n    return [\n      `Array contains invalid element at ${this.at}:`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nclass FieldError extends SchemaError {\n  /**\n   * @param {{at:string, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'FieldError'\n  }\n  describe() {\n    return [\n      `Object contains invalid field \"${this.at}\":`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {object} options\n * @param {string|number} options.at\n * @param {Schema.Error} options.cause\n * @returns {{error: Schema.Error}}\n */\nexport const memberError = ({ at, cause }) =>\n  typeof at === 'string'\n    ? { error: new FieldError({ at, cause }) }\n    : { error: new ElementError({ at, cause }) }\n\nclass UnionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'UnionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match any type of the union:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\nclass IntersectionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'IntersectionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match following types of the intersection:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {string} message\n */\nconst indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nconst li = message => indent(`- ${message}`)\n", "import * as API from '@ucanto/interface'\nimport { create, createLegacy, isLink, parse, base32 } from '../link.js'\nimport * as Schema from './schema.js'\n\nexport { create, createLegacy, isLink, parse }\n\n/**\n * @template {number} [Code=number]\n * @template {number} [Alg=number]\n * @template {1|0} [Version=0|1]\n * @typedef {{\n * code?:Code,\n * version?:Version\n * multihash?: {code?: Alg, digest?: Uint8Array}\n * }} Settings\n */\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @extends {Schema.API<API.Link<unknown, Code, Alg, Version>, unknown, Settings<Code, Alg, Version>>}\n */\nclass LinkSchema extends Schema.API {\n  /**\n   *\n   * @param {unknown} cid\n   * @param {Settings<Code, Alg, Version>} settings\n   * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}\n   */\n  readWith(cid, { code, multihash = {}, version }) {\n    if (cid == null) {\n      return Schema.error(`Expected link but got ${cid} instead`)\n    } else {\n      if (!isLink(cid)) {\n        return Schema.error(`Expected link to be a CID instead of ${cid}`)\n      } else {\n        if (code != null && cid.code !== code) {\n          return Schema.error(\n            `Expected link to be CID with 0x${code.toString(16)} codec`\n          )\n        }\n\n        if (multihash.code != null && cid.multihash.code !== multihash.code)\n          return Schema.error(\n            `Expected link to be CID with 0x${multihash.code.toString(\n              16\n            )} hashing algorithm`\n          )\n\n        if (version != null && cid.version !== version) {\n          return Schema.error(\n            `Expected link to be CID version ${version} instead of ${cid.version}`\n          )\n        }\n\n        const [expectDigest, actualDigest] =\n          multihash.digest != null\n            ? [\n                base32.baseEncode(multihash.digest),\n                base32.baseEncode(cid.multihash.digest),\n              ]\n            : ['', '']\n\n        if (expectDigest !== actualDigest) {\n          return Schema.error(\n            `Expected link with \"${expectDigest}\" hash digest instead of \"${actualDigest}\"`\n          )\n        }\n\n        return {\n          ok: /** @type {API.Link<unknown, any, any, any>} */ (cid),\n        }\n      }\n    }\n  }\n}\n\n/** @type {Schema.Schema<API.Link<unknown, number, number, 0|1>, unknown>}  */\nexport const schema = new LinkSchema({})\n\nexport const link = () => schema\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @param {Settings<Code, Alg, Version>} options\n * @returns {Schema.Schema<API.Link<unknown, Code, Alg, Version>>}\n */\nexport const match = (options = {}) => new LinkSchema(options)\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\nexport const optional = () => schema.optional()\n", "import * as API from '@ucanto/interface'\nimport * as DID from '@ipld/dag-ucan/did'\nimport * as Schema from './schema.js'\n\n/**\n * @template {string} Method\n * @extends {Schema.API<API.PrincipalView<API.DID<Method> & API.URI<\"did:\">>, unknown, void|Method>}\n */\nclass PrincipalSchema extends Schema.API {\n  /**\n   * @param {unknown} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    if (!(source instanceof Uint8Array)) {\n      return Schema.typeError({ expect: 'Uint8Array', actual: source })\n    }\n    let principal\n    try {\n      principal = DID.decode(source)\n    } catch (err) {\n      return Schema.error(`Unable to decode bytes as DID: ${err}`)\n    }\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!principal.did().startsWith(prefix)) {\n      return Schema.error(\n        `Expected a ${prefix} but got \"${principal.did()}\" instead`\n      )\n    }\n    return { ok: /** @type {API.PrincipalView<API.DID<Method>>} */ (principal) }\n  }\n}\n\nconst schema = new PrincipalSchema()\n\n/** A schema that reads byte encoded DIDs. */\nexport const principal = () => schema\n\n/** @param {unknown} input */\nexport const read = input => schema.read(input)\n\n/**\n * Matches a byte encoded DID.\n *\n * @template {string} Method\n * @param {{ method?: Method }} options\n */\nexport const match = (options = {}) =>\n  /** @type {Schema.Schema<API.PrincipalView<API.DID<Method> & API.URI<\"did:\">>>} */\n  (new PrincipalSchema(options.method))\n\n/**\n * Create a Principal from any input (or throw).\n *\n * @param {unknown} input\n */\nexport const from = input => match({}).from(input)\n", "import * as API from '@ucanto/interface'\nimport * as Schema from './schema.js'\nimport * as DID from '@ipld/dag-ucan/did'\n/**\n * @template {string} Method\n * @extends {Schema.API<API.DID<Method> & API.URI<\"did:\">, string, void|Method>}\n */\nclass DIDSchema extends Schema.API {\n  /**\n   * @param {string} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!source.startsWith(prefix)) {\n      return Schema.error(`Expected a ${prefix} but got \"${source}\" instead`)\n    } else {\n      return { ok: /** @type {API.DID<Method>} */ (source) }\n    }\n  }\n}\n\nconst schema = Schema.string().refine(new DIDSchema())\n\nexport const did = () => schema\n/**\n *\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @template {string} Method\n * @param {{method?: Method}} options\n */\nexport const match = (options = {}) =>\n  /** @type {Schema.Schema<API.DID<Method> & API.URI<\"did:\">>} */ (\n    Schema.string().refine(new DIDSchema(options.method))\n  )\n\n/**\n * Create a DID string from any input (or throw)\n * @param {unknown} input\n */\nexport const from = input => match({}).from(input)\n\n/**\n * @template {string} Method\n * @extends {Schema.API<API.DID<Method> & API.URI<\"did:\">, unknown, void|Method>}\n */\nclass DIDBytesSchema extends Schema.API {\n  /**\n   * @param {unknown} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    if (!(source instanceof Uint8Array)) {\n      return Schema.typeError({ expect: 'Uint8Array', actual: source })\n    }\n    let did\n    try {\n      did = DID.decode(source).did()\n    } catch (err) {\n      return Schema.error(`Unable to parse bytes as did: ${err}`)\n    }\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!did.startsWith(prefix)) {\n      return Schema.error(`Expected a ${prefix} but got \"${did}\" instead`)\n    } else {\n      return { ok: /** @type {API.DID<Method>} */ (did) }\n    } \n  }\n}\n\nconst schemaBytes = new DIDBytesSchema()\n\n/**\n * @deprecated Use `Schema.principal(...)` instead.\n */\nexport const didBytes = () => schemaBytes\n\n/**\n * @deprecated Use `Schema.principal(...)` instead.\n * @param {unknown} input\n */\nexport const readBytes = input => schemaBytes.read(input)\n\n/**\n * @deprecated Use `Schema.principal(...)` instead.\n * @template {string} Method\n * @param {{method?: Method}} options\n */\nexport const matchBytes = (options = {}) =>\n  /** @type {Schema.Schema<API.DID<Method> & API.URI<\"did:\">>} */ (\n    new DIDBytesSchema(options.method)\n  )\n\n/**\n * Create a DID string from any input (or throw)\n *\n * @deprecated Use `Schema.principal(...)` instead.\n * @param {unknown} input\n */\nexport const fromBytes = input => matchBytes({}).from(input)\n", "import * as Schema from './schema.js'\n\nconst schema = Schema.string()\n\n/**\n * @param {{pattern: RegExp}} [options]\n */\nexport const match = options =>\n  options ? schema.refine(new Match(options.pattern)) : schema\n\nexport const text = match\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @extends {Schema.API<string, string, RegExp>}\n */\nclass Match extends Schema.API {\n  /**\n   * @param {string} source\n   * @param {RegExp} pattern\n   */\n  readWith(source, pattern) {\n    if (!pattern.test(source)) {\n      return Schema.error(\n        `Expected to match ${pattern} but got \"${source}\" instead`\n      )\n    } else {\n      return { ok: source }\n    }\n  }\n}\n", "import * as API from '@ucanto/interface'\nimport { delegate, Delegation, isDelegation } from './delegation.js'\nimport * as DAG from './dag.js'\n\n/**\n * Takes invocation link or a reference and returns `true` if value\n * passed is a reference, returns `false` if value is a link.\n *\n * @param {API.Invocation | API.Link} value\n * @return {value is API.Invocation}\n */\nexport const isInvocation = value => isDelegation(value)\n\n/**\n * @template {API.Capability} Capability\n * @param {API.InvocationOptions<Capability>} options\n * @return {API.IssuedInvocationView<Capability>}\n */\nexport const invoke = options => new IssuedInvocation(options)\n\n/**\n * @template {API.Capability} C\n * @param {object} dag\n * @param {API.UCANBlock<[C]>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Invocation<C>}\n */\nexport const create = ({ root, blocks }) => new Invocation(root, blocks)\n\n/**\n * Takes a link of the `root` block and a map of blocks and constructs an\n * `Invocation` from it. If `root` is not included in the provided blocks\n * provided fallback is returned and if not provided than throws an error.\n * If root points to wrong block (that is not an invocation) it will misbehave\n * and likely throw some errors on field access.\n *\n * @template {API.Capability} C\n * @template {API.Invocation} Invocation\n * @template [T=never]\n * @param {object} dag\n * @param {API.UCANLink<[C]>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {T} [fallback]\n * @returns {API.Invocation<C>|T}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n\n  return /** @type {API.Invocation<C>} */ (create({ root: block, blocks }))\n}\n\n/**\n * @template {API.Capability} Capability\n * @implements {API.IssuedInvocationView<Capability>}\n * @implements {API.IssuedInvocation<Capability>}\n */\nclass IssuedInvocation {\n  /**\n   * @param {API.InvocationOptions<Capability>} data\n   */\n  constructor({\n    issuer,\n    audience,\n    capability,\n    proofs = [],\n    expiration,\n    lifetimeInSeconds,\n    notBefore,\n    nonce,\n    facts = [],\n    attachedBlocks,\n  }) {\n    /** @readonly */\n    this.issuer = issuer\n    /** @readonly */\n    this.audience = audience\n    /** @readonly */\n    this.proofs = proofs\n\n    /**\n     * @readonly\n     * @type {[Capability]}\n     */\n    this.capabilities = [capability]\n\n    this.expiration = expiration\n    this.lifetimeInSeconds = lifetimeInSeconds\n    this.notBefore = notBefore\n    this.nonce = nonce\n    this.facts = facts\n\n    /** @type {API.BlockStore<unknown>} */\n    this.attachedBlocks = attachedBlocks || new Map()\n  }\n\n  /**\n   * @param {API.Block} block\n   */\n  attach(block) {\n    this.attachedBlocks.set(`${block.cid}`, block)\n  }\n\n  delegate() {\n    return delegate(this)\n  }\n\n  buildIPLDView() {\n    return delegate(this)\n  }\n\n  /**\n   * @template {API.InvocationService<Capability>} Service\n   * @param {API.ConnectionView<Service>} connection\n   * @returns {Promise<API.InferReceipt<Capability, Service>>}\n   */\n  async execute(connection) {\n    /** @type {API.ServiceInvocation<Capability, Service>} */\n    // @ts-expect-error - Our `API.InvocationService<Capability>` constraint\n    // does not seem to be enough to convince TS that `this` is valid\n    // `ServiceInvocations<Service>`.\n    const invocation = this\n    const [result] = await connection.execute(invocation)\n    return result\n  }\n}\n\n/**\n * @template {API.Capability} Capability\n * @implements {API.Invocation<Capability>}\n * @extends {Delegation<[Capability]>}\n */\nexport class Invocation extends Delegation {}\n", "import * as API from '@ucanto/interface'\nimport * as DAG from './dag.js'\nimport { Invocation, panic } from './lib.js'\nimport * as Receipt from './receipt.js'\nimport * as Schema from './schema.js'\n\nexport const MessageSchema = Schema.variant({\n  'ucanto/message@7.0.0': Schema.struct({\n    execute: Schema.link().array().optional(),\n    delegate: Schema.dictionary({\n      key: Schema.string(),\n      value: /** @type {API.Reader<API.Link<API.ReceiptModel>>} */ (\n        Schema.link()\n      ),\n    })\n      .array()\n      .optional(),\n  }),\n})\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @param {object} source\n * @param {I} [source.invocations]\n * @param {R} [source.receipts]\n * @returns {Promise<API.AgentMessage<{ In: API.InferInvocations<I>, Out: R }>>}\n */\nexport const build = ({ invocations, receipts }) =>\n  new MessageBuilder({ invocations, receipts }).buildIPLDView()\n\n/**\n * @template [E=never]\n * @param {object} source\n * @param {API.Link} source.root\n * @param {DAG.BlockStore} source.store\n * @param {E} [fallback]\n * @returns {API.AgentMessage|E}\n */\nexport const view = ({ root, store }, fallback) => {\n  const block = DAG.get(root, store, null)\n  if (block === null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = DAG.CBOR.decode(block.bytes)\n  const [branch, value] = MessageSchema.match(data, fallback)\n  switch (branch) {\n    case 'ucanto/message@7.0.0':\n      return new Message({ root: { ...block, data }, store })\n    default:\n      return value\n  }\n}\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @implements {API.AgentMessageBuilder<{In: API.InferInvocations<I>, Out: R }>}\n *\n */\nclass MessageBuilder {\n  /**\n   * @param {object} source\n   * @param {I} [source.invocations]\n   * @param {R} [source.receipts]\n   */\n  constructor({ invocations, receipts }) {\n    this.invocations = invocations\n    this.receipts = receipts\n  }\n  /**\n   *\n   * @param {API.BuildOptions} [options]\n   * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}\n   */\n  async buildIPLDView(options) {\n    const store = new Map()\n\n    const { invocations, ...executeField } = await writeInvocations(\n      this.invocations || [],\n      store\n    )\n\n    const { receipts, ...receiptsField } = await writeReceipts(\n      this.receipts || [],\n      store\n    )\n\n    const root = await DAG.writeInto(\n      /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */\n      ({\n        'ucanto/message@7.0.0': {\n          ...executeField,\n          ...receiptsField,\n        },\n      }),\n      store,\n      options\n    )\n\n    return new Message({ root, store }, { receipts, invocations })\n  }\n}\n\n/**\n *\n * @param {API.IssuedInvocation[]} run\n * @param {Map<string, API.Block>} store\n */\nconst writeInvocations = async (run, store) => {\n  const invocations = []\n  const execute = []\n  for (const invocation of run) {\n    const view = await invocation.buildIPLDView()\n    execute.push(view.link())\n    invocations.push(view)\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n  }\n\n  return { invocations, ...(execute.length > 0 ? { execute } : {}) }\n}\n\n/**\n * @param {API.Receipt[]} source\n * @param {Map<string, API.Block>} store\n */\nconst writeReceipts = async (source, store) => {\n  if (source.length === 0) {\n    return {}\n  }\n\n  const receipts = new Map()\n  /** @type {Record<API.ToString<API.ReceiptModel['ocm']['ran']>, API.Link<API.ReceiptModel>>} */\n  const report = {}\n\n  for (const [n, receipt] of source.entries()) {\n    const view = await receipt.buildIPLDView()\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    const key = `${view.ran.link()}`\n    if (!(key in report)) {\n      report[key] = view.root.cid\n      receipts.set(key, view)\n    } else {\n      // In theory we could have gotten the same invocation twice and both\n      // should get same receipt. In legacy code we send tuple of results\n      // as opposed to a map keyed by invocation to keep old clients working\n      // we just stick the receipt in the map with a unique key so that when\n      // legacy encoder maps entries to array it will get both receipts in\n      // the right order.\n      receipts.set(`${key}@${n}`, view)\n    }\n  }\n\n  return { receipts, report }\n}\n\n/**\n * @template {{ In: API.Invocation[], Out: API.Receipt[] }} T\n * @implements {API.AgentMessage<T>}\n */\nclass Message {\n  /**\n   * @param {object} source\n   * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root\n   * @param {DAG.BlockStore} source.store\n   * @param {object} build\n   * @param {API.Invocation[]} [build.invocations]\n   * @param {Map<string, API.Receipt>} [build.receipts]\n   */\n  constructor({ root, store }, { invocations, receipts } = {}) {\n    this.root = root\n    this.store = store\n    this._invocations = invocations\n    this._receipts = receipts\n  }\n  *iterateIPLDBlocks() {\n    for (const invocation of this.invocations) {\n      yield* invocation.iterateIPLDBlocks()\n    }\n\n    for (const receipt of this.receipts.values()) {\n      yield* receipt.iterateIPLDBlocks()\n    }\n\n    yield this.root\n  }\n  /**\n   * @template [E=never]\n   * @param {API.Link} link\n   * @param {E} [fallback]\n   * @returns {API.Receipt|E}\n   */\n  get(link, fallback) {\n    const receipts = this.root.data['ucanto/message@7.0.0'].report || {}\n    const receipt = receipts[`${link}`]\n    if (receipt) {\n      return Receipt.view({ root: receipt, blocks: this.store })\n    } else {\n      return fallback !== undefined\n        ? fallback\n        : panic(`Message does not include receipt for ${link}`)\n    }\n  }\n\n  get invocationLinks() {\n    return this.root.data['ucanto/message@7.0.0'].execute || []\n  }\n\n  get invocations() {\n    let invocations = this._invocations\n    if (!invocations) {\n      invocations = this.invocationLinks.map(link => {\n        return Invocation.view({ root: link, blocks: this.store })\n      })\n    }\n\n    return invocations\n  }\n\n  get receipts() {\n    let receipts = this._receipts\n    if (!receipts) {\n      receipts = new Map()\n      const report = this.root.data['ucanto/message@7.0.0'].report || {}\n      for (const [key, link] of Object.entries(report)) {\n        const receipt = Receipt.view({ root: link, blocks: this.store })\n        receipts.set(`${receipt.ran.link()}`, receipt)\n      }\n    }\n\n    return receipts\n  }\n}\n", "import * as API from '@ucanto/interface'\nimport * as DID from '@ipld/dag-ucan/did'\nimport * as Invocation from './invocation.js'\nimport * as Delegation from './delegation.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as DAG from './dag.js'\nimport * as CBOR from './cbor.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n/**\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template [E=never]\n * @param {object} input\n * @param {API.Link<API.ReceiptModel<Ok, Error, Ran>>} input.root\n * @param {DAG.BlockStore} input.blocks\n * @param {E} [fallback]\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = CBOR.decode(block.bytes)\n\n  return new Receipt({ root: { ...block, data }, store: blocks })\n}\n\n/**\n * Represents a UCAN invocation receipt view over some block store e.g. in\n * memory CAR. It incrementally decodes proofs, ran invocation etc. on access\n * which reduces overhead but potentially defers errors if references blocks\n * do not conform to the expected IPLD schema.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} [SigAlg=API.SigAlg]\n * @implements {API.Receipt<Ok, Error, Ran, SigAlg>}\n */\nclass Receipt {\n  /**\n   * @param {object} input\n   * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root\n   * @param {DAG.BlockStore} input.store\n   * @param {API.Meta} [input.meta]\n   * @param {Ran|ReturnType<Ran['link']>} [input.ran]\n   * @param {API.EffectsModel} [input.fx]\n   * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]\n   * @param {API.UCAN.Principal} [input.issuer]\n   * @param {API.Proof[]} [input.proofs]\n   */\n  constructor({ root, store, ran, issuer, signature, proofs }) {\n    this.store = store\n\n    this.root = root\n    this._ran = ran\n\n    // Field is materialized on demand when `fx` getter is first accessed.\n    /** @type {API.Effects|undefined} */\n    this._fx = undefined\n    this._signature = signature\n    this._proofs = proofs\n    this._issuer = issuer\n  }\n\n  /**\n   * @returns {Ran|ReturnType<Ran['link']>}\n   */\n  get ran() {\n    const ran = this._ran\n    if (!ran) {\n      const ran = /** @type {Ran} */ (\n        Invocation.view(\n          {\n            root: this.root.data.ocm.ran,\n            blocks: this.store,\n          },\n          this.root.data.ocm.ran\n        )\n      )\n      this._ran = ran\n      return ran\n    } else {\n      return ran\n    }\n  }\n  get proofs() {\n    const proofs = this._proofs\n    if (proofs) {\n      return proofs\n    } else {\n      const { store, root } = this\n      const { prf } = root.data.ocm\n      const proofs = []\n      if (prf) {\n        for (const link of prf) {\n          const proof = Delegation.view({ root: link, blocks: store }, link)\n          proofs.push(proof)\n        }\n      }\n\n      this._proofs = proofs\n      return proofs\n    }\n  }\n  link() {\n    return this.root.cid\n  }\n  get meta() {\n    return this.root.data.ocm.meta\n  }\n  get issuer() {\n    const issuer = this._issuer\n    if (issuer) {\n      return issuer\n    } else {\n      const { iss } = this.root.data.ocm\n      if (iss) {\n        const issuer = DID.parse(iss)\n        this._issuer = issuer\n        return issuer\n      }\n    }\n  }\n\n  get out() {\n    return this.root.data.ocm.out\n  }\n\n  get fx() {\n    let fx = this._fx\n    if (!fx) {\n      const { store: blocks } = this\n      const { fork, join } = this.root.data.ocm.fx\n\n      fx = {\n        fork: fork.map(root => Invocation.view({ root, blocks }, root)),\n      }\n\n      if (join) {\n        fx.join = Invocation.view({ root: join, blocks }, join)\n      }\n\n      this._fx = fx\n    }\n    return fx\n  }\n\n  get signature() {\n    const signature = this._signature\n    if (signature) {\n      return signature\n    } else {\n      const signature =\n        /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */ (\n          Signature.view(this.root.data.sig)\n        )\n      this._signature = signature\n      return signature\n    }\n  }\n\n  /**\n   * @param {API.Crypto.Verifier} signingPrincipal\n   */\n  verifySignature(signingPrincipal) {\n    return this.signature.verify(\n      signingPrincipal,\n      CBOR.encode(this.root.data.ocm)\n    )\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  *iterateIPLDBlocks() {\n    const { ran, fx, proofs, root } = this\n\n    yield* DAG.iterate(ran)\n\n    for (const fork of fx.fork) {\n      yield* DAG.iterate(fork)\n    }\n\n    if (fx.join) {\n      yield* DAG.iterate(fx.join)\n    }\n\n    for (const proof of proofs) {\n      yield* DAG.iterate(proof)\n    }\n\n    yield root\n  }\n}\n\n/**\n * Represents a receipt builder that can be used to create a receipt that later\n * can be encoded into desired IPLD codec and hasher. In the future we may make\n * this an incremental builder so you could set some fields later on.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @implements {API.IPLDViewBuilder<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nclass ReceptBuilder {\n  /**\n   * @param {object} options\n   * @param {API.Signer<API.DID, SigAlg>} options.issuer\n   * @param {Ran|ReturnType<Ran['link']>} options.ran\n   * @param {API.Result<Ok, Error>} options.result\n   * @param {API.Effects} [options.fx]\n   * @param {API.Proof[]} [options.proofs]\n   * @param {Record<string, unknown>} [options.meta]\n   */\n  constructor({ issuer, result, ran, fx = NOFX, proofs = [], meta = {} }) {\n    this.issuer = issuer\n    this.result = result\n    this.ran = ran\n    this.fx = fx\n    this.proofs = proofs\n    this.meta = meta\n  }\n  async buildIPLDView({ hasher = sha256, codec = CBOR } = {}) {\n    const store = DAG.createStore()\n\n    // copy invocation blocks int\n    DAG.addEveryInto(DAG.iterate(this.ran), store)\n\n    // copy proof blocks into store\n    const prf = []\n    for (const proof of this.proofs) {\n      DAG.addEveryInto(DAG.iterate(proof), store)\n      prf.push(proof.link())\n    }\n\n    // copy blocks from the embedded fx\n    /** @type {{fork: API.Run[], join?:API.Run}}  */\n    const fx = { fork: [] }\n    for (const fork of this.fx.fork) {\n      DAG.addEveryInto(DAG.iterate(fork), store)\n      fx.fork.push(fork.link())\n    }\n\n    if (this.fx.join) {\n      DAG.addEveryInto(DAG.iterate(this.fx.join), store)\n      fx.join = this.fx.join.link()\n    }\n\n    /** @type {API.OutcomeModel<Ok, Error, Ran>} */\n    const outcome = {\n      ran: /** @type {ReturnType<Ran['link']>} */ (this.ran.link()),\n      out: this.result,\n      fx,\n      meta: this.meta,\n      iss: this.issuer.did(),\n      prf,\n    }\n\n    const signature = await this.issuer.sign(CBOR.encode(outcome))\n\n    /** @type {API.ReceiptModel<Ok, Error, Ran>} */\n    const model = {\n      ocm: outcome,\n      sig: signature,\n    }\n    const root = await DAG.writeInto(model, store, {\n      hasher,\n      codec,\n    })\n\n    return new Receipt({\n      root,\n      store,\n      signature,\n      proofs: this.proofs,\n      ran: this.ran,\n    })\n  }\n}\n\nconst NOFX = Object.freeze({ fork: Object.freeze([]) })\n\n/**\n * Creates a receipt in CBOR with sha256 hashed links.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @param {object} options\n * @param {API.Signer<API.DID, SigAlg>} options.issuer\n * @param {Ran|ReturnType<Ran['link']>} options.ran\n * @param {API.Result<Ok, Error>} options.result\n * @param {API.Effects} [options.fx]\n * @param {API.Proof[]} [options.proofs]\n * @param {Record<string, unknown>} [options.meta]\n * @returns {Promise<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nexport const issue = options => new ReceptBuilder(options).buildIPLDView()\n", "import { CAR } from '@ucanto/core'\nimport * as request from './car/request.js'\nimport * as response from './car/response.js'\nimport * as Codec from './codec.js'\n\nexport { CAR as codec, request, response }\n\nexport const contentType = CAR.contentType\n\nexport const inbound = Codec.inbound({\n  decoders: {\n    [request.contentType]: request,\n  },\n  encoders: {\n    [response.contentType]: response,\n  },\n})\n\nexport const outbound = Codec.outbound({\n  encoders: {\n    [request.contentType]: request,\n  },\n  decoders: {\n    [response.contentType]: response,\n  },\n})\n", "import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\n\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n  // We will signal that we want to receive a CAR file in the response\n  accept: contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions & { headers?: Record<string, string> }} [options]\n * @returns {API.HTTPRequest<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: options?.headers || { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n", "import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPResponse`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPResponse<Message>} response\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n", "import * as API from '@ucanto/interface'\n\n/**\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>}+${Lowercase<string>}`} ContentType\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>};q=${number}.${number}`} MediaType\n * @param {object} source\n * @param {Record<ContentType, API.Transport.RequestDecoder>} source.decoders\n * @param {Record<MediaType, API.Transport.ResponseEncoder>} source.encoders\n * @returns {API.InboundCodec}\n */\nexport const inbound = source => new Inbound(source)\n\n/**\n * @implements {API.InboundCodec}\n */\nclass Inbound {\n  /**\n   * @param {API.HTTPRequest} request\n   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport\n   */\n  accept({ headers }) {\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType]\n    if (!decoder) {\n      return {\n        error: {\n          status: 415,\n          message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,\n          headers: {\n            accept: Object.keys(this.decoders).join(', '),\n          },\n        },\n      }\n    }\n\n    const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*')\n    for (const { category, type } of accept) {\n      for (const encoder of this.encoders) {\n        const select =\n          (category === '*' || category === encoder.category) &&\n          (type === '*' || type === encoder.type)\n\n        if (select) {\n          return { ok: { ...encoder, decoder } }\n        }\n      }\n    }\n\n    return {\n      error: {\n        status: 406,\n        message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,\n        headers: {\n          accept: formatAcceptHeader(Object.values(this.encoders)),\n        },\n      },\n    }\n  }\n\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders\n   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n  }\n}\n\n/**\n * @param {object} source\n * @param {Record<MediaType, API.Transport.RequestEncoder>} source.encoders\n * @param {Record<ContentType, API.Transport.ResponseDecoder>} source.decoders\n * @returns {API.OutboundCodec}\n */\nexport const outbound = source => new Outbound(source)\n\n/**\n * @implements {API.OutboundCodec}\n */\nclass Outbound {\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders\n   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    this.acceptType = formatAcceptHeader(this.encoders)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n\n    this.encoder = this.encoders[0].encoder\n  }\n\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {Message} message\n   */\n  encode(message) {\n    return this.encoder.encode(message, {\n      accept: this.acceptType,\n    })\n  }\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {API.HTTPResponse<Message>} response\n   * @returns {API.Await<Message>}\n   */\n  decode(response) {\n    const { headers } = response\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType] || this.decoders['*/*']\n    switch (response.status) {\n      case 415:\n      case 406:\n        throw Object.assign(\n          new RangeError(new TextDecoder().decode(response.body)),\n          {\n            status: response.status,\n            headers: response.headers,\n          }\n        )\n    }\n    if (!decoder) {\n      throw Object.assign(\n        TypeError(\n          `Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`\n        ),\n        {\n          error: true,\n        }\n      )\n    }\n\n    return decoder.decode(response)\n  }\n}\n\n/**\n * @typedef {{ category: string, type: string, preference: number }} Media\n * @param {string} source\n * @returns {Media}\n */\nexport const parseMediaType = source => {\n  const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';')\n  const [category = '*', type = '*'] = mediaType.split('/')\n  const params = new URLSearchParams(mediaRange)\n  const preference = parseFloat(params.get('q') || '0')\n  return {\n    category,\n    type,\n    /* c8 ignore next */\n    preference: isNaN(preference) ? 0 : preference,\n  }\n}\n\n/**\n * @param {Media} media\n */\nexport const formatMediaType = ({ category, type, preference }) =>\n  /** @type {MediaType}  */ (\n    `${category}/${type}${preference ? `;q=${preference}` : ''}`\n  )\n\n/**\n * @param {string} source\n */\nexport const parseAcceptHeader = source =>\n  source\n    .split(',')\n    .map(parseMediaType)\n    .sort((a, b) => b.preference - a.preference)\n\n/**\n * @param {Media[]} source\n */\nexport const formatAcceptHeader = source =>\n  source.map(formatMediaType).join(', ')\n", "import * as API from '@ucanto/interface'\n\n/**\n * @typedef {{\n * ok: boolean\n * arrayBuffer():API.Await<ArrayBuffer>\n * headers: {\n *  entries?: () => Iterable<[string, string]>\n * } | Headers\n * status?: number\n * statusText?: string\n * url?: string\n * }} FetchResponse\n * @typedef {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} Fetcher\n */\n/**\n * @template S\n * @param {object} options\n * @param {URL} options.url\n * @param {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} [options.fetch]\n * @param {string} [options.method]\n * @param {Record<string, string>} [options.headers]\n * @returns {API.Channel<S>}\n */\nexport const open = ({ url, method = 'POST', fetch, headers }) => {\n  /* c8 ignore next 9 */\n  if (!fetch) {\n    if (typeof globalThis.fetch !== 'undefined') {\n      fetch = globalThis.fetch.bind(globalThis)\n    } else {\n      throw new TypeError(\n        `ucanto HTTP transport got undefined \\`fetch\\`. Try passing in a \\`fetch\\` implementation explicitly.`\n      )\n    }\n  }\n  return new Channel({ url, method, fetch, headers })\n}\n\n/**\n * @template {Record<string, any>} S\n * @implements {API.Channel<S>}\n */\nclass Channel {\n  /**\n   * @param {object} options\n   * @param {URL} options.url\n   * @param {Fetcher} options.fetch\n   * @param {string} [options.method]\n   * @param {Record<string, string>} [options.headers]\n   */\n  constructor({ url, fetch, method, headers }) {\n    this.fetch = fetch\n    this.method = method\n    this.url = url\n    this.headers = headers\n  }\n  /**\n   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I\n   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request\n   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}\n   */\n  async request({ headers, body }) {\n    const response = await this.fetch(this.url.href, {\n      headers: { ...this.headers, ...headers },\n      body,\n      method: this.method,\n    })\n\n    const buffer = response.ok\n      ? await response.arrayBuffer()\n      : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href}  ${response.status}`, response)\n\n    return {\n      headers: response.headers.entries\n        ? Object.fromEntries(response.headers.entries())\n        : /* c8 ignore next */\n          {},\n      body: new Uint8Array(buffer),\n    }\n  }\n}\n\n/**\n * @typedef {{\n * status?: number\n * statusText?: string\n * url?: string\n * }} Options\n */\nclass HTTPError extends Error {\n  /**\n   * @param {string} message\n   * @param {Options} options\n   * @returns {never}\n   */\n  static throw(message, options) {\n    throw new this(message, options)\n  }\n  /**\n   * @param {string} message\n   * @param {Options} options\n   */\n  constructor(message, { url, status = 500, statusText = 'Server error' }) {\n    super(message)\n    /** @type {'HTTPError'} */\n    this.name = 'HTTPError'\n    this.url = url\n    this.status = status\n    this.statusText = statusText\n  }\n}\n", "/**\n * Space Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Space from '@storacha/capabilities/space'\n * ```\n *\n * @module\n */\nimport * as Store from './store.js';\nimport { capability, Schema, ok, fail } from '@ucanto/validator';\nimport { SpaceDID, equalWith } from './utils.js';\nimport * as Upload from './upload.js';\nexport { top } from './top.js';\n// Need this to workaround TS bug\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Store };\nexport const space = capability({\n    can: 'space/*',\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `space/info` can be derived from any of the `store/*`\n * capability that has matching `with`. This allows store service\n * to identify account based on any user request.\n */\nexport const info = Store.add\n    .or(Store.list)\n    .or(Store.remove)\n    .or(Upload.add)\n    .or(Upload.list)\n    .or(Upload.remove)\n    .derive({\n    to: capability({\n        can: 'space/info',\n        with: SpaceDID,\n    }),\n    derives: equalWith,\n});\nexport const allocate = capability({\n    can: 'space/allocate',\n    with: SpaceDID,\n    nb: Schema.struct({\n        size: Schema.integer(),\n    }),\n    derives: (child, parent) => {\n        const result = equalWith(child, parent);\n        if (result.ok) {\n            return child.nb.size <= parent.nb.size\n                ? ok({})\n                : fail(`Claimed size ${child.nb.size} escalates delegated size ${parent.nb.size}`);\n        }\n        else {\n            return result;\n        }\n    },\n});\n/**\n * The capability grants permission for all content serve operations that fall under the \"space/content/serve\" namespace.\n * It can be derived from any of the `space/*` capability that has matching `with`.\n */\nexport const contentServe = capability({\n    can: 'space/content/serve/*',\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Capability can be invoked by an agent to record egress data for a given resource.\n * It can be derived from any of the `space/content/serve/*` capability that has matching `with`.\n */\nexport const egressRecord = capability({\n    can: 'space/content/serve/egress/record',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** CID of the resource that was served. */\n        resource: Schema.link(),\n        /** Amount of bytes served. */\n        bytes: Schema.integer().greaterThan(0),\n        /** Timestamp of the event in milliseconds after Unix epoch. */\n        servedAt: Schema.integer().greaterThan(-1),\n    }),\n    derives: equalWith,\n});\n/**\n * The capability grants permission to decrypt a given resource.\n * It can be derived from `space/content/decrypt` capability that has matching `with` and `nb.resource`.\n */\nexport const decrypt = capability({\n    can: 'space/content/decrypt',\n    with: SpaceDID,\n    nb: Schema.struct({\n        resource: Schema.link(),\n    }),\n    derives: (child, parent) => {\n        if (child.with !== parent.with) {\n            return fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n        }\n        if (child.nb.resource.toString() !== parent.nb.resource.toString()) {\n            return fail(`Can not derive ${child.can} resource ${child.nb.resource} from ${parent.nb.resource}`);\n        }\n        return ok({});\n    },\n});\n/**\n * \"Setup encryption for a Space using asymmetric keys in KMS.\"\n *\n * A Principal who may `space/encryption/setup` is permitted to initialize\n * encryption for a Space. This generates an RSA key pair in Google KMS\n * for the Space and returns the public key that clients can use to encrypt\n * per-file symmetric keys.\n *\n * This operation is idempotent - invoking it the first time generates the\n * asymmetric key for the space, but future invocations just return the\n * existing public key.\n *\n * The Space must be provisioned for a paid plan to use encryption.\n */\nexport const EncryptionSetup = capability({\n    can: 'space/encryption/setup',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * The location of the KMS key to use for encryption. If not provided, the Storacha Key Manager will use the default location.\n         */\n        location: Schema.string().optional(),\n        /**\n         * The keyring of the KMS key to use for encryption. If not provided, the Storacha Key Manager will use the default keyring.\n         */\n        keyring: Schema.string().optional(),\n    }),\n    derives: (child, parent) => {\n        if (child.with !== parent.with) {\n            return fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n        }\n        if (child.nb.location !== parent.nb.location) {\n            return fail(`Can not derive ${child.can} location ${child.nb.location} from ${parent.nb.location}`);\n        }\n        if (child.nb.keyring !== parent.nb.keyring) {\n            return fail(`Can not derive ${child.can} keyring ${child.nb.keyring} from ${parent.nb.keyring}`);\n        }\n        return ok({});\n    },\n});\n/**\n * \"Decrypt symmetric keys for encrypted content owned by the subject Space.\"\n *\n * A Principal who may `space/encryption/key/decrypt` is permitted to decrypt\n * the symmetric keys for any encrypted content owned by the Space. This capability\n * is used by the gateway to validate that a client has permission to access encrypted\n * content and receive the decrypted Data Encryption Keys (DEKs).\n *\n * The gateway will validate this capability against UCAN delegations before\n * providing decrypted Data Encryption Keys (DEKs) to authorized clients.\n */\nexport const EncryptionKeyDecrypt = capability({\n    can: 'space/encryption/key/decrypt',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * The encrypted symmetric key to be decrypted\n         */\n        key: Schema.bytes(),\n    }),\n    derives: (child, parent) => {\n        if (child.with !== parent.with) {\n            return fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n        }\n        if (child.nb.key !== parent.nb.key) {\n            return fail(`Can not derive ${child.can} key ${child.nb.key} from ${parent.nb.key}`);\n        }\n        return ok({});\n    },\n});\n//# sourceMappingURL=space.js.map", "/**\n * Store Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Store from '@storacha/capabilities/store'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok, fail } from '@ucanto/validator';\nimport { equalLink, equalWith, SpaceDID } from './utils.js';\n// @see https://github.com/multiformats/multicodec/blob/master/table.csv#L140\nexport const code = 0x0202;\nexport const CARLink = Schema.link({ code, version: 1 });\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n *\n * @deprecated\n */\nexport const store = capability({\n    can: 'store/*',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `store/add` capability allows agent to store a CAR file into a (memory) space\n * identified by did:key in the `with` field. Agent must precompute CAR locally\n * and provide it's CID and size using `nb.link` and `nb.size` fields, allowing\n * a service to provision a write location for the agent to PUT or POST desired\n * CAR into.\n *\n * @deprecated\n */\nexport const add = capability({\n    can: 'store/add',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * CID of the CAR file to be stored. Service will provision write target\n         * for this exact CAR file for agent to PUT or POST it. Attempt to write\n         * any other content will fail.\n         */\n        link: CARLink,\n        /**\n         * Size of the CAR file to be stored. Service will provision write target\n         * for this exact size. Attempt to write a larger CAR file will fail.\n         */\n        size: Schema.integer(),\n        /**\n         * Agent may optionally provide a link to a related CAR file using `origin`\n         * field. This is useful when storing large DAGs, agent could shard it\n         * across multiple CAR files and then link each shard with a previous one.\n         *\n         * Providing this relation tells service that given CAR is shard of the\n         * larger DAG as opposed to it being intentionally partial DAG. When DAG is\n         * not sharded, there will be only one `store/add` with `origin` left out.\n         */\n        origin: Link.optional(),\n    }),\n    derives: (claim, from) => {\n        const result = equalLink(claim, from);\n        if (result.error) {\n            return result;\n        }\n        else if (claim.nb.size !== undefined && from.nb.size !== undefined) {\n            return claim.nb.size > from.nb.size\n                ? fail(`Size constraint violation: ${claim.nb.size} > ${from.nb.size}`)\n                : ok({});\n        }\n        else {\n            return ok({});\n        }\n    },\n});\n/**\n * Capability to get store metadata by shard CID.\n * Use to check for inclusion, or get shard size and origin\n *\n * `nb.link` is optional to allow delegation of `store/get`\n * capability for any shard CID. If link is specified, then the\n * capability only allows a get for that specific CID.\n *\n * When used as as an invocation, `nb.link` must be specified.\n *\n * @deprecated\n */\nexport const get = capability({\n    can: 'store/get',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * shard CID to fetch info about.\n         */\n        link: CARLink.optional(),\n    }),\n    derives: equalLink,\n});\n/**\n * Capability can be used to remove the stored CAR file from the (memory)\n * space identified by `with` field.\n *\n * @deprecated\n */\nexport const remove = capability({\n    can: 'store/remove',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * CID of the CAR file to be removed from the store.\n         */\n        link: CARLink,\n    }),\n    derives: equalLink,\n});\n/**\n * Capability can be invoked to request a list of stored CAR files in the\n * (memory) space identified by `with` field.\n *\n * @deprecated\n */\nexport const list = capability({\n    can: 'store/list',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A pointer that can be moved back and forth on the list.\n         * It can be used to paginate a list for instance.\n         */\n        cursor: Schema.string().optional(),\n        /**\n         * Maximum number of items per page.\n         */\n        size: Schema.integer().optional(),\n        /**\n         * If true, return page of results preceding cursor. Defaults to false.\n         */\n        pre: Schema.boolean().optional(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        return ok({});\n    },\n});\n/** @deprecated */\nexport const all = add.or(remove).or(list);\n//  We export imports here so they are not omitted in generated typedes\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };\n//# sourceMappingURL=store.js.map", "import * as API from '@ucanto/interface'\nimport { isDelegation, UCAN, ok, fail } from '@ucanto/core'\nimport { capability } from './capability.js'\nimport * as Schema from '@ucanto/core/schema'\nimport * as Authorization from './authorization.js'\nimport {\n  UnavailableProof,\n  Unauthorized,\n  PrincipalAlignmentError,\n  Expired,\n  Revoked,\n  NotValidBefore,\n  InvalidSignature,\n  SessionEscalation,\n  Failure,\n  MalformedCapability,\n  DIDKeyResolutionError,\n  li,\n} from './error.js'\n\nexport { capability } from './capability.js'\nexport * from '@ucanto/core/schema'\n\nexport {\n  Schema,\n  Authorization,\n  Failure,\n  fail,\n  ok,\n  Revoked,\n  UnavailableProof,\n  Unauthorized,\n  MalformedCapability,\n  DIDKeyResolutionError as DIDResolutionError,\n}\n\n/**\n * @param {UCAN.Link} proof\n * @returns {{error:API.UnavailableProof}}\n */\nconst unavailable = proof => ({ error: new UnavailableProof(proof) })\n\n/**\n *\n * @param {UCAN.DID} did\n * @returns {{error:API.DIDKeyResolutionError}}\n */\nconst failDIDKeyResolution = did => ({ error: new DIDKeyResolutionError(did) })\n\n/**\n * @param {Required<API.ClaimOptions>} config\n * @param {API.Match<unknown, API.Match>} match\n */\n\nconst resolveMatch = async (match, config) => {\n  const promises = []\n  const includes = new Set()\n  for (const source of match.source) {\n    const id = source.delegation.cid.toString()\n    if (!includes.has(id)) {\n      promises.push(await resolveSources(source, config))\n    }\n  }\n  const groups = await Promise.all(promises)\n  const sources = []\n  const errors = []\n  for (const group of groups) {\n    sources.push(...group.sources)\n    errors.push(...group.errors)\n  }\n\n  return { sources, errors }\n}\n\n/**\n * Takes `proofs` from the delegation which may contain `Delegation` or a link\n * to one and attempts to resolve links by side loading them. Returns set of\n * resolved `Delegation`s and errors for the proofs that could not be resolved.\n *\n * @param {API.Proof[]} proofs\n * @param {Required<API.ProofResolver>} config\n */\nconst resolveProofs = async (proofs, config) => {\n  /** @type {API.Delegation[]} */\n  const delegations = []\n  /** @type {API.UnavailableProof[]} */\n  const errors = []\n  const promises = []\n  for (const proof of proofs) {\n    // If it is a delegation we can just add it to the resolved set.\n    if (isDelegation(proof)) {\n      delegations.push(proof)\n    }\n    // otherwise we attempt to resolve the link asynchronously. To avoid doing\n    // sequential requests we create promise for each link and then wait for\n    // all of them at the end.\n    else {\n      promises.push(\n        new Promise(async resolve => {\n          // config.resolve is not supposed to throw, but we catch it just in\n          // case it does and consider proof resolution failed.\n          try {\n            const result = await config.resolve(proof)\n            if (result.error) {\n              errors.push(result.error)\n            } else {\n              delegations.push(result.ok)\n            }\n          } catch (error) {\n            errors.push(\n              new UnavailableProof(proof, /** @type {Error} */(error))\n            )\n          }\n\n          // we don't care about the result, we just need to signal that we are\n          // done with this promise.\n          resolve(null)\n        })\n      )\n    }\n  }\n\n  // Wait for all the promises to resolve. At this point we have collected all\n  // the resolved delegations and errors.\n  await Promise.all(promises)\n  return { delegations, errors }\n}\n\n/**\n * Takes a delegation source and attempts to resolve all the linked proofs.\n *\n * @param {API.Source} from\n * @param {Required<API.ClaimOptions>} config\n * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}\n */\nconst resolveSources = async ({ delegation }, config) => {\n  const errors = []\n  const sources = []\n  const proofs = []\n  // First we attempt to resolve all the linked proofs.\n  const { delegations, errors: failedProofs } = await resolveProofs(\n    delegation.proofs,\n    config\n  )\n\n  // All the proofs that failed to resolve are saved as proof errors.\n  for (const error of failedProofs) {\n    errors.push(new ProofError(error.link, error))\n  }\n\n  // All the proofs that resolved are checked for principal alignment. Ones that\n  // do not align are saved as proof errors.\n  for (const proof of delegations) {\n    // If proof does not delegate to a matching audience save an proof error.\n    if (delegation.issuer.did() !== proof.audience.did()) {\n      errors.push(\n        new ProofError(\n          proof.cid,\n          new PrincipalAlignmentError(delegation.issuer, proof)\n        )\n      )\n    } else {\n      proofs.push(proof)\n    }\n  }\n  // In the second pass we attempt to proofs that were resolved and are aligned.\n  for (const proof of proofs) {\n    // If proof is not valid (expired, not active yet or has incorrect\n    // signature) save a corresponding proof error.\n    const validation = await validate(proof, proofs, config)\n    if (validation.error) {\n      errors.push(new ProofError(proof.cid, validation.error))\n    } else {\n      // otherwise create source objects for it's capabilities, so we could\n      // track which proof in which capability the are from.\n      for (const capability of proof.capabilities) {\n        sources.push(\n          /** @type {API.Source} */({\n            capability,\n            delegation: proof,\n          })\n        )\n      }\n    }\n  }\n\n  return { sources, errors }\n}\n\n/**\n * @param {API.ParsedCapability} capability\n * @param {API.DID} issuer\n */\nconst isSelfIssued = (capability, issuer) => capability.with === issuer\n\n/**\n * Finds a valid path in a proof chain of the given `invocation` by exploring\n * every possible option. On success an `Authorization` object is returned that\n * illustrates the valid path. If no valid path is found `Unauthorized` error\n * is returned detailing all explored paths and where they proved to fail.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {R} URI\n * @template {API.Caveats} C\n * @param {API.Invocation<API.Capability<A, URI, C>>} invocation\n * @param {API.ValidationOptions<API.ParsedCapability<A, R, C>>} options\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const access = async (invocation, { capability, ...config }) =>\n  claim(capability, [invocation], config)\n\n/**\n * Attempts to find a valid proof chain for the claimed `capability` given set\n * of `proofs`. On success an `Authorization` object with detailed proof chain\n * is returned and on failure `Unauthorized` error is returned with details on\n * paths explored and why they have failed.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>>>} capability\n * @param {API.Proof[]} proofs\n * @param {API.ClaimOptions} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const claim = async (\n  capability,\n  proofs,\n  {\n    authority,\n    principal,\n    validateAuthorization,\n    resolveDIDKey = failDIDKeyResolution,\n    canIssue = isSelfIssued,\n    resolve = unavailable,\n    proofs: localProofs = [],\n  }\n) => {\n  const config = {\n    canIssue,\n    resolve,\n    principal,\n    capability,\n    authority,\n    validateAuthorization,\n    resolveDIDKey,\n    proofs: localProofs,\n  }\n\n  const invalidProofs = []\n\n  /** @type {API.Source[]} */\n  const sources = []\n\n  const { delegations, errors } = await resolveProofs(proofs, config)\n  invalidProofs.push(...errors)\n\n  for (const proof of delegations) {\n    // Validate each proof if valid add ech capability to the list of sources.\n    // otherwise collect the error.\n    const validation = await validate(proof, delegations, config)\n    if (validation.ok) {\n      for (const capability of validation.ok.capabilities.values()) {\n        sources.push(\n          /** @type {API.Source} */({\n            capability,\n            delegation: validation.ok,\n          })\n        )\n      }\n    } else {\n      invalidProofs.push(validation.error)\n    }\n  }\n  // look for the matching capability\n  const selection = capability.select(sources)\n\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      const authorization = Authorization.create(matched, [])\n      const result = await validateAuthorization(authorization)\n      if (result.error) {\n        invalidProofs.push(result.error)\n      } else {\n        return { ok: authorization }\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        const authorization = Authorization.create(matched, [result.ok])\n        const approval = await validateAuthorization(authorization)\n        if (approval.error) {\n          invalidProofs.push(approval.error)\n        } else {\n          return { ok: authorization }\n        }\n      }\n    }\n  }\n\n  return {\n    error: new Unauthorized({\n      capability,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\n/**\n * Verifies whether any of the delegated proofs grant give capability.\n *\n * @template {API.Match} Match\n * @param {Match} match\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>}\n */\n\nexport const authorize = async (match, config) => {\n  // load proofs from all delegations\n  const { sources, errors: invalidProofs } = await resolveMatch(match, config)\n\n  const selection = match.select(sources)\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      return {\n        ok: Authorization.create(\n          // @ts-expect-error - it may not be a parsed capability but rather a\n          // group of capabilities but we can deal with that in the future.\n          matched,\n          []\n        ),\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        return {\n          ok: Authorization.create(\n            // @ts-expect-error - it may not be a parsed capability but rather a\n            // group of capabilities but we can deal with that in the future.\n            matched,\n            [result.ok]\n          ),\n        }\n      }\n    }\n  }\n\n  return {\n    error: new InvalidClaim({\n      match,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\nclass ProofError extends Failure {\n  /**\n   * @param {API.UCANLink} proof\n   * @param {API.Failure} cause\n   */\n  constructor(proof, cause) {\n    super()\n    this.name = 'ProofError'\n    this.proof = proof\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Capability can not be derived from prf:${this.proof} because:`,\n      li(this.cause.message),\n    ].join(`\\n`)\n  }\n}\n\n/**\n * @implements {API.InvalidClaim}\n */\nclass InvalidClaim extends Failure {\n  /**\n   * @param {{\n   * match: API.Match\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: ProofError[]\n   * failedProofs: API.InvalidClaim[]\n   * }} info\n   */\n  constructor(info) {\n    super()\n    this.info = info\n    this.name = /** @type {const} */ ('InvalidClaim')\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get delegation() {\n    return this.info.match.source[0].delegation\n  }\n  describe() {\n    const errors = [\n      ...this.info.failedProofs.map(error => li(error.message)),\n      ...this.info.delegationErrors.map(error => li(error.message)),\n      ...this.info.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.info.unknownCapabilities.map(c =>\n      li(JSON.stringify(c))\n    )\n\n    return [\n      `Capability ${this.info.match} is not authorized because:`,\n      li(`Capability can not be (self) issued by '${this.issuer.did()}'`),\n      ...(errors.length > 0 ? errors : [li(`Delegated capability not found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * Validate a delegation to check it is within the time bound and that it is\n * authorized by the issuer.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst validate = async (delegation, proofs, config) => {\n  if (UCAN.isExpired(delegation.data)) {\n    return {\n      error: new Expired(\n        /** @type {API.Delegation & {expiration: number}} */(delegation)\n      ),\n    }\n  }\n\n  if (UCAN.isTooEarly(delegation.data)) {\n    return {\n      error: new NotValidBefore(\n        /** @type {API.Delegation & {notBefore: number}} */(delegation)\n      ),\n    }\n  }\n\n  return await verifyAuthorization(delegation, proofs, config)\n}\n\n/**\n * Verifies that delegation has been authorized by the issuer. If issued by the\n * did:key principal checks that the signature is valid. If issued by the root\n * authority checks that the signature is valid. If issued by the principal\n * identified by other DID method attempts to resolve a valid `ucan/attest`\n * attestation from the authority, if attestation is not found falls back to\n * resolving did:key for the issuer and verifying its signature.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst verifyAuthorization = async (delegation, proofs, config) => {\n  const issuer = delegation.issuer.did()\n  // If the issuer is a did:key we just verify a signature\n  if (issuer.startsWith('did:key:')) {\n    return verifySignature(delegation, config.principal.parse(issuer))\n  }\n\n  // If the issuer is the root authority we use authority itself to verify\n  else if (issuer === config.authority.did()) {\n    return verifySignature(delegation, config.authority)\n  } else {\n    // If issuer is not a did:key principal nor configured authority, we\n    // attempt to resolve embedded authorization session from the authority.\n    const session = await verifySession(delegation, proofs, config)\n    // If we have valid session we consider authorization valid\n    if (session.ok) {\n      return { ok: delegation }\n    } else if (session.error.failedProofs.length > 0) {\n      return {\n        error: new SessionEscalation({ delegation, cause: session.error }),\n      }\n    }\n    // Otherwise we try to resolve did:key from the DID instead\n    // and use that to verify the signature\n    else {\n      const result = await config.resolveDIDKey(issuer)\n      if (result.error) {\n        return result\n      }\n\n      const verifiers = result.ok\n      /** @type {(API.InvalidSignature | API.DIDKeyResolutionError)[]} */\n      const verificationErrResults = []\n      for (const verifier of verifiers) {\n        const verificationResult = await verifySignature(\n          delegation,\n          config.principal.parse(verifier).withDID(issuer)\n        )\n        if (verificationResult.ok) {\n          return verificationResult\n        }\n        if (verificationResult.error) {\n          verificationErrResults.push(verificationResult.error)\n        }\n      }\n      \n      // If no verifiers were found, there is no way to verify the signature\n      if (verificationErrResults.length === 0) {\n        return { error: new DIDKeyResolutionError(issuer) }\n      }\n\n      const combinedError = verificationErrResults[0]\n      const combinedMessage = verificationErrResults\n        .map(err => err.message)\n        .join('\\n  ')\n      \n      // @ts-expect-error - both error types have describe method, override it to return the concatenated message\n      combinedError.describe = () => combinedMessage\n\n      return { error: combinedError }\n    }\n  }\n}\n\n/**\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Verifier} verifier\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}\n */\nconst verifySignature = async (delegation, verifier) => {\n  const valid = await UCAN.verifySignature(delegation.data, verifier)\n  return valid\n    ? { ok: delegation }\n    : { error: new InvalidSignature(delegation, verifier) }\n}\n\n/**\n * Attempts to find an authorization session - an `ucan/attest` capability\n * delegation where `with` matches `config.authority` and `nb.proof`\n * matches given delegation.\n * @see https://github.com/storacha/specs/blob/feat/auth+account/w3-session.md#authorization-session\n *\n * @param {API.Delegation} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n */\nconst verifySession = async (delegation, proofs, config) => {\n  // Recognize attestations from all authorized principals, not just authority\n  const withSchemas = config.proofs\n    .filter(\n      p =>\n        p.capabilities[0].can === 'ucan/attest' &&\n        p.capabilities[0].with === config.authority.did()\n    )\n    .map(p => Schema.literal(p.audience.did()))\n\n  const withSchema = withSchemas.length\n    ? Schema.union([Schema.literal(config.authority.did()), ...withSchemas])\n    : Schema.literal(config.authority.did())\n\n  // Create a schema that will match an authorization for this exact delegation\n  const attestation = capability({\n    with: withSchema,\n    can: 'ucan/attest',\n    nb: Schema.struct({\n      proof: Schema.link(delegation.cid),\n    }),\n  })\n\n  return await claim(\n    attestation,\n    proofs\n      // We only consider attestations otherwise we will end up doing an\n      // exponential scan if there are other proofs that require attestations.\n      .filter(isAttestation)\n      // Also filter any proofs that _are_ the delegation we're verifying so\n      // we don't recurse indefinitely.\n      .filter(p => p.cid.toString() !== delegation.cid.toString()),\n    config\n  )\n}\n\n/**\n * Checks if the delegation is an attestation.\n *\n * @param {API.Delegation} proof\n */\nconst isAttestation = proof => proof.capabilities[0]?.can === 'ucan/attest'\n", "import * as API from '@ucanto/interface'\nimport { entries, combine, intersection } from './util.js'\nimport {\n  EscalatedCapability,\n  MalformedCapability,\n  UnknownCapability,\n  DelegationError as MatchError,\n} from './error.js'\nimport { invoke, delegate, Schema } from '@ucanto/core'\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({ derives, nb, ...etc })\n\nconst defaultNBSchema =\n  /** @type {Schema.MapRepresentation<any>} */\n  (Schema.struct({}))\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right)\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors)\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({ from, to, derives }) => new Derive(from, to, derives)\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return { error: new UnknownCapability(source.capability) }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities)\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({ derives, to }) {\n    return derive({ derives, to, from: this })\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other)\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and(/** @type {API.CapabilityParser<M>} */ (this), other)\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super()\n    this.descriptor = descriptor\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb,\n    })\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const { descriptor, can } = this\n    const decoders = descriptor.nb\n    const data = /** @type {C} */ (options.nb || {})\n\n    const resource = descriptor.with.read(options.with)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.read(data)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return createCapability({ can, with: resource.ok, nb: nb.ok })\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({ with: with_, nb, ...options }) {\n    return invoke({\n      ...options,\n      capability: this.create(\n        /** @type {API.InferCreateOptions<R, C>} */\n        ({ with: with_, nb })\n      ),\n    })\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({ nb: input = {}, with: with_, ...options }) {\n    const { descriptor, can } = this\n    const readers = descriptor.nb\n\n    const resource = descriptor.with.read(with_)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.partial().read(input)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return delegate({\n      capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],\n      ...options,\n    })\n  }\n\n  get can() {\n    return this.descriptor.can\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source)\n    return result.error\n      ? result\n      : { ok: new Match(source, result.ok, this.descriptor) }\n  }\n  toString() {\n    return JSON.stringify({ can: this.descriptor.can })\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({ can, with: with_, nb }) =>\n  /** @type {API.InferCapability<T>} */ ({\n    can,\n    with: with_,\n    ...(isEmpty(nb) ? {} : { nb }),\n  })\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super()\n    this.left = left\n    this.right = right\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability)\n    if (left.error) {\n      const right = this.right.match(capability)\n      if (right.error) {\n        return right.error.name === 'MalformedCapability'\n          ? //\n            right\n          : //\n            left\n      } else {\n        return right\n      }\n    } else {\n      return left\n    }\n  }\n\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super()\n    this.selectors = selectors\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = []\n    for (const selector of this.selectors) {\n      const result = selector.match(capability)\n      if (result.error) {\n        return result\n      } else {\n        group.push(result.ok)\n      }\n    }\n\n    return {\n      ok: new AndMatch(/** @type {API.InferMembers<Selectors>} */ (group)),\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other])\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super()\n    this.from = from\n    this.to = to\n    this.derives = derives\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options)\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options)\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options)\n  }\n  get can() {\n    return this.to.can\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability)\n    if (match.error) {\n      return match\n    } else {\n      return { ok: new DerivedMatch(match.ok, this.from, this.derives) }\n    }\n  }\n  toString() {\n    return this.to.toString()\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source]\n    this.value = value\n    this.descriptor = descriptor\n  }\n  get can() {\n    return this.value.can\n  }\n\n  get proofs() {\n    const proofs = [this.source[0].delegation]\n    Object.defineProperties(this, {\n      proofs: { value: proofs },\n    })\n    return proofs\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = []\n    const errors = []\n    const matches = []\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability)\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok)\n        if (claim.error) {\n          errors.push(\n            new MatchError(\n              [new EscalatedCapability(this.value, result.ok, claim.error)],\n              this\n            )\n          )\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor))\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability)\n            break\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this))\n        }\n      }\n    }\n\n    return { matches, unknown, errors }\n  }\n  toString() {\n    const { nb } = this.value\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined,\n    })\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected\n    this.from = from\n    this.derives = derives\n  }\n  get can() {\n    return this.value.can\n  }\n  get source() {\n    return this.selected.source\n  }\n  get proofs() {\n    const proofs = []\n    for (const { delegation } of this.selected.source) {\n      proofs.push(delegation)\n    }\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  get value() {\n    return this.selected.value\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected =\n      /** @type {API.DirectMatch<T>|null} */\n      (this.selected.prune(context))\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const { derives, selected, from } = this\n    const { value } = selected\n\n    const direct = selected.select(capabilities)\n\n    const derived = from.select(capabilities)\n    const matches = []\n    const errors = []\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value)\n      if (result.error) {\n        errors.push(\n          new MatchError(\n            [new EscalatedCapability(value, match.value, result.error)],\n            this\n          )\n        )\n      } else {\n        matches.push(match)\n      }\n    }\n\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [\n        ...errors,\n        ...direct.errors,\n        ...derived.errors.map(error => new MatchError([error], this)),\n      ],\n      matches: [\n        ...direct.matches.map(match => new DerivedMatch(match, from, derives)),\n        ...matches,\n      ],\n    }\n  }\n\n  toString() {\n    return this.selected.toString()\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches\n  }\n  get selectors() {\n    return this.matches\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = []\n\n    for (const match of this.matches) {\n      source.push(...match.source)\n    }\n    Object.defineProperties(this, { source: { value: source } })\n    return source\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = []\n    for (const match of this.matches) {\n      const pruned = match.prune(context)\n      if (pruned) {\n        matches.push(pruned)\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches)\n  }\n\n  get proofs() {\n    const proofs = []\n\n    for (const { delegation } of this.source) {\n      proofs.push(delegation)\n    }\n\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = []\n\n    for (const match of this.matches) {\n      value.push(match.value)\n    }\n    Object.defineProperties(this, { value: { value } })\n    return /** @type {any} */ (value)\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1))\n        ? can\n        : fallback\n  }\n}\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri\n    default:\n      return fallback\n  }\n}\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const { delegation } = source\n  const capability = /** @type {API.Capability<A, R, C>} */ (source.capability)\n\n  if (descriptor.can !== capability.can) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const uri = descriptor.with.read(capability.with)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read(capability.nb || {})\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, { capability, delegation }) => {\n  const can = resolveAbility(capability.can, claimed.can, null)\n  if (can == null) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const resource = resolveResource(\n    capability.with,\n    claimed.with,\n    capability.with\n  )\n  const uri = descriptor.with.read(resource)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb,\n  })\n\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can\n    this.with = with_\n    this.delegation = delegation\n    this.nb = nb\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = []\n  const matches = []\n  const errors = []\n  for (const capability of capabilities) {\n    const result = matcher.match(capability)\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability)\n          break\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability))\n      }\n    } else {\n      matches.push(result.ok)\n    }\n  }\n\n  return { matches, errors, unknown }\n}\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown\n  const data = []\n  const errors = []\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities)\n    unknown = unknown\n      ? intersection(unknown, selected.unknown)\n      : selected.unknown\n\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self))\n    }\n\n    data.push(selected.matches)\n  }\n\n  const matches = combine(data).map(group => new AndMatch(group))\n\n  return {\n    unknown:\n      /* c8 ignore next */\n      unknown || [],\n    errors,\n    matches,\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(\n        `Resource ${claimed.with} does not match delegated ${delegated.with} `\n      )\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(\n      `Resource ${claimed.with} is not contained by ${delegated.with}`\n    )\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {}\n  const nb = claimed.nb || {}\n  const kv = entries(caveats)\n\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`)\n    }\n  }\n\n  return { ok: true }\n}\n", "/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => /** @type {any} */ (Object.entries(object))\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value])\n  for (const values of rest) {\n    const tuples = results.splice(0)\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value])\n      }\n    }\n  }\n  return results\n}\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] =\n    left.length < right.length\n      ? [new Set(left), new Set(right)]\n      : [new Set(right), new Set(left)]\n\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item)\n    }\n  }\n\n  return [...result]\n}\n", "import * as API from '@ucanto/interface'\nimport { the } from './util.js'\nimport { isLink } from '@ucanto/core/link'\nimport { fail, Failure } from '@ucanto/core/result'\n\nexport { Failure, fail }\n\nexport class EscalatedCapability extends Failure {\n  /**\n   * @param {API.ParsedCapability} claimed\n   * @param {object} delegated\n   * @param {API.Failure} cause\n   */\n  constructor(claimed, delegated, cause) {\n    super()\n    this.claimed = claimed\n    this.delegated = delegated\n    this.cause = cause\n    this.name = the('EscalatedCapability')\n  }\n  describe() {\n    return `Constraint violation: ${this.cause.message}`\n  }\n}\n\n/**\n * @implements {API.DelegationError}\n */\nexport class DelegationError extends Failure {\n  /**\n   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes\n   * @param {object} context\n   */\n  constructor(causes, context) {\n    super()\n    this.name = the('InvalidClaim')\n    this.causes = causes\n    this.context = context\n  }\n  describe() {\n    return [\n      `Can not derive ${this.context} from delegated capabilities:`,\n      ...this.causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n\n  /**\n   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}\n   */\n  get cause() {\n    /* c8 ignore next 9 */\n    if (this.causes.length !== 1) {\n      return this\n    } else {\n      const [cause] = this.causes\n      const value = cause.name === 'InvalidClaim' ? cause.cause : cause\n      Object.defineProperties(this, { cause: { value } })\n      return value\n    }\n  }\n}\n\n/**\n * @implements {API.SessionEscalation}\n */\nexport class SessionEscalation extends Failure {\n  /**\n   * @param {object} source\n   * @param {API.Delegation} source.delegation\n   * @param {API.Failure} source.cause\n   */\n  constructor({ delegation, cause }) {\n    super()\n    this.name = the('SessionEscalation')\n    this.delegation = delegation\n    this.cause = cause\n  }\n  describe() {\n    const issuer = this.delegation.issuer.did()\n    return [\n      `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @implements {API.InvalidSignature}\n */\nexport class InvalidSignature extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   * @param {API.Verifier} verifier\n   */\n  constructor(delegation, verifier) {\n    super()\n    this.name = the('InvalidSignature')\n    this.delegation = delegation\n    this.verifier = verifier\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n  get key() {\n    return this.verifier.toDIDKey()\n  }\n  describe() {\n    const issuer = this.issuer.did()\n    const key = this.key\n    return (\n      issuer.startsWith('did:key')\n        ? [\n            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`,\n          ]\n        : [\n            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,\n            `   Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`,\n          ]\n    ).join('\\n')\n  }\n}\n\n/**\n * @implements {API.UnavailableProof}\n */\nexport class UnavailableProof extends Failure {\n  /**\n   * @param {API.UCAN.Link} link\n   * @param {Error} [cause]\n   */\n  constructor(link, cause) {\n    super()\n    this.name = the('UnavailableProof')\n    this.link = link\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Linked proof '${this.link}' is not included and could not be resolved`,\n      ...(this.cause\n        ? [li(`Proof resolution failed with: ${this.cause.message}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\nexport class DIDKeyResolutionError extends Failure {\n  /**\n   * @param {API.UCAN.DID} did\n   * @param {API.Failure} [cause]\n   */\n  constructor(did, cause) {\n    super()\n    this.name = the('DIDKeyResolutionError')\n    this.did = did\n    this.cause = cause\n  }\n  describe() {\n    return `Unable to resolve '${this.did}' key`\n  }\n}\n\n/**\n * @implements {API.InvalidAudience}\n */\nexport class PrincipalAlignmentError extends Failure {\n  /**\n   * @param {API.UCAN.Principal} audience\n   * @param {API.Delegation} delegation\n   */\n  constructor(audience, delegation) {\n    super()\n    this.name = the('InvalidAudience')\n    this.audience = audience\n    this.delegation = delegation\n  }\n  describe() {\n    return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`\n  }\n  toJSON() {\n    const { name, audience, message, stack } = this\n    return {\n      name,\n      audience: audience.did(),\n      delegation: { audience: this.delegation.audience.did() },\n      message,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.MalformedCapability}\n */\nexport class MalformedCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   * @param {API.Failure} cause\n   */\n  constructor(capability, cause) {\n    super()\n    this.name = the('MalformedCapability')\n    this.capability = capability\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Encountered malformed '${this.capability.can}' capability: ${format(\n        this.capability\n      )}`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nexport class UnknownCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   */\n  constructor(capability) {\n    super()\n    this.name = the('UnknownCapability')\n    this.capability = capability\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return `Encountered unknown capability: ${format(this.capability)}`\n  }\n}\n\nexport class Expired extends Failure {\n  /**\n   * @param {API.Delegation & { expiration: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Expired')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has expired on ${new Date(\n      this.delegation.expiration * 1000\n    )}`\n  }\n  get expiredAt() {\n    return this.delegation.expiration\n  }\n  toJSON() {\n    const { name, expiredAt, message, stack } = this\n    return {\n      name,\n      message,\n      expiredAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Revoked}\n */\nexport class Revoked extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Revoked')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has been revoked`\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return {\n      name,\n      message,\n      stack,\n    }\n  }\n}\n\nexport class NotValidBefore extends Failure {\n  /**\n   * @param {API.Delegation & { notBefore: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('NotValidBefore')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} is not valid before ${new Date(\n      this.delegation.notBefore * 1000\n    )}`\n  }\n  get validAt() {\n    return this.delegation.notBefore\n  }\n  toJSON() {\n    const { name, validAt, message, stack } = this\n    return {\n      name,\n      message,\n      validAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Unauthorized}\n */\n\nexport class Unauthorized extends Failure {\n  /**\n   * @param {{\n   * capability: API.CapabilityParser\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: API.InvalidProof[]\n   * failedProofs: API.InvalidClaim[]\n   * }} cause\n   */\n  constructor({\n    capability,\n    delegationErrors,\n    unknownCapabilities,\n    invalidProofs,\n    failedProofs,\n  }) {\n    super()\n    this.name = /** @type {const} */  ('Unauthorized')\n    this.capability = capability\n    this.delegationErrors = delegationErrors\n    this.unknownCapabilities = unknownCapabilities\n    this.invalidProofs = invalidProofs\n    this.failedProofs = failedProofs\n  }\n\n  describe() {\n    const errors = [\n      ...this.failedProofs.map(error => li(error.message)),\n      ...this.delegationErrors.map(error => li(error.message)),\n      ...this.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.unknownCapabilities.map(c => li(JSON.stringify(c)))\n\n    return [\n      `Claim ${this.capability} is not authorized`,\n      ...(errors.length > 0\n        ? errors\n        : [li(`No matching delegated capability found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {unknown} capability\n * @param {string|number} [space]\n */\n\nconst format = (capability, space) =>\n  JSON.stringify(\n    capability,\n    (_key, value) => {\n      /* c8 ignore next 2 */\n      if (isLink(value)) {\n        return value.toString()\n      } else {\n        return value\n      }\n    },\n    space\n  )\n\n/**\n * @param {string} message\n */\nexport const indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nexport const li = message => indent(`- ${message}`)\n", "import * as API from '@ucanto/interface'\n\n/**\n * @template {API.ParsedCapability} C\n * @implements {API.Authorization<C>}\n */\nclass Authorization {\n  /**\n   * @param {API.Match<C>} match\n   * @param {API.Authorization<API.ParsedCapability>[]} proofs\n   */\n  constructor(match, proofs) {\n    this.match = match\n    this.proofs = proofs\n  }\n  get capability() {\n    return this.match.value\n  }\n  get delegation() {\n    return this.match.source[0].delegation\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n}\n\n/**\n * @template {API.ParsedCapability} C\n * @param {API.Match<C>} match\n * @param {API.Authorization<API.ParsedCapability>[]} proofs\n * @returns {API.Authorization<C>}\n */\nexport const create = (match, proofs = []) => new Authorization(match, proofs)\n\n/**\n *\n * @param {API.Authorization} authorization\n * @returns {Iterable<API.UCANLink>}\n */\nexport const iterate = function* ({ delegation, proofs }) {\n  yield delegation.cid\n  for (const proof of proofs) {\n    yield* iterate(proof)\n  }\n}\n", "import * as API from '@ucanto/interface';\nimport { DID, Schema, fail, ok } from '@ucanto/validator';\nimport { equals } from 'multiformats/bytes';\nimport { base58btc } from 'multiformats/bases/base58';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\nexport const SpaceDID = DID.match({ method: 'key' });\nexport const AccountDID = DID.match({ method: 'mailto' });\nexport const Await = Schema.struct({\n    'ucan/await': Schema.tuple([Schema.string(), Schema.link()]),\n});\n/**\n *\n * Check URI can be delegated.\n *\n * @param {string} [child]\n * @param {string} [parent]\n */\nexport function canDelegateURI(child, parent) {\n    if (parent === undefined) {\n        return ok({});\n    }\n    if (child !== undefined && parent.endsWith('*')) {\n        return child.startsWith(parent.slice(0, -1))\n            ? ok({})\n            : fail(`${child} does not match ${parent}`);\n    }\n    return child === parent\n        ? ok({})\n        : fail(`${child} is different from ${parent}`);\n}\n/**\n * Checks that `with` on claimed capability is the same as `with`\n * in delegated capability. Note this will ignore `can` field.\n *\n * @param {API.ParsedCapability} child\n * @param {API.ParsedCapability} parent\n */\nexport function equalWith(child, parent) {\n    return child.with === parent.with\n        ? ok({})\n        : fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n}\n/**\n * @param {unknown} child\n * @param {unknown} parent\n * @param {string} constraint\n */\nexport function equal(child, parent, constraint) {\n    if (parent === undefined || parent === '*') {\n        return ok({});\n    }\n    else if (String(child) === String(parent)) {\n        return ok({});\n    }\n    else {\n        return fail(`Constraint violation: ${child} violates imposed ${constraint} constraint ${parent}`);\n    }\n}\n/**\n * @template {any} T\n * @param {T[]} child\n * @param {T[]} parent\n * @param {string} constraint\n */\nexport function containedWithin(child, parent, constraint) {\n    if (child.every((item) => parent.includes(item))) {\n        return ok({});\n    }\n    else {\n        return fail(`Constraint violation: ${child} violates imposed ${constraint} constraint ${parent} because it contains items not in the constraint`);\n    }\n}\n/**\n * @template {API.ParsedCapability<\"store/add\"|\"store/get\"|\"store/remove\", API.URI<'did:'>, {link?: API.Link<unknown, number, number, 0|1>}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalLink = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.link &&\n        `${delegated.nb.link}` !== `${claimed.nb.link}`) {\n        return fail(`Link ${claimed.nb.link ? `${claimed.nb.link}` : ''} violates imposed ${delegated.nb.link} constraint.`);\n    }\n    else {\n        return ok({});\n    }\n};\n/** @param {API.UnknownLink | { digest: Uint8Array }} linkOrDigest */\nconst toDigestBytes = (linkOrDigest) => 'multihash' in linkOrDigest\n    ? linkOrDigest.multihash.bytes\n    : linkOrDigest.digest;\n/**\n * @template {API.ParsedCapability<API.Ability, API.URI, { content?: API.UnknownLink | { digest: Uint8Array } }>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalLinkOrDigestContent = (claimed, delegated) => {\n    if (delegated.nb.content) {\n        const delegatedBytes = toDigestBytes(delegated.nb.content);\n        if (!claimed.nb.content) {\n            return fail(`Constraint violation: undefined violates imposed content constraint ${base58btc.encode(delegatedBytes)}`);\n        }\n        const claimedBytes = toDigestBytes(claimed.nb.content);\n        if (!equals(claimedBytes, delegatedBytes)) {\n            return fail(`Constraint violation: ${base58btc.encode(claimedBytes)} violates imposed content constraint ${base58btc.encode(delegatedBytes)}`);\n        }\n    }\n    return ok({});\n};\n/**\n * @template {API.ParsedCapability<API.Ability, API.URI<'did:'>, {blob: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalBlob = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.blob.digest &&\n        !equals(delegated.nb.blob.digest, claimed.nb.blob.digest)) {\n        return fail(`Link ${claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ''} violates imposed ${delegated.nb.blob.digest} constraint.`);\n    }\n    else if (claimed.nb.blob.size !== undefined &&\n        delegated.nb.blob.size !== undefined) {\n        return claimed.nb.blob.size > delegated.nb.blob.size\n            ? fail(`Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`)\n            : ok({});\n    }\n    else {\n        return ok({});\n    }\n};\n/**\n * @template {API.ParsedCapability<\"http/put\", API.URI<'did:'>, {body: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalBody = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.body.digest &&\n        !equals(delegated.nb.body.digest, claimed.nb.body.digest)) {\n        return fail(`Link ${claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ''} violates imposed ${delegated.nb.body.digest} constraint.`);\n    }\n    else if (claimed.nb.body.size !== undefined &&\n        delegated.nb.body.size !== undefined) {\n        return claimed.nb.body.size !== delegated.nb.body.size\n            ? fail(`Size constraint violation: ${claimed.nb.body.size} !== ${delegated.nb.body.size}`)\n            : ok({});\n    }\n    else {\n        return ok({});\n    }\n};\n/**\n * @template {API.ParsedCapability<\"blob/add\"|\"blob/remove\"|\"blob/allocate\"|\"blob/accept\"|\"http/put\", API.URI<'did:'>, {content: Uint8Array}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalContent = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.content &&\n        !equals(delegated.nb.content, claimed.nb.content)) {\n        return fail(`Link ${claimed.nb.content ? `${claimed.nb.content}` : ''} violates imposed ${delegated.nb.content} constraint.`);\n    }\n    else {\n        return ok({});\n    }\n};\n/**\n * Checks that `claimed` {@link API.Link} meets an `imposed` constraint.\n *\n * @param {API.UnknownLink} claimed\n * @param {API.UnknownLink|undefined} imposed\n * @param {string} at\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const checkLink = (claimed, imposed, at) => {\n    return equal(String(claimed), imposed === undefined ? undefined : String(imposed), at);\n};\n/**\n * @template T\n * @param {API.Result<T , API.Failure>} result\n * @returns {{error: API.Failure, ok?:undefined}|undefined}\n */\nexport const and = (result) => (result.error ? result : undefined);\n/**\n *\n * @param {import('@ucanto/interface').Ability} ability\n */\nfunction parseAbility(ability) {\n    const [namespace, ...segments] = ability.split('/');\n    return { namespace, segments };\n}\n/**\n *\n * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'\n *\n * @param {import('@ucanto/interface').Ability} parent\n * @param {import('@ucanto/interface').Ability} child\n */\nexport function canDelegateAbility(parent, child) {\n    const parsedParent = parseAbility(parent);\n    const parsedChild = parseAbility(child);\n    // Parent is wildcard\n    if (parsedParent.namespace === '*' && parsedParent.segments.length === 0) {\n        return true;\n    }\n    // Child is wild card so it can not be delegated from anything\n    if (parsedChild.namespace === '*' && parsedChild.segments.length === 0) {\n        return false;\n    }\n    // namespaces don't match\n    if (parsedParent.namespace !== parsedChild.namespace) {\n        return false;\n    }\n    // given that namespaces match and parent first segment is wildcard\n    if (parsedParent.segments[0] === '*') {\n        return true;\n    }\n    // Array equality\n    if (parsedParent.segments.length !== parsedChild.segments.length) {\n        return false;\n    }\n    // all segments must match\n    return parsedParent.segments.reduce((acc, v, i) => acc && parsedChild.segments[i] === v, true);\n}\n//# sourceMappingURL=utils.js.map", "/**\n * Upload Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@storacha/capabilities/upload'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok } from '@ucanto/validator';\nimport { codec as CAR } from '@ucanto/transport/car';\nimport { equalWith, and, equal, SpaceDID } from './utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `upload/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const upload = capability({\n    can: 'upload/*',\n    /**\n     * DID of the (memory) space where upload is add to the\n     * upload list.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Schema representing a link (a.k.a CID) to a CAR file. Enforces CAR codec code and CID v1.\n */\nconst CARLink = Link.match({ code: CAR.code, version: 1 });\n/**\n * Capability allows an agent to add an arbitrary DAG (root) to the upload list\n * of the specified (memory) space (identified by did:key in the `with` field).\n * It is recommended to provide an optional list of shard links that contain\n * fragments of this DAG, as it allows system to optimize block discovery, it is\n * also a way to communicate DAG partiality - this upload contains partial DAG\n * identified by the given `root`.\n *\n * Usually when agent wants to upload a DAG it will encode it as a one or more\n * CAR files (shards) and invoke `store/add` capability for each one. Once all\n * shards are stored it will invoke `upload/add` capability (providing link to\n * a DAG root and all the shards) to add it the upload list.\n *\n * That said `upload/add` could be invoked without invoking `store/add`s e.g.\n * because another (memory) space may already have those CARs.\n *\n * Note: If DAG with the given root is already in the upload list, invocation\n * will simply update `shards` to be a union of existing and new shards.\n */\nexport const add = capability({\n    can: 'upload/add',\n    /**\n     * DID of the (memory) space where uploaded is added.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Root CID of the DAG to be added to the upload list.\n         */\n        root: Link,\n        /**\n         * CIDs to the CAR files that contain blocks of the DAG.\n         */\n        shards: CARLink.array().optional(),\n    }),\n    derives: (self, from) => {\n        return (and(equalWith(self, from)) ||\n            and(equal(self.nb.root, from.nb.root, 'root')) ||\n            and(equal(self.nb.shards, from.nb.shards, 'shards')) ||\n            ok({}));\n    },\n});\n/**\n * Capability to get upload metadata by root CID.\n * Use to check for inclusion, or find the shards for a root.\n *\n * `nb.root` is optional to allow delegation of `upload/get`\n * capability for any root. If root is specified, then the\n * capability only allows a get for that single cid.\n *\n * When used as as an invocation, `nb.root` must be specified.\n */\nexport const get = capability({\n    can: 'upload/get',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Root CID of the DAG to fetch upload info about.\n         */\n        root: Link.optional(),\n    }),\n    derives: (self, from) => {\n        const res = equalWith(self, from);\n        if (res.error) {\n            return res;\n        }\n        if (!from.nb.root) {\n            return res;\n        }\n        // root must match if specified in the proof\n        return equal(self.nb.root, from.nb.root, 'root');\n    },\n});\n/**\n * Capability removes an upload (identified by it's root CID) from the upload\n * list. Please note that removing an upload does not delete corresponding shards\n * from the store, however that could be done via `store/remove` invocations.\n */\nexport const remove = capability({\n    can: 'upload/remove',\n    /**\n     * DID of the (memory) space where uploaded is removed from.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Root CID of the DAG to be removed from the upload list.\n         */\n        root: Link,\n    }),\n    derives: (self, from) => {\n        return (and(equalWith(self, from)) ||\n            and(equal(self.nb.root, from.nb.root, 'root')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked to request a list of uploads in the (memory) space\n * identified by the `with` field.\n */\nexport const list = capability({\n    can: 'upload/list',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A pointer that can be moved back and forth on the list.\n         * It can be used to paginate a list for instance.\n         */\n        cursor: Schema.string().optional(),\n        /**\n         * Maximum number of items per page.\n         */\n        size: Schema.integer().optional(),\n        /**\n         * If true, return page of results preceding cursor. Defaults to false.\n         */\n        pre: Schema.boolean().optional(),\n    }),\n});\nexport const all = add.or(remove).or(list);\n//  We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Link, Schema };\n//# sourceMappingURL=upload.js.map", "/**\n * Top Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@storacha/capabilities/top'\n * ```\n *\n * @module\n */\nimport { capability, Schema } from '@ucanto/validator';\nimport { equalWith } from './utils.js';\n/**\n * Represents the top `{ can: '*', with: 'did:key:zAlice' }` capability, which we often\n * also call account linking.\n *\n * @see {@link https://github.com/ucan-wg/spec#52-top}\n */\nexport const top = capability({\n    can: '*',\n    with: Schema.or(Schema.did(), Schema.literal('ucan:*')),\n    derives: equalWith,\n});\n//# sourceMappingURL=top.js.map", "/**\n * UCAN core capabilities.\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport * as API from '@ucanto/interface';\nimport { equalWith, equal, and, checkLink } from './utils.js';\nexport const UCANLink = \n/** @type {Schema.Schema<API.UCANLink, unknown>} */\n(Schema.link({ version: 1 }));\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const ucan = capability({\n    can: 'ucan/*',\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * `ucan/revoke` capability is a replacement for the\n * [UCAN Revocation](https://github.com/ucan-wg/spec#66-revocation) that had\n * been proposed to a UCAN working group and had a tentative support from\n * members.\n *\n * Capability can be used to revoke `nb.ucan` authorization from all proofs\n * chains that lead to the UCAN issued or being delegated to the principal\n * identified by the `with` field. Note that revoked UCAN MUST continue to\n * be valid in the invocation where proof chain does not lead to the principal\n * identified by the `with` field.\n */\nexport const revoke = capability({\n    can: 'ucan/revoke',\n    /**\n     * DID of the principal authorizing revocation.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * UCAN being revoked from all proof chains that lead to the UCAN that is\n         * either issued (iss) by or delegated to (aud) the principal identified\n         * by the `with` field.\n         */\n        ucan: UCANLink,\n        /**\n         * Proof chain illustrating the path from revoked UCAN to the one that is\n         * either issued (iss) by or delegated to (aud) the principal identified\n         * by the `with` field.\n         *\n         * If the UCAN being revoked is either issued (iss) by or delegated to (aud)\n         * the principal identified by the `with` field no `proof` is required and\n         * it can be omitted or set to an empty array.\n         *\n         * It is RECOMMENDED that `proof` is provided in all other cases otherwise\n         * it MAY not be possible to verify that revoking principal is a participant\n         * in the proof chain.\n         */\n        proof: UCANLink.array().optional(),\n    }),\n    derives: (claim, from) => \n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n        // UCAN being revoked MUST be the same\n        and(checkLink(claim.nb.ucan, from.nb.ucan, 'nb.ucan')) ??\n        // And proof chain MUST be the same\n        equal((claim.nb.proof ?? []).join('/'), (from.nb.proof ?? []).join('/'), 'nb.proof'),\n});\n/**\n * `ucan/conclude` capability represents a receipt using a special UCAN capability.\n *\n * The UCAN invocation specification defines receipt record, that is cryptographically\n * signed description of the invocation output and requested effects. Receipt\n * structure is very similar to UCAN except it has no notion of expiry nor it is\n * possible to delegate ability to issue receipt to another principal.\n */\nexport const conclude = capability({\n    can: 'ucan/conclude',\n    /**\n     * DID of the principal representing the Conclusion Authority.\n     * MUST be the DID of the audience of the ran invocation.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content with the Receipt.\n         */\n        receipt: Schema.link(),\n    }),\n    derives: (claim, from) => \n    // With field MUST be the same\n    and(equalWith(claim, from)) ||\n        and(checkLink(claim.nb.receipt, from.nb.receipt, 'nb.receipt')) ||\n        ok({}),\n});\n/**\n * Issued by trusted authority (usually the one handling invocation) that attest\n * that specific UCAN delegation has been considered authentic.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-session.md#authorization-session\n *\n * @example\n * ```js\n * {\n    iss: \"did:web:storacha.network\",\n    aud: \"did:key:z6Mkk89bC3JrVqKie71YEcc5M1SMVxuCgNx6zLZ8SYJsxALi\",\n    att: [{\n      \"with\": \"did:web:storacha.network\",\n      \"can\": \"ucan/attest\",\n      \"nb\": {\n        \"proof\": {\n          \"/\": \"bafyreifer23oxeyamllbmrfkkyvcqpujevuediffrpvrxmgn736f4fffui\"\n        }\n      }\n    }],\n    exp: null\n    sig: \"...\"\n  }\n * ```\n */\nexport const attest = capability({\n    can: 'ucan/attest',\n    // Should be storacha.network DID\n    with: Schema.did(),\n    nb: Schema.struct({\n        // UCAN delegation that is being attested.\n        proof: Schema.link({ version: 1 }),\n    }),\n    derives: (claim, from) => \n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n        // UCAN link MUST be the same\n        checkLink(claim.nb.proof, from.nb.proof, 'nb.proof'),\n});\n//# sourceMappingURL=ucan.js.map", "import * as Access from '@storacha/capabilities/access';\nimport * as API from './types.js';\nimport { Failure, fail, DID } from '@ucanto/core';\nimport { Agent, importAuthorization } from './agent.js';\nimport { bytesToDelegations } from './encoding.js';\n/**\n * Takes array of delegations and propagates them to their respective audiences\n * through a given space (or the current space if none is provided).\n *\n * Returns error result if agent has no current space and no space was provided.\n * Also returns error result if invocation fails.\n *\n * @param {Agent} agent - Agent connected to the w3up service.\n * @param {object} input\n * @param {API.Delegation[]} input.delegations - Delegations to propagate.\n * @param {API.SpaceDID} [input.space] - Space to propagate through.\n * @param {API.Delegation[]} [input.proofs] - Optional set of proofs to be\n * included in the invocation.\n */\nexport const delegate = async (agent, { delegations, proofs = [], space = agent.currentSpace() }) => {\n    if (!space) {\n        return fail('Space must be specified');\n    }\n    const entries = Object.values(delegations).map((proof) => [\n        proof.cid.toString(),\n        proof.cid,\n    ]);\n    const { out } = await agent.invokeAndExecute(Access.delegate, {\n        with: space,\n        nb: {\n            delegations: Object.fromEntries(entries),\n        },\n        // must be embedded here because it's referenced by cid in .nb.delegations\n        proofs: [...delegations, ...proofs],\n    });\n    return out;\n};\n/**\n * Requests specified `access` level from specified `account`. It invokes\n * `access/authorize` capability, if invocation succeeds it will return a\n * `PendingAccessRequest` object that can be used to poll for the requested\n * delegation through `access/claim` capability.\n *\n * @param {API.Agent} agent\n * @param {object} input\n * @param {API.AccountDID} input.account - Account from which access is requested.\n * @param {API.ProviderDID} [input.provider] - Provider that will receive the invocation.\n * @param {API.DID} [input.audience] - Principal requesting an access.\n * @param {API.Access} [input.access] - Access been requested.\n * @param {API.AppName} [input.appName] - App name for the access request\n * @param {API.SSORequestParams} [input.sso] - SSO authentication request (all fields required if provided)\n * @returns {Promise<API.Result<PendingAccessRequest, API.AccessAuthorizeFailure|API.InvocationError>>}\n */\nexport const request = async (agent, { account, provider = /** @type {API.ProviderDID} */ (agent.connection.id.did()), audience: audience = agent.did(), access = spaceAccess, appName, sso, }) => {\n    // Build facts array with appName and SSO object\n    const facts = [];\n    if (appName) {\n        facts.push({ appName });\n    }\n    if (sso) {\n        if (typeof sso !== 'object') {\n            return fail('SSO parameter must be an object');\n        }\n        if (!sso.authProvider || typeof sso.authProvider !== 'string') {\n            return fail('SSO authProvider must be a non-empty string');\n        }\n        if (!sso.externalUserId || typeof sso.externalUserId !== 'string') {\n            return fail('SSO externalUserId must be a non-empty string');\n        }\n        if (!sso.externalSessionToken ||\n            typeof sso.externalSessionToken !== 'string') {\n            return fail('SSO externalSessionToken must be a non-empty string');\n        }\n        facts.push({\n            sso: {\n                authProvider: sso.authProvider,\n                externalUserId: sso.externalUserId,\n                externalSessionToken: sso.externalSessionToken,\n            },\n        });\n    }\n    // Request access from the account.\n    const { out: result } = await agent.invokeAndExecute(Access.authorize, {\n        audience: DID.parse(provider),\n        with: audience,\n        nb: {\n            iss: account,\n            // New ucan spec moved to recap style layout for capabilities and new\n            // `access/request` will use similar format as opposed to legacy one,\n            // in the meantime we translate new format to legacy format here.\n            att: [...toCapabilities(access)],\n        },\n        facts,\n    });\n    return result.error\n        ? result\n        : {\n            ok: new PendingAccessRequest({\n                ...result.ok,\n                agent,\n                audience,\n                provider,\n            }),\n        };\n};\n/**\n * Claims access that has been delegated to the given audience, which by\n * default is the agent's DID.\n *\n * @param {API.Agent} agent\n * @param {object} input\n * @param {API.DID} [input.audience] - Principal requesting an access.\n * @param {API.ProviderDID} [input.provider] - Provider handling the invocation.\n * @returns {Promise<API.Result<GrantedAccess, API.AccessClaimFailure|API.InvocationError>>}\n */\nexport const claim = async (agent, { provider = /** @type {API.ProviderDID} */ (agent.connection.id.did()), audience = agent.did(), } = {}) => {\n    const { out: result } = await agent.invokeAndExecute(Access.claim, {\n        audience: DID.parse(provider),\n        with: audience,\n    });\n    if (result.error) {\n        return result;\n    }\n    else {\n        const delegations = Object.values(result.ok.delegations);\n        const proofs = /** @type {API.Tuple<API.Delegation>} */ (delegations.flatMap((proof) => bytesToDelegations(proof)));\n        return { ok: new GrantedAccess({ agent, proofs }) };\n    }\n};\n/**\n * Creates a new `PendingAccessRequest` object that can be used to poll for the\n * requested delegation through `access/claim` capability.\n *\n * @param {API.Agent} agent\n * @param {object} input\n * @param {API.Link} input.request - Link to the `access/authorize` invocation.\n * @param {API.UTCUnixTimestamp} input.expiration - Seconds in UTC.\n * @param {API.DID} [input.audience] - Principal requesting an access.\n * @param {API.ProviderDID} [input.provider] - Provider handling request.\n */\nexport const createPendingAccessRequest = (agent, { request, expiration, provider = /** @type {API.ProviderDID} */ (agent.connection.id.did()), audience: audience = agent.did(), }) => new PendingAccessRequest({ agent, request, expiration, provider, audience });\n/**\n * Represents a pending access request. It can be used to poll for the requested\n * delegation.\n */\nclass PendingAccessRequest {\n    /**\n     * @typedef {object} PendingAccessRequestModel\n     * @property {API.Agent} agent - Agent handling interaction.\n     * @property {API.DID} audience - Principal requesting an access.\n     * @property {API.ProviderDID} provider - Provider handling request.\n     * @property {API.UTCUnixTimestamp} expiration - Seconds in UTC.\n     * @property {API.Link} request - Link to the `access/authorize` invocation.\n     *\n     * @param {PendingAccessRequestModel} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    get agent() {\n        return this.model.agent;\n    }\n    get audience() {\n        return this.model.audience;\n    }\n    get expiration() {\n        return new Date(this.model.expiration * 1000);\n    }\n    get request() {\n        return this.model.request;\n    }\n    get provider() {\n        return this.model.provider;\n    }\n    /**\n     * Low level method and most likely you want to use `.claim` instead. This method will poll\n     * fetch delegations **just once** and will return proofs matching to this request. Please note\n     * that there may not be any matches in which case result will be `{ ok: [] }`.\n     *\n     * If you do want to continuously poll until request is approved or expired, you should use\n     * `.claim` method instead.\n     *\n     * @returns {Promise<API.Result<API.Delegation[], API.InvocationError|API.AccessClaimFailure|RequestExpired>>}\n     */\n    async poll() {\n        const { agent, audience, provider, expiration } = this.model;\n        const timeout = expiration * 1000 - Date.now();\n        if (timeout <= 0) {\n            return { error: new RequestExpired(this.model) };\n        }\n        else {\n            const result = await claim(agent, { audience, provider });\n            return result.error\n                ? result\n                : {\n                    ok: result.ok.proofs.filter((proof) => isRequestedAccess(proof, this.model)),\n                };\n        }\n    }\n    /**\n     * Continuously polls delegations until this request is approved or expired. Returns\n     * a `GrantedAccess` object (view over the delegations) that can be used in the\n     * invocations or can be saved in the agent (store) using `.save()` method.\n     *\n     * @param {object} options\n     * @param {number} [options.interval]\n     * @param {AbortSignal} [options.signal]\n     * @returns {Promise<API.Result<GrantedAccess, Error>>}\n     */\n    async claim({ signal, interval = 250 } = {}) {\n        while (signal?.aborted !== true) {\n            const result = await this.poll();\n            // If polling failed, return the error.\n            if (result.error) {\n                return result;\n            }\n            // If we got some matching proofs, return them.\n            else if (result.ok.length > 0) {\n                return {\n                    ok: new GrantedAccess({\n                        agent: this.agent,\n                        proofs: /** @type {API.Tuple<API.Delegation>} */ (result.ok),\n                    }),\n                };\n            }\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n        return {\n            error: Object.assign(new Error('Aborted'), { reason: signal.reason }),\n        };\n    }\n}\n/**\n * Error returned when pending access request expires.\n */\nclass RequestExpired extends Failure {\n    /**\n     * @param {PendingAccessRequestModel} model\n     */\n    constructor(model) {\n        super();\n        this.model = model;\n    }\n    get name() {\n        return 'RequestExpired';\n    }\n    get request() {\n        return this.model.request;\n    }\n    get expiredAt() {\n        return new Date(this.model.expiration * 1000);\n    }\n    describe() {\n        return `Access request expired at ${this.expiredAt} for ${this.request} request.`;\n    }\n}\n/**\n * View over the UCAN Delegations that grant access to a specific principal.\n */\nexport class GrantedAccess {\n    /**\n     * @typedef {object} GrantedAccessModel\n     * @property {API.Agent} agent - Agent that processed the request.\n     * @property {API.Tuple<API.Delegation>} proofs - Delegations that grant access.\n     *\n     * @param {GrantedAccessModel} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    get proofs() {\n        return this.model.proofs;\n    }\n    /**\n     * Saves access into the agents proofs store so that it can be retained\n     * between sessions.\n     *\n     * @param {object} input\n     * @param {API.Agent} [input.agent]\n     */\n    save({ agent = this.model.agent } = {}) {\n        return importAuthorization(agent, this);\n    }\n}\n/**\n * Checks if the given delegation is caused by the passed `request` for access.\n *\n * @param {API.Delegation} delegation\n * @param {object} selector\n * @param {API.Link} selector.request\n * @returns\n */\nconst isRequestedAccess = (delegation, { request }) => \n// `access/confirm` handler adds facts to the delegation issued by the account\n// so that principal requesting access can identify correct delegation when\n// access is granted.\ndelegation.facts.some((fact) => `${fact['access/request']}` === `${request}`);\n/**\n * Maps access object that uses UCAN 0.10 capabilities format as opposed\n * to legacy UCAN 0.9 format used by w3up  which predates new format.\n *\n * @param {API.Access} access\n * @returns {{ can: API.Ability }[]}\n */\nexport const toCapabilities = (access) => {\n    const abilities = [];\n    const entries = /** @type {[API.Ability, API.Unit][]} */ (Object.entries(access));\n    for (const [can, details] of entries) {\n        if (details) {\n            abilities.push({ can });\n        }\n    }\n    return abilities;\n};\n/**\n * Set of capabilities required by the agent to manage a space.\n */\nexport const spaceAccess = {\n    'space/*': {},\n    'blob/*': {},\n    'index/*': {},\n    'store/*': {},\n    'upload/*': {},\n    'access/*': {},\n    'filecoin/*': {},\n    'usage/*': {},\n};\n/**\n * Set of capabilities required for by the agent to manage an account.\n */\nexport const accountAccess = {\n    '*': {},\n};\n//# sourceMappingURL=access.js.map", "/**\n * Access Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Access from '@storacha/capabilities/access'\n * ```\n *\n * @module\n */\nimport { capability, URI, DID, Schema, fail, ok } from '@ucanto/validator';\nimport * as Types from '@ucanto/interface';\nimport { attest } from './ucan.js';\nimport { equalWith, equal, and, SpaceDID, checkLink } from './utils.js';\nexport { top } from './top.js';\n/**\n * @deprecated - Use `ucan.attest` instead.\n */\nexport const session = attest;\n/**\n * Account identifier.\n */\nexport const Account = DID.match({ method: 'mailto' });\n/**\n * Describes the capability requested.\n */\nexport const CapabilityRequest = Schema.struct({\n    /**\n     * If set to `\"*\"` it corresponds to \"sudo\" access.\n     */\n    can: Schema.string(),\n});\n/**\n * Authorization request describing set of desired capabilities.\n */\nexport const AuthorizationRequest = Schema.struct({\n    /**\n     * DID of the Account authorization is requested from.\n     */\n    iss: Account.optional(),\n    /**\n     * Capabilities agent wishes to be granted.\n     */\n    att: CapabilityRequest.array(),\n});\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `access/` prefixed capability for the agent identified\n * by did:key in the `with` field.\n */\nexport const access = capability({\n    can: 'access/*',\n    with: URI.match({ protocol: 'did:' }),\n});\n/**\n * Capability can be invoked by an agent to request set of capabilities from\n * the account.\n */\nexport const authorize = capability({\n    can: 'access/authorize',\n    with: DID.match({ method: 'key' }),\n    /**\n     * Authorization request describing set of desired capabilities\n     */\n    nb: AuthorizationRequest,\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.iss, parent.nb.iss, 'iss')) ||\n            and(subsetCapabilities(child.nb.att, parent.nb.att)) ||\n            ok({}));\n    },\n});\n/**\n * Capability is delegated by us to the user allowing them to complete the\n * authorization flow. It allows us to ensure that user clicks the link and\n * we don't have some rogue agent trying to impersonate user clicking the link\n * in order to get access to their account.\n */\nexport const confirm = capability({\n    can: 'access/confirm',\n    with: DID,\n    nb: Schema.struct({\n        /**\n         * Link to the `access/authorize` request that this delegation was created\n         * for.\n         */\n        cause: Schema.link({ version: 1 }),\n        iss: Account,\n        aud: Schema.did(),\n        att: CapabilityRequest.array(),\n    }),\n    derives: (claim, proof) => {\n        return (and(equalWith(claim, proof)) ||\n            and(equal(claim.nb.iss, proof.nb.iss, 'iss')) ||\n            and(equal(claim.nb.aud, proof.nb.aud, 'aud')) ||\n            and(subsetCapabilities(claim.nb.att, proof.nb.att)) ||\n            and(checkLink(claim.nb.cause, proof.nb.cause, 'nb.cause')) ||\n            ok({}));\n    },\n});\nexport const claim = capability({\n    can: 'access/claim',\n    with: DID.match({ method: 'key' }).or(DID.match({ method: 'mailto' })),\n});\n// https://github.com/storacha/specs/blob/main/w3-access.md#accessdelegate\nexport const delegate = capability({\n    can: 'access/delegate',\n    /**\n     * Field MUST be a space DID with a storage provider. Delegation will be stored just like any other DAG stored using store/add capability.\n     *\n     * @see https://github.com/storacha/specs/blob/main/w3-access.md#delegate-with\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        // keys SHOULD be CIDs, but we won't require it in the schema\n        /**\n         * @type {Schema.Schema<AccessDelegateDelegations>}\n         */\n        delegations: Schema.dictionary({\n            value: Schema.Link.match(),\n        }),\n    }),\n    derives: (claim, proof) => {\n        return (and(equalWith(claim, proof)) ||\n            and(subsetsNbDelegations(claim, proof)) ||\n            ok({}));\n    },\n});\n/**\n * @typedef {Schema.Dictionary<string, Types.Link<unknown, number, number, 0 | 1>>} AccessDelegateDelegations\n */\n/**\n * Parsed Capability for access/delegate\n *\n * @typedef {object} ParsedAccessDelegate\n * @property {string} can\n * @property {object} nb\n * @property {AccessDelegateDelegations} [nb.delegations]\n */\n/**\n * returns whether the claimed ucan is proves by the proof ucan.\n * both are access/delegate, or at least have same semantics for `nb.delegations`, which is a set of delegations.\n * checks that the claimed delegation set is equal to or less than the proven delegation set.\n * usable with {import('@ucanto/interface').Derives}.\n *\n * @param {ParsedAccessDelegate} claim\n * @param {ParsedAccessDelegate} proof\n */\nfunction subsetsNbDelegations(claim, proof) {\n    const missingProofs = setDifference(delegatedCids(claim), new Set(delegatedCids(proof)));\n    if (missingProofs.size > 0) {\n        return fail(`unauthorized nb.delegations ${[...missingProofs].join(', ')}`);\n    }\n    return ok({});\n}\n/**\n * Checks that set of requested capabilities is a subset of the capabilities\n * that had been allowed by the owner or the delegate.\n *\n *  This function does not currently check that say `store/add` is allowed\n * when say `store/*` was delegated, because it seems very unlikely that we\n * will ever encounter delegations for `access/authorize` at all.\n *\n * @param {Schema.Infer<CapabilityRequest>[]} claim\n * @param {Schema.Infer<CapabilityRequest>[]} proof\n */\nconst subsetCapabilities = (claim, proof) => {\n    const allowed = new Set(proof.map((p) => p.can));\n    // If everything is allowed, no need to check further because it contains\n    // all the capabilities.\n    if (allowed.has('*')) {\n        return ok({});\n    }\n    // Otherwise we compute delta between what is allowed and what is requested.\n    const escalated = setDifference(claim.map((c) => c.can), allowed);\n    if (escalated.size > 0) {\n        return fail(`unauthorized nb.att.can ${[...escalated].join(', ')}`);\n    }\n    return ok({});\n};\n/**\n * iterate delegated UCAN CIDs from an access/delegate capability.nb.delegations value.\n *\n * @param {ParsedAccessDelegate} delegate\n * @returns {Iterable<string>}\n */\nfunction* delegatedCids(delegate) {\n    for (const d of Object.values(delegate.nb.delegations || {})) {\n        yield d.toString();\n    }\n}\n/**\n * @template S\n * @param {Iterable<S>} minuend - set to subtract from\n * @param {Set<S>} subtrahend - subtracted from minuend\n */\nfunction setDifference(minuend, subtrahend) {\n    /** @type {Set<S>} */\n    const difference = new Set();\n    for (const e of minuend) {\n        if (!subtrahend.has(e)) {\n            difference.add(e);\n        }\n    }\n    return difference;\n}\n//# sourceMappingURL=access.js.map", "// export other types\nexport * from '@ucanto/interface';\nexport * from '@storacha/capabilities/types';\nexport * from './errors.js';\nexport * from '@storacha/did-mailto';\nexport var AppName;\n(function (AppName) {\n    AppName[\"BskyBackups\"] = \"bsky-backups\";\n    AppName[\"TGMiniapp\"] = \"tg-miniapp\";\n    AppName[\"Console\"] = \"console\";\n})(AppName || (AppName = {}));\n//# sourceMappingURL=types.js.map", "export * from './types.js';\n/**\n * create a did:mailto from an email address\n *\n * @param {import(\"./types.js\").EmailAddress} email\n * @returns {import(\"./types.js\").DidMailto}\n */\nexport function fromEmail(email) {\n    const { domain, local } = parseEmail(email);\n    const did = /** @type {const} */ (`did:mailto:${encodeURIComponent(domain)}:${encodeURIComponent(local)}`);\n    return did;\n}\n/**\n * @param {import(\"./types.js\").DidMailto} did\n * @returns {import(\"./types.js\").EmailAddress}\n */\nexport function toEmail(did) {\n    const parts = did.split(':');\n    if (parts[1] !== 'mailto') {\n        throw new Error(`DID ${did} is not a mailto did.`);\n    }\n    return `${decodeURIComponent(parts[3])}@${decodeURIComponent(parts[2])}`;\n}\n/**\n * given a string, if it is an EmailAddress, return it, otherwise throw an error.\n * Use this to parse string input to `EmailAddress` type to pass to `fromEmail` (when needed).\n * This is not meant to be a general RFC5322 (et al) email address validator, which would be more expensive.\n *\n * @param {string} input\n * @returns {import(\"./types.js\").EmailAddress}\n */\nexport function email(input) {\n    const { domain, local } = parseEmail(input);\n    /** @type {import(\"./types.js\").EmailAddress} */\n    const emailAddress = `${local}@${domain}`;\n    return emailAddress;\n}\n/**\n * parse a did mailto from a string\n *\n * @param {string} input\n * @returns {import(\"./types.js\").DidMailto}\n */\nexport function fromString(input) {\n    const colonParts = input.split(':');\n    if (colonParts.length !== 4) {\n        throw new TypeError(`expected did:mailto to have 4 colon-delimited segments, but got ${colonParts.length}`);\n    }\n    const [domain, local] = [colonParts[2], colonParts[3]];\n    return `did:mailto:${domain}:${local}`;\n}\n/**\n * @param {string} email\n */\nfunction parseEmail(email) {\n    const atParts = email.split('@');\n    if (atParts.length < 2) {\n        throw new TypeError(`expected at least 2 @-delimited segments, but got ${atParts.length}`);\n    }\n    const domain = atParts.at(-1) ?? '';\n    const local = atParts.slice(0, -1).join('@');\n    return { domain, local };\n}\n//# sourceMappingURL=index.js.map", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "/**\n * To guarantee Uint8Array semantics, convert nodejs Buffers\n * into vanilla Uint8Arrays\n */\nexport function asUint8Array (buf: Uint8Array): Uint8Array {\n  return buf\n}\n", "/**\n * Can be used with Array.sort to sort and array with Uint8Array entries\n */\nexport function compare (a: Uint8Array, b: Uint8Array): number {\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] < b[i]) {\n      return -1\n    }\n\n    if (a[i] > b[i]) {\n      return 1\n    }\n  }\n\n  if (a.byteLength > b.byteLength) {\n    return 1\n  }\n\n  if (a.byteLength < b.byteLength) {\n    return -1\n  }\n\n  return 0\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "/**\n * Encoding utilities\n *\n * It is recommended that you import directly with:\n * ```js\n * import * as Encoding from '@storacha/access/encoding'\n *\n * // or\n *\n * import { encodeDelegations } from '@storacha/access/encoding'\n * ```\n *\n * @module\n */\nimport { CarBufferReader } from '@ipld/car/buffer-reader';\nimport * as CarBufferWriter from '@ipld/car/buffer-writer';\nimport { Delegation } from '@ucanto/core/delegation';\nimport * as u8 from 'uint8arrays';\n// eslint-disable-next-line no-unused-vars\nimport * as Types from '@ucanto/interface';\n/**\n * Encode delegations as bytes\n *\n * @param {Types.Delegation[]} delegations\n */\nexport function delegationsToBytes(delegations) {\n    if (!Array.isArray(delegations) || delegations.length === 0) {\n        throw new Error('Delegations required to be an non empty array.');\n    }\n    const roots = delegations.map((d) => /** @type {CarBufferWriter.CID} */ (d.root.cid));\n    const cids = new Set();\n    /** @type {CarBufferWriter.Block[]} */\n    const blocks = [];\n    let byteLength = 0;\n    for (const delegation of delegations) {\n        for (const block of delegation.export()) {\n            const cid = block.cid.toV1().toString();\n            if (!cids.has(cid)) {\n                byteLength += CarBufferWriter.blockLength(\n                /** @type {CarBufferWriter.Block} */ (block));\n                blocks.push(/** @type {CarBufferWriter.Block} */ (block));\n                cids.add(cid);\n            }\n        }\n    }\n    const headerLength = CarBufferWriter.estimateHeaderLength(roots.length);\n    const writer = CarBufferWriter.createWriter(new ArrayBuffer(headerLength + byteLength), { roots });\n    for (const block of blocks) {\n        writer.write(block);\n    }\n    return writer.close();\n}\n/**\n * Decode bytes into Delegations\n *\n * @template {Types.Capabilities} [T=Types.Capabilities]\n * @param {import('./types.js').BytesDelegation<T>} bytes\n */\nexport function bytesToDelegations(bytes) {\n    if (!(bytes instanceof Uint8Array) || bytes.length === 0) {\n        throw new TypeError('Input should be a non-empty Uint8Array.');\n    }\n    const reader = CarBufferReader.fromBytes(bytes);\n    const roots = reader.getRoots();\n    /** @type {Types.Delegation<T>[]} */\n    const delegations = [];\n    for (const root of roots) {\n        const rootBlock = reader.get(root);\n        if (rootBlock) {\n            const blocks = new Map();\n            for (const block of reader.blocks()) {\n                if (block.cid.toString() !== root.toString())\n                    blocks.set(block.cid.toString(), block);\n            }\n            // @ts-ignore\n            delegations.push(new Delegation(rootBlock, blocks));\n        }\n        else {\n            throw new Error('Failed to find root from raw delegation.');\n        }\n    }\n    return delegations;\n}\n/**\n * @param {Types.Delegation[]} delegations\n * @param {import('uint8arrays/to-string').SupportedEncodings} encoding\n */\nexport function delegationsToString(delegations, encoding = 'base64url') {\n    const bytes = delegationsToBytes(delegations);\n    return u8.toString(bytes, encoding);\n}\n/**\n * Encode one {@link Types.Delegation Delegation} into a string\n *\n * @param {Types.Delegation<Types.Capabilities>} delegation\n * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding]\n */\nexport function delegationToString(delegation, encoding) {\n    return delegationsToString([delegation], encoding);\n}\n/**\n * Decode string into {@link Types.Delegation Delegation}\n *\n * @template {Types.Capabilities} [T=Types.Capabilities]\n * @param {import('./types.js').EncodedDelegation<T>} raw\n * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding]\n */\nexport function stringToDelegations(raw, encoding = 'base64url') {\n    const bytes = u8.fromString(raw, encoding);\n    return bytesToDelegations(bytes);\n}\n/**\n * Decode string into a {@link Types.Delegation Delegation}\n *\n * @template {Types.Capabilities} [T=Types.Capabilities]\n * @param {import('./types.js').EncodedDelegation<T>} raw\n * @param {import('uint8arrays/to-string').SupportedEncodings} [encoding]\n */\nexport function stringToDelegation(raw, encoding) {\n    const delegations = stringToDelegations(raw, encoding);\n    return /** @type {Types.Delegation<T>} */ (delegations[0]);\n}\n/**\n * @param {number} [expiration]\n */\nexport function expirationToDate(expiration) {\n    const expires = expiration === Infinity || !expiration\n        ? undefined\n        : new Date(expiration * 1000);\n    return expires;\n}\n//# sourceMappingURL=encoding.js.map", "import * as ED25519 from '@ucanto/principal/ed25519';\nimport { delegate, Schema, UCAN, error, fail, DID } from '@ucanto/core';\nimport * as BIP39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nimport * as API from './types.js';\nimport * as Access from './access.js';\nimport * as Provider from './provider.js';\nimport { SpaceAccess } from './space-access.js';\n/**\n * Data model for the (owned) space.\n *\n * @typedef {{\n *  signer: ED25519.EdSigner;\n *   name: string;\n *   access?: API.SpaceAccessType;\n *   agent?: API.Agent<S>;\n * }} Model\n * @template {Record<string, any>} [S=API.Service]\n */\n/**\n * Generates a new space.\n *\n * @template {Record<string, any>} [S=API.Service]\n * @param {object} options\n * @param {string} options.name - The name of the space.\n * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.\n * @param {API.Agent<S>} [options.agent]\n */\nexport const generate = async ({ name, access, agent }) => {\n    const { signer } = await ED25519.generate();\n    const normalizedAccess = SpaceAccess.from(access);\n    return new OwnedSpace({ signer, name, access: normalizedAccess, agent });\n};\n/**\n * Recovers space from the saved mnemonic.\n *\n * @param {string} mnemonic\n * @param {object} options\n * @param {string} options.name - Name to give to the recovered space.\n * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.\n * @param {API.Agent} [options.agent]\n */\nexport const fromMnemonic = async (mnemonic, { name, access, agent }) => {\n    // TODO: Improve recovery UX by auto-detecting access type from existing space metadata\n    // or storing access type with space mnemonic. Should default to public if mnemonic\n    // doesn't contain access type information.\n    const secret = BIP39.mnemonicToEntropy(mnemonic, wordlist);\n    const signer = await ED25519.derive(secret);\n    const normalizedAccess = SpaceAccess.from(access);\n    return new OwnedSpace({ signer, name, access: normalizedAccess, agent });\n};\n/**\n * Turns (owned) space into a BIP39 mnemonic that later can be used to recover\n * the space using `fromMnemonic` function.\n *\n * @param {object} space\n * @param {ED25519.EdSigner} space.signer\n */\nexport const toMnemonic = ({ signer }) => {\n    /** @type {Uint8Array} */\n    // @ts-expect-error - Field is defined but not in the interface\n    const secret = signer.secret;\n    return BIP39.entropyToMnemonic(secret, wordlist);\n};\n/**\n * Creates a (UCAN) delegation that gives full access to the space to the\n * specified `account`. At the moment we only allow `did:mailto` principal\n * to be used as an `account`.\n *\n * @template {Record<string, any>} [S=API.Service]\n * @param {Model<S>} space\n * @param {API.AccountDID} account\n */\nexport const createRecovery = (space, account) => createAuthorization(space, {\n    audience: DID.parse(account),\n    access: Access.accountAccess,\n    expiration: Infinity,\n});\n// Default authorization session is valid for 1 year\nexport const SESSION_LIFETIME = 60 * 60 * 24 * 365;\n/**\n * Creates (UCAN) delegation that gives specified `agent` an access to\n * specified ability (passed as `access.can` field) on this space.\n * Optionally, you can specify `access.expiration` field to set the\n * expiration time for the authorization. By default the authorization\n * is valid for 1 year and gives access to all capabilities on the space\n * that are needed to use the space.\n *\n * @template {Record<string, any>} [S=API.Service]\n * @param {Model<S>} space\n * @param {object} options\n * @param {API.Principal} options.audience\n * @param {API.Access} [options.access]\n * @param {API.UTCUnixTimestamp} [options.expiration]\n */\nexport const createAuthorization = async ({ signer, name, access }, { audience, access: spaceAccess = Access.spaceAccess, expiration = UCAN.now() + SESSION_LIFETIME, }) => {\n    const normalizedAccess = SpaceAccess.from(access);\n    const facts = [{ space: { name, access: normalizedAccess } }];\n    return await delegate({\n        issuer: signer,\n        audience: audience,\n        capabilities: toCapabilities({\n            [signer.did()]: spaceAccess,\n        }),\n        ...(expiration ? { expiration } : {}),\n        facts,\n    });\n};\n/**\n * @param {Record<API.Resource, API.Access>} allow\n * @returns {API.Capabilities}\n */\nconst toCapabilities = (allow) => {\n    const capabilities = [];\n    for (const [subject, access] of Object.entries(allow)) {\n        const entries = /** @type {[API.Ability, API.Unit][]} */ (Object.entries(access));\n        for (const [can, details] of entries) {\n            if (details) {\n                capabilities.push({ can, with: subject });\n            }\n        }\n    }\n    return /** @type {API.Capabilities} */ (capabilities);\n};\n/**\n * Represents an owned space, meaning a space for which we have a private key\n * and consequently have full authority over.\n *\n * @template {Record<string, any>} [S=API.Service]\n */\nexport class OwnedSpace {\n    /**\n     * @param {Model<S>} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    get signer() {\n        return this.model.signer;\n    }\n    get name() {\n        return this.model.name;\n    }\n    get access() {\n        return SpaceAccess.from(this.model.access);\n    }\n    did() {\n        return this.signer.did();\n    }\n    /**\n     * Creates a renamed version of this space.\n     *\n     * @param {string} name\n     */\n    withName(name) {\n        return new OwnedSpace({\n            signer: this.signer,\n            name,\n            access: this.access,\n        });\n    }\n    /**\n     * Saves account in the agent store so it can be accessed across sessions.\n     *\n     * @param {object} input\n     * @param {API.Agent<S>} [input.agent]\n     * @returns {Promise<API.Result<API.Unit, Error>>}\n     */\n    async save({ agent = this.model.agent } = {}) {\n        if (!agent) {\n            return fail('Please provide an agent to save the space into');\n        }\n        const proof = await createAuthorization(this, { audience: agent });\n        await agent.importSpaceFromDelegation(proof);\n        await agent.setCurrentSpace(this.did());\n        return { ok: {} };\n    }\n    /**\n     * @param {Authorization} authorization\n     * @param {object} options\n     * @param {API.Agent<S>} [options.agent]\n     */\n    provision({ proofs }, { agent = this.model.agent } = {}) {\n        if (!agent) {\n            return fail('Please provide an agent to save the space into');\n        }\n        return provision(this, { proofs, agent });\n    }\n    /**\n     * Creates a (UCAN) delegation that gives full access to the space to the\n     * specified `account`. At the moment we only allow `did:mailto` principal\n     * to be used as an `account`.\n     *\n     * @param {API.AccountDID} account\n     */\n    async createRecovery(account) {\n        return createRecovery(this, account);\n    }\n    /**\n     * Creates (UCAN) delegation that gives specified `agent` an access to\n     * specified ability (passed as `access.can` field) on the this space.\n     * Optionally, you can specify `access.expiration` field to set the\n     *\n     * @param {API.Principal} principal\n     * @param {object} [input]\n     * @param {API.Access} [input.access]\n     * @param {API.UCAN.UTCUnixTimestamp} [input.expiration]\n     */\n    createAuthorization(principal, input) {\n        return createAuthorization(this, { ...input, audience: principal });\n    }\n    /**\n     * Derives BIP39 mnemonic that can be used to recover the space.\n     *\n     * @returns {string}\n     */\n    toMnemonic() {\n        return toMnemonic(this);\n    }\n}\nconst SpaceDID = Schema.did({ method: 'key' });\n/**\n * Creates a (shared) space from given delegation.\n *\n * @param {API.Delegation} delegation\n */\nexport const fromDelegation = (delegation) => {\n    const result = SpaceDID.read(delegation.capabilities[0].with);\n    if (result.error) {\n        throw Object.assign(new Error(`Invalid delegation, expected capabilities[0].with to be DID, ${result.error}`), {\n            cause: result.error,\n        });\n    }\n    /** @type {{name?:string, access?:API.SpaceAccessType}} */\n    const meta = delegation.facts[0]?.space ?? {};\n    // Ensure access defaults to public for backwards compatibility\n    meta.access = SpaceAccess.from(meta.access);\n    return new SharedSpace({ id: result.ok, delegation, meta });\n};\n/**\n * @typedef {object} Authorization\n * @property {API.Delegation[]} proofs\n *\n * @typedef {object} Space\n * @property {() => API.SpaceDID} did\n */\n/**\n * @template {Record<string, any>} [S=API.Service]\n * @param {Space} space\n * @param {object} options\n * @param {API.Delegation[]} options.proofs\n * @param {API.Agent<S>} options.agent\n */\nexport const provision = async (space, { proofs, agent }) => {\n    const [capability] = proofs[0].capabilities;\n    const { ok: account, error: reason } = Provider.AccountDID.read(capability.with);\n    if (reason) {\n        return error(reason);\n    }\n    return await Provider.add(agent, {\n        consumer: space.did(),\n        account,\n        proofs,\n    });\n};\n/**\n * Represents a shared space, meaning a space for which we have a delegation\n * and consequently have limited authority over.\n */\nexport class SharedSpace {\n    /**\n     * @typedef {object} SharedSpaceModel\n     * @property {API.SpaceDID} id\n     * @property {API.Delegation} delegation\n     * @property {{name?:string, access?:API.SpaceAccessType}} meta\n     * @property {API.Agent} [agent]\n     *\n     * @param {SharedSpaceModel} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    get delegation() {\n        return this.model.delegation;\n    }\n    get meta() {\n        return this.model.meta;\n    }\n    get name() {\n        return this.meta.name ?? '';\n    }\n    get access() {\n        return SpaceAccess.from(this.meta.access);\n    }\n    did() {\n        return this.model.id;\n    }\n    /**\n     * @param {string} name\n     */\n    withName(name) {\n        return new SharedSpace({\n            ...this.model,\n            meta: { ...this.meta, name, access: this.access },\n        });\n    }\n}\n//# sourceMappingURL=space.js.map", "export * from './ed25519/signer.js'\nexport * as Verifier from './ed25519/verifier.js'\nexport * as Signer from './ed25519/signer.js'\n", "import * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Verifier from './verifier.js'\nimport { base64pad } from 'multiformats/bases/base64'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as Signer from '../signer.js'\nexport * from './type.js'\n\nexport const code = 0x1300\nexport const name = Verifier.name\n\n/** @type {'EdDSA'} */\nexport const signatureAlgorithm = Verifier.signatureAlgorithm\nexport const signatureCode = Verifier.signatureCode\n\nconst PRIVATE_TAG_SIZE = varint.encodingLength(code)\nconst PUBLIC_TAG_SIZE = varint.encodingLength(Verifier.code)\nconst KEY_SIZE = 32\nconst SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE\n\nexport const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE\n\n/**\n * Generates new issuer by generating underlying ED25519 keypair.\n * @returns {Promise<API.EdSigner>}\n */\nexport const generate = () => derive(ED25519.utils.randomPrivateKey())\n\n/**\n * Derives issuer from 32 byte long secret key.\n * @param {Uint8Array} secret\n * @returns {Promise<API.EdSigner>}\n */\nexport const derive = async secret => {\n  if (secret.byteLength !== KEY_SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`\n    )\n  }\n\n  const publicKey = await ED25519.getPublicKey(secret)\n  const signer = new Ed25519Signer(SIZE)\n\n  varint.encodeTo(code, signer, 0)\n  signer.set(secret, PRIVATE_TAG_SIZE)\n\n  varint.encodeTo(Verifier.code, signer, PRIVATE_TAG_SIZE + KEY_SIZE)\n  signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE)\n\n  return signer\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.EdSigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const key = keys[/** @type {API.DIDKey} */ (id)]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    }\n  }\n  throw new TypeError(`Unsupported archive format`)\n}\n\n/**\n * @template {API.SignerImporter} O\n * @param {O} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.EdSigner}\n */\nexport const decode = bytes => {\n  if (bytes.byteLength !== SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`\n    )\n  }\n\n  {\n    const [keyCode] = varint.decode(bytes)\n    if (keyCode !== code) {\n      throw new Error(`Given bytes must be a multiformat with ${code} tag`)\n    }\n  }\n\n  {\n    const [code] = varint.decode(bytes.subarray(PUB_KEY_OFFSET))\n    if (code !== Verifier.code) {\n      throw new Error(\n        `Given bytes must contain public key in multiformats with ${Verifier.code} tag`\n      )\n    }\n  }\n\n  return new Ed25519Signer(bytes)\n}\n\n/**\n * @param {API.EdSigner} signer\n * @return {API.ByteView<API.EdSigner & CryptoKeyPair>}\n */\nexport const encode = signer => signer.encode()\n\n/**\n * @template {string} Prefix\n * @param {API.EdSigner} signer\n * @param {API.MultibaseEncoder<Prefix>} [encoder]\n */\nexport const format = (signer, encoder) =>\n  (encoder || base64pad).encode(encode(signer))\n\n/**\n * @template {string} Prefix\n * @param {string} principal\n * @param {API.MultibaseDecoder<Prefix>} [decoder]\n * @returns {API.EdSigner}\n */\nexport const parse = (principal, decoder) =>\n  decode((decoder || base64pad).decode(principal))\n\n/**\n * @implements {API.EdSigner}\n */\nclass Ed25519Signer extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  get signer() {\n    return this\n  }\n  /** @type {API.EdVerifier} */\n  get verifier() {\n    const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE)\n    const verifier = Verifier.decode(bytes)\n\n    Object.defineProperties(this, {\n      verifier: {\n        value: verifier,\n      },\n    })\n\n    return verifier\n  }\n\n  /**\n   * Raw public key without multiformat code.\n   */\n  get secret() {\n    const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE)\n    Object.defineProperties(this, {\n      secret: {\n        value: secret,\n      },\n    })\n\n    return secret\n  }\n\n  /**\n   * DID of this principal in `did:key` format.\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof Signature.EdDSA>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}\n   */\n  async sign(payload) {\n    const raw = await ED25519.sign(payload, this.secret)\n\n    return Signature.create(this.signatureCode, raw)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  get signatureCode() {\n    return Signature.EdDSA\n  }\n\n  encode() {\n    return this\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.encode() },\n    }\n  }\n}\n", "/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */\nimport * as nodeCrypto from 'crypto';\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _8n = BigInt(8);\nconst CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');\nconst CURVE = Object.freeze({\n    a: BigInt(-1),\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),\n    l: CU_O,\n    n: CU_O,\n    h: BigInt(8),\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n});\nexport { CURVE };\nconst POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');\nconst SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\nconst SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\nclass ExtendedPoint {\n    constructor(x, y, z, t) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.t = t;\n    }\n    static fromAffine(p) {\n        if (!(p instanceof Point)) {\n            throw new TypeError('ExtendedPoint#fromAffine: expected Point');\n        }\n        if (p.equals(Point.ZERO))\n            return ExtendedPoint.ZERO;\n        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));\n    }\n    static toAffineBatch(points) {\n        const toInv = invertBatch(points.map((p) => p.z));\n        return points.map((p, i) => p.toAffine(toInv[i]));\n    }\n    static normalizeZ(points) {\n        return this.toAffineBatch(points).map(this.fromAffine);\n    }\n    equals(other) {\n        assertExtPoint(other);\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { x: X2, y: Y2, z: Z2 } = other;\n        const X1Z2 = mod(X1 * Z2);\n        const X2Z1 = mod(X2 * Z1);\n        const Y1Z2 = mod(Y1 * Z2);\n        const Y2Z1 = mod(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    negate() {\n        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));\n    }\n    double() {\n        const { x: X1, y: Y1, z: Z1 } = this;\n        const { a } = CURVE;\n        const M = mod;\n        const A = M(X1 * X1);\n        const B = M(Y1 * Y1);\n        const C = M(_2n * M(Z1 * Z1));\n        const D = M(a * A);\n        const x1y1 = X1 + Y1;\n        const E = M(M(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    add(other) {\n        const { x: X1, y: Y1, z: Z1, t: T1 } = this;\n        assertExtPoint(other);\n        const { x: X2, y: Y2, z: Z2, t: T2 } = other;\n        const { a, d } = CURVE;\n        const M = mod;\n        const A = M(X1 * X2);\n        const B = M(Y1 * Y2);\n        const C = M(T1 * d * T2);\n        const D = M(Z1 * Z2);\n        const E = M((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = M(D - C);\n        const G = M(D + C);\n        const H = M(B - a * A);\n        const X3 = M(E * F);\n        const Y3 = M(G * H);\n        const T3 = M(E * H);\n        const Z3 = M(F * G);\n        return new ExtendedPoint(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    precomputeWindow(W) {\n        const windows = 1 + 256 / W;\n        const points = [];\n        let p = this;\n        let base = p;\n        for (let window = 0; window < windows; window++) {\n            base = p;\n            points.push(base);\n            for (let i = 1; i < 2 ** (W - 1); i++) {\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    wNAF(n, affinePoint) {\n        if (!affinePoint && this.equals(ExtendedPoint.BASE))\n            affinePoint = Point.BASE;\n        const W = (affinePoint && affinePoint._WINDOW_SIZE) || 1;\n        if (256 % W) {\n            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');\n        }\n        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);\n        if (!precomputes) {\n            precomputes = this.precomputeWindow(W);\n            if (affinePoint && W !== 1) {\n                precomputes = ExtendedPoint.normalizeZ(precomputes);\n                pointPrecomputes.set(affinePoint, precomputes);\n            }\n        }\n        let p = ExtendedPoint.ZERO;\n        let f = ExtendedPoint.BASE;\n        const windows = 1 + 256 / W;\n        const windowSize = 2 ** (W - 1);\n        const mask = BigInt(2 ** W - 1);\n        const maxNumber = 2 ** W;\n        const shiftBy = BigInt(W);\n        for (let window = 0; window < windows; window++) {\n            const offset = window * windowSize;\n            let wbits = Number(n & mask);\n            n >>= shiftBy;\n            if (wbits > windowSize) {\n                wbits -= maxNumber;\n                n += _1n;\n            }\n            const offset1 = offset;\n            const offset2 = offset + Math.abs(wbits) - 1;\n            const cond1 = window % 2 !== 0;\n            const cond2 = wbits < 0;\n            if (wbits === 0) {\n                f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n            }\n            else {\n                p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n            }\n        }\n        return ExtendedPoint.normalizeZ([p, f])[0];\n    }\n    multiply(scalar, affinePoint) {\n        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);\n    }\n    multiplyUnsafe(scalar) {\n        let n = normalizeScalar(scalar, CURVE.l, false);\n        const G = ExtendedPoint.BASE;\n        const P0 = ExtendedPoint.ZERO;\n        if (n === _0n)\n            return P0;\n        if (this.equals(P0) || n === _1n)\n            return this;\n        if (this.equals(G))\n            return this.wNAF(n);\n        let p = P0;\n        let d = this;\n        while (n > _0n) {\n            if (n & _1n)\n                p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    isSmallOrder() {\n        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n    }\n    isTorsionFree() {\n        let p = this.multiplyUnsafe(CURVE.l / _2n).double();\n        if (CURVE.l % _2n)\n            p = p.add(this);\n        return p.equals(ExtendedPoint.ZERO);\n    }\n    toAffine(invZ) {\n        const { x, y, z } = this;\n        const is0 = this.equals(ExtendedPoint.ZERO);\n        if (invZ == null)\n            invZ = is0 ? _8n : invert(z);\n        const ax = mod(x * invZ);\n        const ay = mod(y * invZ);\n        const zz = mod(z * invZ);\n        if (is0)\n            return Point.ZERO;\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return new Point(ax, ay);\n    }\n    fromRistrettoBytes() {\n        legacyRist();\n    }\n    toRistrettoBytes() {\n        legacyRist();\n    }\n    fromRistrettoHash() {\n        legacyRist();\n    }\n}\nExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));\nExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction assertExtPoint(other) {\n    if (!(other instanceof ExtendedPoint))\n        throw new TypeError('ExtendedPoint expected');\n}\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistrettoPoint))\n        throw new TypeError('RistrettoPoint expected');\n}\nfunction legacyRist() {\n    throw new Error('Legacy method: switch to RistrettoPoint');\n}\nclass RistrettoPoint {\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static calcElligatorRistrettoMap(r0) {\n        const { d } = CURVE;\n        const r = mod(SQRT_M1 * r0 * r0);\n        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);\n        let c = BigInt(-1);\n        const D = mod((c - d * r) * mod(r + d));\n        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n        let s_ = mod(s * r0);\n        if (!edIsNegative(s_))\n            s_ = mod(-s_);\n        if (!Ns_D_is_sq)\n            s = s_;\n        if (!Ns_D_is_sq)\n            c = r;\n        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);\n        const s2 = s * s;\n        const W0 = mod((s + s) * D);\n        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);\n        const W2 = mod(_1n - s2);\n        const W3 = mod(_1n + s2);\n        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n    }\n    static hashToCurve(hex) {\n        hex = ensureBytes(hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = this.calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = this.calcElligatorRistrettoMap(r2);\n        return new RistrettoPoint(R1.add(R2));\n    }\n    static fromHex(hex) {\n        hex = ensureBytes(hex, 32);\n        const { a, d } = CURVE;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2);\n        const u2 = mod(_1n - a * s2);\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2);\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2));\n        const Dx = mod(I * u2);\n        const Dy = mod(I * Dx * v);\n        let x = mod((s + s) * Dx);\n        if (edIsNegative(x))\n            x = mod(-x);\n        const y = mod(u1 * Dy);\n        const t = mod(x * y);\n        if (!isValid || edIsNegative(t) || y === _0n)\n            throw new Error(emsg);\n        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));\n    }\n    toRawBytes() {\n        let { x, y, z, t } = this.ep;\n        const u1 = mod(mod(z + y) * mod(z - y));\n        const u2 = mod(x * y);\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));\n        const D1 = mod(invsqrt * u1);\n        const D2 = mod(invsqrt * u2);\n        const zInv = mod(D1 * D2 * t);\n        let D;\n        if (edIsNegative(t * zInv)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2;\n        }\n        if (edIsNegative(x * zInv))\n            y = mod(-y);\n        let s = mod((z - y) * D);\n        if (edIsNegative(s))\n            s = mod(-s);\n        return numberTo32BytesLE(s);\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    equals(other) {\n        assertRstPoint(other);\n        const a = this.ep;\n        const b = other.ep;\n        const one = mod(a.x * b.y) === mod(a.y * b.x);\n        const two = mod(a.y * b.y) === mod(a.x * b.x);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistrettoPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistrettoPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nRistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);\nRistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);\nconst pointPrecomputes = new WeakMap();\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    _setWindowSize(windowSize) {\n        this._WINDOW_SIZE = windowSize;\n        pointPrecomputes.delete(this);\n    }\n    static fromHex(hex, strict = true) {\n        const { d, P } = CURVE;\n        hex = ensureBytes(hex, 32);\n        const normed = hex.slice();\n        normed[31] = hex[31] & ~0x80;\n        const y = bytesToNumberLE(normed);\n        if (strict && y >= P)\n            throw new Error('Expected 0 < hex < P');\n        if (!strict && y >= POW_2_256)\n            throw new Error('Expected 0 < hex < 2**256');\n        const y2 = mod(y * y);\n        const u = mod(y2 - _1n);\n        const v = mod(d * y2 + _1n);\n        let { isValid, value: x } = uvRatio(u, v);\n        if (!isValid)\n            throw new Error('Point.fromHex: invalid y coordinate');\n        const isXOdd = (x & _1n) === _1n;\n        const isLastByteOdd = (hex[31] & 0x80) !== 0;\n        if (isLastByteOdd !== isXOdd) {\n            x = mod(-x);\n        }\n        return new Point(x, y);\n    }\n    static async fromPrivateKey(privateKey) {\n        return (await getExtendedPublicKey(privateKey)).point;\n    }\n    toRawBytes() {\n        const bytes = numberTo32BytesLE(this.y);\n        bytes[31] |= this.x & _1n ? 0x80 : 0;\n        return bytes;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n    toX25519() {\n        const { y } = this;\n        const u = mod((_1n + y) * invert(_1n - y));\n        return numberTo32BytesLE(u);\n    }\n    isTorsionFree() {\n        return ExtendedPoint.fromAffine(this).isTorsionFree();\n    }\n    equals(other) {\n        return this.x === other.x && this.y === other.y;\n    }\n    negate() {\n        return new Point(mod(-this.x), this.y);\n    }\n    add(other) {\n        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();\n    }\n    subtract(other) {\n        return this.add(other.negate());\n    }\n    multiply(scalar) {\n        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();\n    }\n}\nPoint.BASE = new Point(CURVE.Gx, CURVE.Gy);\nPoint.ZERO = new Point(_0n, _1n);\nclass Signature {\n    constructor(r, s) {\n        this.r = r;\n        this.s = s;\n        this.assertValidity();\n    }\n    static fromHex(hex) {\n        const bytes = ensureBytes(hex, 64);\n        const r = Point.fromHex(bytes.slice(0, 32), false);\n        const s = bytesToNumberLE(bytes.slice(32, 64));\n        return new Signature(r, s);\n    }\n    assertValidity() {\n        const { r, s } = this;\n        if (!(r instanceof Point))\n            throw new Error('Expected Point instance');\n        normalizeScalar(s, CURVE.l, false);\n        return this;\n    }\n    toRawBytes() {\n        const u8 = new Uint8Array(64);\n        u8.set(this.r.toRawBytes());\n        u8.set(numberTo32BytesLE(this.s), 32);\n        return u8;\n    }\n    toHex() {\n        return bytesToHex(this.toRawBytes());\n    }\n}\nexport { ExtendedPoint, Point, RistrettoPoint, Signature };\nfunction isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nfunction concatBytes(...arrays) {\n    arrays.every(abytes);\n    if (arrays.length === 1)\n        return arrays[0];\n    const length = arrays.reduce((a, arr) => a + arr.length, 0);\n    const result = new Uint8Array(length);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const arr = arrays[i];\n        result.set(arr, pad);\n        pad += arr.length;\n    }\n    return result;\n}\nconst hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0;\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10);\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10);\n    return;\n}\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\nfunction numberTo32BytesBE(num) {\n    const length = 32;\n    const hex = num.toString(16).padStart(length * 2, '0');\n    return hexToBytes(hex);\n}\nfunction numberTo32BytesLE(num) {\n    return numberTo32BytesBE(num).reverse();\n}\nfunction edIsNegative(num) {\n    return (mod(num) & _1n) === _1n;\n}\nfunction bytesToNumberLE(uint8a) {\n    abytes(uint8a);\n    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));\n}\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nfunction bytes255ToNumberLE(bytes) {\n    return mod(bytesToNumberLE(bytes) & MAX_255B);\n}\nfunction mod(a, b = CURVE.P) {\n    const res = a % b;\n    return res >= _0n ? res : b + res;\n}\nfunction invert(number, modulo = CURVE.P) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    let a = mod(number, modulo);\n    let b = modulo;\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\nfunction invertBatch(nums, p = CURVE.P) {\n    const tmp = new Array(nums.length);\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = acc;\n        return mod(acc * num, p);\n    }, _1n);\n    const inverted = invert(lastMultiplied, p);\n    nums.reduceRight((acc, num, i) => {\n        if (num === _0n)\n            return acc;\n        tmp[i] = mod(acc * tmp[i], p);\n        return mod(acc * num, p);\n    }, inverted);\n    return tmp;\n}\nfunction pow2(x, power) {\n    const { P } = CURVE;\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= P;\n    }\n    return res;\n}\nfunction pow_2_252_3(x) {\n    const { P } = CURVE;\n    const _5n = BigInt(5);\n    const _10n = BigInt(10);\n    const _20n = BigInt(20);\n    const _40n = BigInt(40);\n    const _80n = BigInt(80);\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P;\n    const b4 = (pow2(b2, _2n) * b2) % P;\n    const b5 = (pow2(b4, _1n) * x) % P;\n    const b10 = (pow2(b5, _5n) * b5) % P;\n    const b20 = (pow2(b10, _10n) * b10) % P;\n    const b40 = (pow2(b20, _20n) * b20) % P;\n    const b80 = (pow2(b40, _40n) * b40) % P;\n    const b160 = (pow2(b80, _80n) * b80) % P;\n    const b240 = (pow2(b160, _80n) * b80) % P;\n    const b250 = (pow2(b240, _10n) * b10) % P;\n    const pow_p_5_8 = (pow2(b250, _2n) * x) % P;\n    return { pow_p_5_8, b2 };\n}\nfunction uvRatio(u, v) {\n    const v3 = mod(v * v * v);\n    const v7 = mod(v3 * v3 * v);\n    const pow = pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v3 * pow);\n    const vx2 = mod(v * x * x);\n    const root1 = x;\n    const root2 = mod(x * SQRT_M1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u);\n    const noRoot = vx2 === mod(-u * SQRT_M1);\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2;\n    if (edIsNegative(x))\n        x = mod(-x);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\nfunction invertSqrt(number) {\n    return uvRatio(_1n, number);\n}\nfunction modlLE(hash) {\n    return mod(bytesToNumberLE(hash), CURVE.l);\n}\nfunction equalBytes(b1, b2) {\n    if (b1.length !== b2.length) {\n        return false;\n    }\n    for (let i = 0; i < b1.length; i++) {\n        if (b1[i] !== b2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction ensureBytes(hex, expectedLength) {\n    const bytes = isBytes(hex) ? Uint8Array.from(hex) : hexToBytes(hex);\n    if (typeof expectedLength === 'number' && bytes.length !== expectedLength)\n        throw new Error(`Expected ${expectedLength} bytes`);\n    return bytes;\n}\nfunction normalizeScalar(num, max, strict = true) {\n    if (!max)\n        throw new TypeError('Specify max value');\n    if (typeof num === 'number' && Number.isSafeInteger(num))\n        num = BigInt(num);\n    if (typeof num === 'bigint' && num < max) {\n        if (strict) {\n            if (_0n < num)\n                return num;\n        }\n        else {\n            if (_0n <= num)\n                return num;\n        }\n    }\n    throw new TypeError('Expected valid scalar: 0 < scalar < max');\n}\nfunction adjustBytes25519(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n}\nfunction decodeScalar25519(n) {\n    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));\n}\nfunction checkPrivateKey(key) {\n    key =\n        typeof key === 'bigint' || typeof key === 'number'\n            ? numberTo32BytesBE(normalizeScalar(key, POW_2_256))\n            : ensureBytes(key);\n    if (key.length !== 32)\n        throw new Error(`Expected 32 bytes`);\n    return key;\n}\nfunction getKeyFromHash(hashed) {\n    const head = adjustBytes25519(hashed.slice(0, 32));\n    const prefix = hashed.slice(32, 64);\n    const scalar = modlLE(head);\n    const point = Point.BASE.multiply(scalar);\n    const pointBytes = point.toRawBytes();\n    return { head, prefix, scalar, point, pointBytes };\n}\nlet _sha512Sync;\nfunction sha512s(...m) {\n    if (typeof _sha512Sync !== 'function')\n        throw new Error('utils.sha512Sync must be set to use sync methods');\n    return _sha512Sync(...m);\n}\nasync function getExtendedPublicKey(key) {\n    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));\n}\nfunction getExtendedPublicKeySync(key) {\n    return getKeyFromHash(sha512s(checkPrivateKey(key)));\n}\nexport async function getPublicKey(privateKey) {\n    return (await getExtendedPublicKey(privateKey)).pointBytes;\n}\nfunction getPublicKeySync(privateKey) {\n    return getExtendedPublicKeySync(privateKey).pointBytes;\n}\nexport async function sign(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);\n    const r = modlLE(await utils.sha512(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction signSync(message, privateKey) {\n    message = ensureBytes(message);\n    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);\n    const r = modlLE(sha512s(prefix, message));\n    const R = Point.BASE.multiply(r);\n    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));\n    const s = mod(r + k * scalar, CURVE.l);\n    return new Signature(R, s).toRawBytes();\n}\nfunction prepareVerification(sig, message, publicKey) {\n    message = ensureBytes(message);\n    if (!(publicKey instanceof Point))\n        publicKey = Point.fromHex(publicKey, false);\n    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);\n    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);\n    return { r, s, SB, pub: publicKey, msg: message };\n}\nfunction finishVerification(publicKey, r, SB, hashed) {\n    const k = modlLE(hashed);\n    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);\n    const RkA = ExtendedPoint.fromAffine(r).add(kA);\n    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);\n}\nexport async function verify(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nfunction verifySync(sig, message, publicKey) {\n    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);\n    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);\n    return finishVerification(pub, r, SB, hashed);\n}\nexport const sync = {\n    getExtendedPublicKey: getExtendedPublicKeySync,\n    getPublicKey: getPublicKeySync,\n    sign: signSync,\n    verify: verifySync,\n};\nexport async function getSharedSecret(privateKey, publicKey) {\n    const { head } = await getExtendedPublicKey(privateKey);\n    const u = Point.fromHex(publicKey).toX25519();\n    return curve25519.scalarMult(head, u);\n}\nPoint.BASE._setWindowSize(8);\nfunction cswap(swap, x_2, x_3) {\n    const dummy = mod(swap * (x_2 - x_3));\n    x_2 = mod(x_2 - dummy);\n    x_3 = mod(x_3 + dummy);\n    return [x_2, x_3];\n}\nfunction montgomeryLadder(pointU, scalar) {\n    const { P } = CURVE;\n    const u = normalizeScalar(pointU, P);\n    const k = normalizeScalar(scalar, P);\n    const a24 = BigInt(121665);\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(255 - 1); t >= _0n; t--) {\n        const k_t = (k >> t) & _1n;\n        swap ^= k_t;\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        swap = k_t;\n        const A = x_2 + z_2;\n        const AA = mod(A * A);\n        const B = x_2 - z_2;\n        const BB = mod(B * B);\n        const E = AA - BB;\n        const C = x_3 + z_3;\n        const D = x_3 - z_3;\n        const DA = mod(D * A);\n        const CB = mod(C * B);\n        const dacb = DA + CB;\n        const da_cb = DA - CB;\n        x_3 = mod(dacb * dacb);\n        z_3 = mod(x_1 * mod(da_cb * da_cb));\n        x_2 = mod(AA * BB);\n        z_2 = mod(E * (AA + mod(a24 * E)));\n    }\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);\n    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);\n    return mod(x_2 * xp2);\n}\nfunction encodeUCoordinate(u) {\n    return numberTo32BytesLE(mod(u, CURVE.P));\n}\nfunction decodeUCoordinate(uEnc) {\n    const u = ensureBytes(uEnc, 32);\n    u[31] &= 127;\n    return bytesToNumberLE(u);\n}\nexport const curve25519 = {\n    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',\n    scalarMult(privateKey, publicKey) {\n        const u = decodeUCoordinate(publicKey);\n        const p = decodeScalar25519(privateKey);\n        const pu = montgomeryLadder(u, p);\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    },\n    scalarMultBase(privateKey) {\n        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);\n    },\n};\nconst crypto = {\n    node: nodeCrypto,\n    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined,\n};\nexport const utils = {\n    bytesToHex,\n    hexToBytes,\n    concatBytes,\n    getExtendedPublicKey,\n    mod,\n    invert,\n    TORSION_SUBGROUP: [\n        '0100000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n        '0000000000000000000000000000000000000000000000000000000000000080',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n        '0000000000000000000000000000000000000000000000000000000000000000',\n        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n    ],\n    hashToPrivateScalar: (hash) => {\n        hash = ensureBytes(hash);\n        if (hash.length < 40 || hash.length > 1024)\n            throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');\n        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;\n    },\n    randomBytes: (bytesLength = 32) => {\n        if (crypto.web) {\n            return crypto.web.getRandomValues(new Uint8Array(bytesLength));\n        }\n        else if (crypto.node) {\n            const { randomBytes } = crypto.node;\n            return new Uint8Array(randomBytes(bytesLength).buffer);\n        }\n        else {\n            throw new Error(\"The environment doesn't have randomBytes function\");\n        }\n    },\n    randomPrivateKey: () => {\n        return utils.randomBytes(32);\n    },\n    sha512: async (...messages) => {\n        const message = concatBytes(...messages);\n        if (crypto.web) {\n            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);\n            return new Uint8Array(buffer);\n        }\n        else if (crypto.node) {\n            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());\n        }\n        else {\n            throw new Error(\"The environment doesn't have sha512 function\");\n        }\n    },\n    precompute(windowSize = 8, point = Point.BASE) {\n        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);\n        cached._setWindowSize(windowSize);\n        cached.multiply(_2n);\n        return cached;\n    },\n    sha512Sync: undefined,\n};\nObject.defineProperties(utils, {\n    sha512Sync: {\n        configurable: false,\n        get() {\n            return _sha512Sync;\n        },\n        set(val) {\n            if (!_sha512Sync)\n                _sha512Sync = val;\n        },\n    },\n});\n", "import * as DID from '@ipld/dag-ucan/did'\nimport * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Verifier from '../verifier.js'\n\n/** @type {API.EdVerifier['code']} */\nexport const code = 0xed\nexport const name = 'Ed25519'\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.EdDSA\nexport const signatureAlgorithm = 'EdDSA'\nconst PUBLIC_TAG_SIZE = varint.encodingLength(code)\nconst SIZE = 32 + PUBLIC_TAG_SIZE\n\n/**\n * @typedef {API.EdVerifier} EdVerifier\n */\n\n/**\n * Parses `did:key:` string as a VerifyingPrincipal.\n *\n * @param {API.DID|string} did\n * @returns {API.Verifier<API.DID, typeof signatureCode>}\n */\nexport const parse = did => decode(DID.parse(did))\n\n/**\n * Takes ed25519 public key tagged with `0xed` multiformat code and creates a\n * corresponding `Principal` that can be used to verify signatures.\n *\n * @param {Uint8Array} bytes\n * @returns {API.EdVerifier}\n */\nexport const decode = bytes => {\n  const [algorithm] = varint.decode(bytes)\n  if (algorithm !== code) {\n    throw new RangeError(\n      `Unsupported key algorithm with multicode 0x${code.toString(16)}`\n    )\n  } else if (bytes.byteLength !== SIZE) {\n    throw new RangeError(\n      `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`\n    )\n  } else {\n    return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  }\n}\n\n/**\n * Formats given Principal into `did:key:` format.\n *\n * @param {API.Principal<API.DID>} principal\n */\nexport const format = principal => DID.format(principal)\n\n/**\n * Encodes given Principal by tagging it's ed25519 public key with `0xed`\n * multiformat code.\n *\n * @param {API.Principal<API.DID<\"key\">>} principal\n */\nexport const encode = principal => DID.encode(principal)\n\n/**\n * @implements {API.EdVerifier}\n */\nclass Ed25519Verifier extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  /** @type {typeof signatureCode} */\n  get signatureCode() {\n    return signatureCode\n  }\n  /** @type {typeof signatureAlgorithm} */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * Raw public key without a multiformat code.\n   *\n   * @readonly\n   */\n  get publicKey() {\n    const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE)\n    Object.defineProperties(this, {\n      publicKey: {\n        value: key,\n      },\n    })\n    return key\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Signature.EdDSA>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return (\n      signature.code === signatureCode &&\n      ED25519.verify(signature.raw, payload, this.publicKey)\n    )\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n}\n\n/**\n * @param {API.PrincipalParser} other\n */\nexport const or = other => Verifier.or({ parse }, other)\n", "import * as API from '@ucanto/interface'\n\n/**\n * @param {API.DID} did\n * @param {API.PrincipalParser[]} parsers\n * @return {API.Verifier}\n */\nconst parseWith = (did, parsers) => {\n  if (did.startsWith('did:')) {\n    for (const parser of parsers) {\n      try {\n        return parser.parse(did)\n      } catch (_) {}\n    }\n    throw new Error(`Unsupported did ${did}`)\n  } else {\n    throw new Error(`Expected did instead got ${did}`)\n  }\n}\n\n/**\n * @param {API.PrincipalParser} left\n * @param {API.PrincipalParser} right\n * @returns {API.ComposedDIDParser}\n */\nexport const or = (left, right) => new Parser([left, right])\n\n/**\n * @implements {API.ComposedDIDParser}\n */\nclass Parser {\n  /**\n   * @param {API.PrincipalParser[]} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n  }\n\n  /**\n   * @param {API.DID} did\n   */\n  parse(did) {\n    return parseWith(did, this.variants)\n  }\n\n  /**\n   * @param {API.PrincipalParser} parser\n   */\n  or(parser) {\n    return new Parser([...this.variants, parser])\n  }\n}\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @param {API.VerifierKey<SigAlg>} key\n * @param {ID} id\n * @returns {API.Verifier<ID, SigAlg>}\n */\nexport const withDID = (key, id) => new VerifierWithDID(id, key)\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @implements {API.Verifier<ID, SigAlg>}\n */\nclass VerifierWithDID {\n  /**\n   * @param {ID} id\n   * @param {API.VerifierKey<SigAlg>} key\n   */\n  constructor(id, key) {\n    this.id = id\n    this.key = key\n  }\n  did() {\n    return this.id\n  }\n\n  toDIDKey() {\n    return this.key.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, SigAlg>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return this.key.verify(payload, signature)\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n}\n", "import * as API from '@ucanto/interface'\n\n/**\n * @template {API.SignerImporter} L\n * @template {API.SignerImporter} R\n * @param {L} left\n * @param {R} right\n * @returns {API.CompositeImporter<[L, R]>}\n */\nexport const or = (left, right) => new Importer([left, right])\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @implements {API.CompositeImporter<Importers>}\n */\nclass Importer {\n  /**\n   * @param {Importers} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n    this.from = create(variants)\n  }\n\n  /**\n   * @template {API.SignerImporter} Other\n   * @param {Other} other\n   * @returns {API.CompositeImporter<[Other, ...Importers]>}\n   */\n  or(other) {\n    return new Importer([other, ...this.variants])\n  }\n}\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @param {Importers} importers\n */\nconst create = importers => {\n  /**\n   * @template {API.DID} ID - DID that can be imported, which may be a type union.\n   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.\n   * @param {API.SignerArchive<ID, Alg>} archive\n   * @returns {API.Signer<ID, Alg>}\n   */\n  const from = archive => {\n    if (archive.id.startsWith('did:key:')) {\n      return /** @type {API.Signer<ID, Alg>} */ (importWith(archive, importers))\n    } else {\n      for (const [name, key] of Object.entries(archive.keys)) {\n        const id = /** @type {API.DIDKey} */ (name)\n        const signer = /** @type {API.Signer<API.DIDKey, Alg>} */ (\n          importWith(\n            {\n              id,\n              keys: { [id]: key },\n            },\n            importers\n          )\n        )\n\n        return signer.withDID(archive.id)\n      }\n\n      throw new Error(`Archive ${archive.id} contains no keys`)\n    }\n  }\n\n  return /** @type {API.Intersection<Importers[number]['from']>} */ (from)\n}\n\n/**\n * @param {API.SignerArchive} archive\n * @param {API.SignerImporter[]} importers\n * @returns {API.Signer}\n */\nconst importWith = (archive, importers) => {\n  for (const importer of importers) {\n    try {\n      return importer.from(archive)\n    } catch (_) {}\n  }\n  throw new Error(`Unsupported signer`)\n}\n/**\n * @template {number} Code\n * @template {API.DID} ID\n * @param {API.Signer<API.DID<'key'>, Code>} signer\n * @param {ID} id\n * @returns {API.Signer<ID, Code>}\n */\nexport const withDID = ({ signer, verifier }, id) =>\n  new SignerWithDID(signer, verifier.withDID(id))\n\n/**\n * @template {API.DID} ID\n * @template {number} Code\n * @implements {API.Signer<ID, Code>}\n */\nclass SignerWithDID {\n  /**\n   * @param {API.Signer<API.DID<'key'>, Code>} key\n   * @param {API.Verifier<ID, Code>} verifier\n   */\n  constructor(key, verifier) {\n    this.key = key\n    this.verifier = verifier\n  }\n  /** @type {API.Signer<ID, Code>} */\n  get signer() {\n    return this\n  }\n\n  get signatureAlgorithm() {\n    return this.key.signatureAlgorithm\n  }\n  get signatureCode() {\n    return this.key.signatureCode\n  }\n\n  /**\n   * @returns {ID}\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   */\n  sign(payload) {\n    return this.key.sign(payload)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Code>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  toArchive() {\n    const { keys } = this.key.toArchive()\n    return {\n      id: this.did(),\n      keys,\n    }\n  }\n}\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, Hash, toBytes, type CHash, type Input } from './utils.ts';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n", "/**\n * Audited & minimal JS implementation of\n * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).\n * @module\n * @example\n```js\nimport * as bip39 from '@scure/bip39';\nimport { wordlist } from '@scure/bip39/wordlists/english';\nconst mn = bip39.generateMnemonic(wordlist);\nconsole.log(mn);\nconst ent = bip39.mnemonicToEntropy(mn, wordlist)\nbip39.entropyToMnemonic(ent, wordlist);\nbip39.validateMnemonic(mn, wordlist);\nawait bip39.mnemonicToSeed(mn, 'password');\nbip39.mnemonicToSeedSync(mn, 'password');\n\n// Wordlists\nimport { wordlist as czech } from '@scure/bip39/wordlists/czech';\nimport { wordlist as english } from '@scure/bip39/wordlists/english';\nimport { wordlist as french } from '@scure/bip39/wordlists/french';\nimport { wordlist as italian } from '@scure/bip39/wordlists/italian';\nimport { wordlist as japanese } from '@scure/bip39/wordlists/japanese';\nimport { wordlist as korean } from '@scure/bip39/wordlists/korean';\nimport { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';\nimport { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';\nimport { wordlist as spanish } from '@scure/bip39/wordlists/spanish';\nimport { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';\n```\n */\n/*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */\nimport { pbkdf2, pbkdf2Async } from '@noble/hashes/pbkdf2';\nimport { sha256, sha512 } from '@noble/hashes/sha2';\nimport { abytes, anumber, randomBytes } from '@noble/hashes/utils';\nimport { utils as baseUtils } from '@scure/base';\n// Japanese wordlist\nconst isJapanese = (wordlist) => wordlist[0] === '\\u3042\\u3044\\u3053\\u304f\\u3057\\u3093';\n// Normalization replaces equivalent sequences of characters\n// so that any two texts that are equivalent will be reduced\n// to the same sequence of code points, called the normal form of the original text.\n// https://tonsky.me/blog/unicode/#why-is-a----\nfunction nfkd(str) {\n    if (typeof str !== 'string')\n        throw new TypeError('invalid mnemonic type: ' + typeof str);\n    return str.normalize('NFKD');\n}\nfunction normalize(str) {\n    const norm = nfkd(str);\n    const words = norm.split(' ');\n    if (![12, 15, 18, 21, 24].includes(words.length))\n        throw new Error('Invalid mnemonic');\n    return { nfkd: norm, words };\n}\nfunction aentropy(ent) {\n    abytes(ent, 16, 20, 24, 28, 32);\n}\n/**\n * Generate x random words. Uses Cryptographically-Secure Random Number Generator.\n * @param wordlist imported wordlist for specific language\n * @param strength mnemonic strength 128-256 bits\n * @example\n * generateMnemonic(wordlist, 128)\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function generateMnemonic(wordlist, strength = 128) {\n    anumber(strength);\n    if (strength % 32 !== 0 || strength > 256)\n        throw new TypeError('Invalid entropy');\n    return entropyToMnemonic(randomBytes(strength / 8), wordlist);\n}\nconst calcChecksum = (entropy) => {\n    // Checksum is ent.length/4 bits long\n    const bitsLeft = 8 - entropy.length / 4;\n    // Zero rightmost \"bitsLeft\" bits in byte\n    // For example: bitsLeft=4 val=10111101 -> 10110000\n    return new Uint8Array([(sha256(entropy)[0] >> bitsLeft) << bitsLeft]);\n};\nfunction getCoder(wordlist) {\n    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string')\n        throw new Error('Wordlist: expected array of 2048 strings');\n    wordlist.forEach((i) => {\n        if (typeof i !== 'string')\n            throw new Error('wordlist: non-string element: ' + i);\n    });\n    return baseUtils.chain(baseUtils.checksum(1, calcChecksum), baseUtils.radix2(11, true), baseUtils.alphabet(wordlist));\n}\n/**\n * Reversible: Converts mnemonic string to raw entropy in form of byte array.\n * @param mnemonic 12-24 words\n * @param wordlist imported wordlist for specific language\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToEntropy(mnem, wordlist)\n * // Produces\n * new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ])\n */\nexport function mnemonicToEntropy(mnemonic, wordlist) {\n    const { words } = normalize(mnemonic);\n    const entropy = getCoder(wordlist).decode(words);\n    aentropy(entropy);\n    return entropy;\n}\n/**\n * Reversible: Converts raw entropy in form of byte array to mnemonic string.\n * @param entropy byte array\n * @param wordlist imported wordlist for specific language\n * @returns 12-24 words\n * @example\n * const ent = new Uint8Array([\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f,\n *   0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f, 0x7f\n * ]);\n * entropyToMnemonic(ent, wordlist);\n * // 'legal winner thank year wave sausage worth useful legal winner thank yellow'\n */\nexport function entropyToMnemonic(entropy, wordlist) {\n    aentropy(entropy);\n    const words = getCoder(wordlist).encode(entropy);\n    return words.join(isJapanese(wordlist) ? '\\u3000' : ' ');\n}\n/**\n * Validates mnemonic for being 12-24 words contained in `wordlist`.\n */\nexport function validateMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n    }\n    catch (e) {\n        return false;\n    }\n    return true;\n}\nconst psalt = (passphrase) => nfkd('mnemonic' + passphrase);\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * await mnemonicToSeed(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeed(mnemonic, passphrase = '') {\n    return pbkdf2Async(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n/**\n * Irreversible: Uses KDF to derive 64 bytes of key data from mnemonic + optional password.\n * @param mnemonic 12-24 words\n * @param passphrase string that will additionally protect the key\n * @returns 64 bytes of key data\n * @example\n * const mnem = 'legal winner thank year wave sausage worth useful legal winner thank yellow';\n * mnemonicToSeedSync(mnem, 'password');\n * // new Uint8Array([...64 bytes])\n */\nexport function mnemonicToSeedSync(mnemonic, passphrase = '') {\n    return pbkdf2(sha512, normalize(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });\n}\n", "export const wordlist = `abandon\nability\nable\nabout\nabove\nabsent\nabsorb\nabstract\nabsurd\nabuse\naccess\naccident\naccount\naccuse\nachieve\nacid\nacoustic\nacquire\nacross\nact\naction\nactor\nactress\nactual\nadapt\nadd\naddict\naddress\nadjust\nadmit\nadult\nadvance\nadvice\naerobic\naffair\nafford\nafraid\nagain\nage\nagent\nagree\nahead\naim\nair\nairport\naisle\nalarm\nalbum\nalcohol\nalert\nalien\nall\nalley\nallow\nalmost\nalone\nalpha\nalready\nalso\nalter\nalways\namateur\namazing\namong\namount\namused\nanalyst\nanchor\nancient\nanger\nangle\nangry\nanimal\nankle\nannounce\nannual\nanother\nanswer\nantenna\nantique\nanxiety\nany\napart\napology\nappear\napple\napprove\napril\narch\narctic\narea\narena\nargue\narm\narmed\narmor\narmy\naround\narrange\narrest\narrive\narrow\nart\nartefact\nartist\nartwork\nask\naspect\nassault\nasset\nassist\nassume\nasthma\nathlete\natom\nattack\nattend\nattitude\nattract\nauction\naudit\naugust\naunt\nauthor\nauto\nautumn\naverage\navocado\navoid\nawake\naware\naway\nawesome\nawful\nawkward\naxis\nbaby\nbachelor\nbacon\nbadge\nbag\nbalance\nbalcony\nball\nbamboo\nbanana\nbanner\nbar\nbarely\nbargain\nbarrel\nbase\nbasic\nbasket\nbattle\nbeach\nbean\nbeauty\nbecause\nbecome\nbeef\nbefore\nbegin\nbehave\nbehind\nbelieve\nbelow\nbelt\nbench\nbenefit\nbest\nbetray\nbetter\nbetween\nbeyond\nbicycle\nbid\nbike\nbind\nbiology\nbird\nbirth\nbitter\nblack\nblade\nblame\nblanket\nblast\nbleak\nbless\nblind\nblood\nblossom\nblouse\nblue\nblur\nblush\nboard\nboat\nbody\nboil\nbomb\nbone\nbonus\nbook\nboost\nborder\nboring\nborrow\nboss\nbottom\nbounce\nbox\nboy\nbracket\nbrain\nbrand\nbrass\nbrave\nbread\nbreeze\nbrick\nbridge\nbrief\nbright\nbring\nbrisk\nbroccoli\nbroken\nbronze\nbroom\nbrother\nbrown\nbrush\nbubble\nbuddy\nbudget\nbuffalo\nbuild\nbulb\nbulk\nbullet\nbundle\nbunker\nburden\nburger\nburst\nbus\nbusiness\nbusy\nbutter\nbuyer\nbuzz\ncabbage\ncabin\ncable\ncactus\ncage\ncake\ncall\ncalm\ncamera\ncamp\ncan\ncanal\ncancel\ncandy\ncannon\ncanoe\ncanvas\ncanyon\ncapable\ncapital\ncaptain\ncar\ncarbon\ncard\ncargo\ncarpet\ncarry\ncart\ncase\ncash\ncasino\ncastle\ncasual\ncat\ncatalog\ncatch\ncategory\ncattle\ncaught\ncause\ncaution\ncave\nceiling\ncelery\ncement\ncensus\ncentury\ncereal\ncertain\nchair\nchalk\nchampion\nchange\nchaos\nchapter\ncharge\nchase\nchat\ncheap\ncheck\ncheese\nchef\ncherry\nchest\nchicken\nchief\nchild\nchimney\nchoice\nchoose\nchronic\nchuckle\nchunk\nchurn\ncigar\ncinnamon\ncircle\ncitizen\ncity\ncivil\nclaim\nclap\nclarify\nclaw\nclay\nclean\nclerk\nclever\nclick\nclient\ncliff\nclimb\nclinic\nclip\nclock\nclog\nclose\ncloth\ncloud\nclown\nclub\nclump\ncluster\nclutch\ncoach\ncoast\ncoconut\ncode\ncoffee\ncoil\ncoin\ncollect\ncolor\ncolumn\ncombine\ncome\ncomfort\ncomic\ncommon\ncompany\nconcert\nconduct\nconfirm\ncongress\nconnect\nconsider\ncontrol\nconvince\ncook\ncool\ncopper\ncopy\ncoral\ncore\ncorn\ncorrect\ncost\ncotton\ncouch\ncountry\ncouple\ncourse\ncousin\ncover\ncoyote\ncrack\ncradle\ncraft\ncram\ncrane\ncrash\ncrater\ncrawl\ncrazy\ncream\ncredit\ncreek\ncrew\ncricket\ncrime\ncrisp\ncritic\ncrop\ncross\ncrouch\ncrowd\ncrucial\ncruel\ncruise\ncrumble\ncrunch\ncrush\ncry\ncrystal\ncube\nculture\ncup\ncupboard\ncurious\ncurrent\ncurtain\ncurve\ncushion\ncustom\ncute\ncycle\ndad\ndamage\ndamp\ndance\ndanger\ndaring\ndash\ndaughter\ndawn\nday\ndeal\ndebate\ndebris\ndecade\ndecember\ndecide\ndecline\ndecorate\ndecrease\ndeer\ndefense\ndefine\ndefy\ndegree\ndelay\ndeliver\ndemand\ndemise\ndenial\ndentist\ndeny\ndepart\ndepend\ndeposit\ndepth\ndeputy\nderive\ndescribe\ndesert\ndesign\ndesk\ndespair\ndestroy\ndetail\ndetect\ndevelop\ndevice\ndevote\ndiagram\ndial\ndiamond\ndiary\ndice\ndiesel\ndiet\ndiffer\ndigital\ndignity\ndilemma\ndinner\ndinosaur\ndirect\ndirt\ndisagree\ndiscover\ndisease\ndish\ndismiss\ndisorder\ndisplay\ndistance\ndivert\ndivide\ndivorce\ndizzy\ndoctor\ndocument\ndog\ndoll\ndolphin\ndomain\ndonate\ndonkey\ndonor\ndoor\ndose\ndouble\ndove\ndraft\ndragon\ndrama\ndrastic\ndraw\ndream\ndress\ndrift\ndrill\ndrink\ndrip\ndrive\ndrop\ndrum\ndry\nduck\ndumb\ndune\nduring\ndust\ndutch\nduty\ndwarf\ndynamic\neager\neagle\nearly\nearn\nearth\neasily\neast\neasy\necho\necology\neconomy\nedge\nedit\neducate\neffort\negg\neight\neither\nelbow\nelder\nelectric\nelegant\nelement\nelephant\nelevator\nelite\nelse\nembark\nembody\nembrace\nemerge\nemotion\nemploy\nempower\nempty\nenable\nenact\nend\nendless\nendorse\nenemy\nenergy\nenforce\nengage\nengine\nenhance\nenjoy\nenlist\nenough\nenrich\nenroll\nensure\nenter\nentire\nentry\nenvelope\nepisode\nequal\nequip\nera\nerase\nerode\nerosion\nerror\nerupt\nescape\nessay\nessence\nestate\neternal\nethics\nevidence\nevil\nevoke\nevolve\nexact\nexample\nexcess\nexchange\nexcite\nexclude\nexcuse\nexecute\nexercise\nexhaust\nexhibit\nexile\nexist\nexit\nexotic\nexpand\nexpect\nexpire\nexplain\nexpose\nexpress\nextend\nextra\neye\neyebrow\nfabric\nface\nfaculty\nfade\nfaint\nfaith\nfall\nfalse\nfame\nfamily\nfamous\nfan\nfancy\nfantasy\nfarm\nfashion\nfat\nfatal\nfather\nfatigue\nfault\nfavorite\nfeature\nfebruary\nfederal\nfee\nfeed\nfeel\nfemale\nfence\nfestival\nfetch\nfever\nfew\nfiber\nfiction\nfield\nfigure\nfile\nfilm\nfilter\nfinal\nfind\nfine\nfinger\nfinish\nfire\nfirm\nfirst\nfiscal\nfish\nfit\nfitness\nfix\nflag\nflame\nflash\nflat\nflavor\nflee\nflight\nflip\nfloat\nflock\nfloor\nflower\nfluid\nflush\nfly\nfoam\nfocus\nfog\nfoil\nfold\nfollow\nfood\nfoot\nforce\nforest\nforget\nfork\nfortune\nforum\nforward\nfossil\nfoster\nfound\nfox\nfragile\nframe\nfrequent\nfresh\nfriend\nfringe\nfrog\nfront\nfrost\nfrown\nfrozen\nfruit\nfuel\nfun\nfunny\nfurnace\nfury\nfuture\ngadget\ngain\ngalaxy\ngallery\ngame\ngap\ngarage\ngarbage\ngarden\ngarlic\ngarment\ngas\ngasp\ngate\ngather\ngauge\ngaze\ngeneral\ngenius\ngenre\ngentle\ngenuine\ngesture\nghost\ngiant\ngift\ngiggle\nginger\ngiraffe\ngirl\ngive\nglad\nglance\nglare\nglass\nglide\nglimpse\nglobe\ngloom\nglory\nglove\nglow\nglue\ngoat\ngoddess\ngold\ngood\ngoose\ngorilla\ngospel\ngossip\ngovern\ngown\ngrab\ngrace\ngrain\ngrant\ngrape\ngrass\ngravity\ngreat\ngreen\ngrid\ngrief\ngrit\ngrocery\ngroup\ngrow\ngrunt\nguard\nguess\nguide\nguilt\nguitar\ngun\ngym\nhabit\nhair\nhalf\nhammer\nhamster\nhand\nhappy\nharbor\nhard\nharsh\nharvest\nhat\nhave\nhawk\nhazard\nhead\nhealth\nheart\nheavy\nhedgehog\nheight\nhello\nhelmet\nhelp\nhen\nhero\nhidden\nhigh\nhill\nhint\nhip\nhire\nhistory\nhobby\nhockey\nhold\nhole\nholiday\nhollow\nhome\nhoney\nhood\nhope\nhorn\nhorror\nhorse\nhospital\nhost\nhotel\nhour\nhover\nhub\nhuge\nhuman\nhumble\nhumor\nhundred\nhungry\nhunt\nhurdle\nhurry\nhurt\nhusband\nhybrid\nice\nicon\nidea\nidentify\nidle\nignore\nill\nillegal\nillness\nimage\nimitate\nimmense\nimmune\nimpact\nimpose\nimprove\nimpulse\ninch\ninclude\nincome\nincrease\nindex\nindicate\nindoor\nindustry\ninfant\ninflict\ninform\ninhale\ninherit\ninitial\ninject\ninjury\ninmate\ninner\ninnocent\ninput\ninquiry\ninsane\ninsect\ninside\ninspire\ninstall\nintact\ninterest\ninto\ninvest\ninvite\ninvolve\niron\nisland\nisolate\nissue\nitem\nivory\njacket\njaguar\njar\njazz\njealous\njeans\njelly\njewel\njob\njoin\njoke\njourney\njoy\njudge\njuice\njump\njungle\njunior\njunk\njust\nkangaroo\nkeen\nkeep\nketchup\nkey\nkick\nkid\nkidney\nkind\nkingdom\nkiss\nkit\nkitchen\nkite\nkitten\nkiwi\nknee\nknife\nknock\nknow\nlab\nlabel\nlabor\nladder\nlady\nlake\nlamp\nlanguage\nlaptop\nlarge\nlater\nlatin\nlaugh\nlaundry\nlava\nlaw\nlawn\nlawsuit\nlayer\nlazy\nleader\nleaf\nlearn\nleave\nlecture\nleft\nleg\nlegal\nlegend\nleisure\nlemon\nlend\nlength\nlens\nleopard\nlesson\nletter\nlevel\nliar\nliberty\nlibrary\nlicense\nlife\nlift\nlight\nlike\nlimb\nlimit\nlink\nlion\nliquid\nlist\nlittle\nlive\nlizard\nload\nloan\nlobster\nlocal\nlock\nlogic\nlonely\nlong\nloop\nlottery\nloud\nlounge\nlove\nloyal\nlucky\nluggage\nlumber\nlunar\nlunch\nluxury\nlyrics\nmachine\nmad\nmagic\nmagnet\nmaid\nmail\nmain\nmajor\nmake\nmammal\nman\nmanage\nmandate\nmango\nmansion\nmanual\nmaple\nmarble\nmarch\nmargin\nmarine\nmarket\nmarriage\nmask\nmass\nmaster\nmatch\nmaterial\nmath\nmatrix\nmatter\nmaximum\nmaze\nmeadow\nmean\nmeasure\nmeat\nmechanic\nmedal\nmedia\nmelody\nmelt\nmember\nmemory\nmention\nmenu\nmercy\nmerge\nmerit\nmerry\nmesh\nmessage\nmetal\nmethod\nmiddle\nmidnight\nmilk\nmillion\nmimic\nmind\nminimum\nminor\nminute\nmiracle\nmirror\nmisery\nmiss\nmistake\nmix\nmixed\nmixture\nmobile\nmodel\nmodify\nmom\nmoment\nmonitor\nmonkey\nmonster\nmonth\nmoon\nmoral\nmore\nmorning\nmosquito\nmother\nmotion\nmotor\nmountain\nmouse\nmove\nmovie\nmuch\nmuffin\nmule\nmultiply\nmuscle\nmuseum\nmushroom\nmusic\nmust\nmutual\nmyself\nmystery\nmyth\nnaive\nname\nnapkin\nnarrow\nnasty\nnation\nnature\nnear\nneck\nneed\nnegative\nneglect\nneither\nnephew\nnerve\nnest\nnet\nnetwork\nneutral\nnever\nnews\nnext\nnice\nnight\nnoble\nnoise\nnominee\nnoodle\nnormal\nnorth\nnose\nnotable\nnote\nnothing\nnotice\nnovel\nnow\nnuclear\nnumber\nnurse\nnut\noak\nobey\nobject\noblige\nobscure\nobserve\nobtain\nobvious\noccur\nocean\noctober\nodor\noff\noffer\noffice\noften\noil\nokay\nold\nolive\nolympic\nomit\nonce\none\nonion\nonline\nonly\nopen\nopera\nopinion\noppose\noption\norange\norbit\norchard\norder\nordinary\norgan\norient\noriginal\norphan\nostrich\nother\noutdoor\nouter\noutput\noutside\noval\noven\nover\nown\nowner\noxygen\noyster\nozone\npact\npaddle\npage\npair\npalace\npalm\npanda\npanel\npanic\npanther\npaper\nparade\nparent\npark\nparrot\nparty\npass\npatch\npath\npatient\npatrol\npattern\npause\npave\npayment\npeace\npeanut\npear\npeasant\npelican\npen\npenalty\npencil\npeople\npepper\nperfect\npermit\nperson\npet\nphone\nphoto\nphrase\nphysical\npiano\npicnic\npicture\npiece\npig\npigeon\npill\npilot\npink\npioneer\npipe\npistol\npitch\npizza\nplace\nplanet\nplastic\nplate\nplay\nplease\npledge\npluck\nplug\nplunge\npoem\npoet\npoint\npolar\npole\npolice\npond\npony\npool\npopular\nportion\nposition\npossible\npost\npotato\npottery\npoverty\npowder\npower\npractice\npraise\npredict\nprefer\nprepare\npresent\npretty\nprevent\nprice\npride\nprimary\nprint\npriority\nprison\nprivate\nprize\nproblem\nprocess\nproduce\nprofit\nprogram\nproject\npromote\nproof\nproperty\nprosper\nprotect\nproud\nprovide\npublic\npudding\npull\npulp\npulse\npumpkin\npunch\npupil\npuppy\npurchase\npurity\npurpose\npurse\npush\nput\npuzzle\npyramid\nquality\nquantum\nquarter\nquestion\nquick\nquit\nquiz\nquote\nrabbit\nraccoon\nrace\nrack\nradar\nradio\nrail\nrain\nraise\nrally\nramp\nranch\nrandom\nrange\nrapid\nrare\nrate\nrather\nraven\nraw\nrazor\nready\nreal\nreason\nrebel\nrebuild\nrecall\nreceive\nrecipe\nrecord\nrecycle\nreduce\nreflect\nreform\nrefuse\nregion\nregret\nregular\nreject\nrelax\nrelease\nrelief\nrely\nremain\nremember\nremind\nremove\nrender\nrenew\nrent\nreopen\nrepair\nrepeat\nreplace\nreport\nrequire\nrescue\nresemble\nresist\nresource\nresponse\nresult\nretire\nretreat\nreturn\nreunion\nreveal\nreview\nreward\nrhythm\nrib\nribbon\nrice\nrich\nride\nridge\nrifle\nright\nrigid\nring\nriot\nripple\nrisk\nritual\nrival\nriver\nroad\nroast\nrobot\nrobust\nrocket\nromance\nroof\nrookie\nroom\nrose\nrotate\nrough\nround\nroute\nroyal\nrubber\nrude\nrug\nrule\nrun\nrunway\nrural\nsad\nsaddle\nsadness\nsafe\nsail\nsalad\nsalmon\nsalon\nsalt\nsalute\nsame\nsample\nsand\nsatisfy\nsatoshi\nsauce\nsausage\nsave\nsay\nscale\nscan\nscare\nscatter\nscene\nscheme\nschool\nscience\nscissors\nscorpion\nscout\nscrap\nscreen\nscript\nscrub\nsea\nsearch\nseason\nseat\nsecond\nsecret\nsection\nsecurity\nseed\nseek\nsegment\nselect\nsell\nseminar\nsenior\nsense\nsentence\nseries\nservice\nsession\nsettle\nsetup\nseven\nshadow\nshaft\nshallow\nshare\nshed\nshell\nsheriff\nshield\nshift\nshine\nship\nshiver\nshock\nshoe\nshoot\nshop\nshort\nshoulder\nshove\nshrimp\nshrug\nshuffle\nshy\nsibling\nsick\nside\nsiege\nsight\nsign\nsilent\nsilk\nsilly\nsilver\nsimilar\nsimple\nsince\nsing\nsiren\nsister\nsituate\nsix\nsize\nskate\nsketch\nski\nskill\nskin\nskirt\nskull\nslab\nslam\nsleep\nslender\nslice\nslide\nslight\nslim\nslogan\nslot\nslow\nslush\nsmall\nsmart\nsmile\nsmoke\nsmooth\nsnack\nsnake\nsnap\nsniff\nsnow\nsoap\nsoccer\nsocial\nsock\nsoda\nsoft\nsolar\nsoldier\nsolid\nsolution\nsolve\nsomeone\nsong\nsoon\nsorry\nsort\nsoul\nsound\nsoup\nsource\nsouth\nspace\nspare\nspatial\nspawn\nspeak\nspecial\nspeed\nspell\nspend\nsphere\nspice\nspider\nspike\nspin\nspirit\nsplit\nspoil\nsponsor\nspoon\nsport\nspot\nspray\nspread\nspring\nspy\nsquare\nsqueeze\nsquirrel\nstable\nstadium\nstaff\nstage\nstairs\nstamp\nstand\nstart\nstate\nstay\nsteak\nsteel\nstem\nstep\nstereo\nstick\nstill\nsting\nstock\nstomach\nstone\nstool\nstory\nstove\nstrategy\nstreet\nstrike\nstrong\nstruggle\nstudent\nstuff\nstumble\nstyle\nsubject\nsubmit\nsubway\nsuccess\nsuch\nsudden\nsuffer\nsugar\nsuggest\nsuit\nsummer\nsun\nsunny\nsunset\nsuper\nsupply\nsupreme\nsure\nsurface\nsurge\nsurprise\nsurround\nsurvey\nsuspect\nsustain\nswallow\nswamp\nswap\nswarm\nswear\nsweet\nswift\nswim\nswing\nswitch\nsword\nsymbol\nsymptom\nsyrup\nsystem\ntable\ntackle\ntag\ntail\ntalent\ntalk\ntank\ntape\ntarget\ntask\ntaste\ntattoo\ntaxi\nteach\nteam\ntell\nten\ntenant\ntennis\ntent\nterm\ntest\ntext\nthank\nthat\ntheme\nthen\ntheory\nthere\nthey\nthing\nthis\nthought\nthree\nthrive\nthrow\nthumb\nthunder\nticket\ntide\ntiger\ntilt\ntimber\ntime\ntiny\ntip\ntired\ntissue\ntitle\ntoast\ntobacco\ntoday\ntoddler\ntoe\ntogether\ntoilet\ntoken\ntomato\ntomorrow\ntone\ntongue\ntonight\ntool\ntooth\ntop\ntopic\ntopple\ntorch\ntornado\ntortoise\ntoss\ntotal\ntourist\ntoward\ntower\ntown\ntoy\ntrack\ntrade\ntraffic\ntragic\ntrain\ntransfer\ntrap\ntrash\ntravel\ntray\ntreat\ntree\ntrend\ntrial\ntribe\ntrick\ntrigger\ntrim\ntrip\ntrophy\ntrouble\ntruck\ntrue\ntruly\ntrumpet\ntrust\ntruth\ntry\ntube\ntuition\ntumble\ntuna\ntunnel\nturkey\nturn\nturtle\ntwelve\ntwenty\ntwice\ntwin\ntwist\ntwo\ntype\ntypical\nugly\numbrella\nunable\nunaware\nuncle\nuncover\nunder\nundo\nunfair\nunfold\nunhappy\nuniform\nunique\nunit\nuniverse\nunknown\nunlock\nuntil\nunusual\nunveil\nupdate\nupgrade\nuphold\nupon\nupper\nupset\nurban\nurge\nusage\nuse\nused\nuseful\nuseless\nusual\nutility\nvacant\nvacuum\nvague\nvalid\nvalley\nvalve\nvan\nvanish\nvapor\nvarious\nvast\nvault\nvehicle\nvelvet\nvendor\nventure\nvenue\nverb\nverify\nversion\nvery\nvessel\nveteran\nviable\nvibrant\nvicious\nvictory\nvideo\nview\nvillage\nvintage\nviolin\nvirtual\nvirus\nvisa\nvisit\nvisual\nvital\nvivid\nvocal\nvoice\nvoid\nvolcano\nvolume\nvote\nvoyage\nwage\nwagon\nwait\nwalk\nwall\nwalnut\nwant\nwarfare\nwarm\nwarrior\nwash\nwasp\nwaste\nwater\nwave\nway\nwealth\nweapon\nwear\nweasel\nweather\nweb\nwedding\nweekend\nweird\nwelcome\nwest\nwet\nwhale\nwhat\nwheat\nwheel\nwhen\nwhere\nwhip\nwhisper\nwide\nwidth\nwife\nwild\nwill\nwin\nwindow\nwine\nwing\nwink\nwinner\nwinter\nwire\nwisdom\nwise\nwish\nwitness\nwolf\nwoman\nwonder\nwood\nwool\nword\nwork\nworld\nworry\nworth\nwrap\nwreck\nwrestle\nwrist\nwrite\nwrong\nyard\nyear\nyellow\nyou\nyoung\nyouth\nzebra\nzero\nzone\nzoo`.split('\\n');\n", "/**\n * Provider Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Provider from '@storacha/capabilities/provider'\n * ```\n *\n * @module\n */\nimport { capability, DID, struct, ok } from '@ucanto/validator';\nimport { AccountDID, equalWith, and, equal, SpaceDID } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const Provider = DID.match({ method: 'web' });\nexport { AccountDID };\n/**\n * Capability can be invoked by an agent to add a provider to a space.\n */\nexport const add = capability({\n    can: 'provider/add',\n    with: AccountDID,\n    nb: struct({\n        provider: Provider,\n        consumer: SpaceDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.provider, parent.nb.provider, 'provider')) ||\n            and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=provider.js.map", "import * as API from './types.js';\nimport * as Provider from '@storacha/capabilities/provider';\nexport const { Provider: ProviderDID, AccountDID } = Provider;\n/**\n * Provisions specified `space` with the specified `account`. It is expected\n * that delegation from the account authorizing agent is either stored in the\n * agent proofs or provided explicitly.\n *\n * @template {Record<string, any>} [S=API.Service]\n * @param {API.Agent<S>} agent\n * @param {object} input\n * @param {API.AccountDID} input.account - Account provisioning the space.\n * @param {API.SpaceDID} input.consumer - Space been provisioned.\n * @param {API.ProviderDID} [input.provider] - Provider been provisioned.\n * @param {API.Delegation[]} [input.proofs] - Delegation from the account\n * authorizing agent to call `provider/add` capability.\n */\nexport const add = async (agent, { account, consumer, provider = /** @type {API.ProviderDID} */ (agent.connection.id.did()), proofs, }) => {\n    if (!ProviderDID.is(provider)) {\n        throw new Error(`Unable to determine provider from agent.connection.id did ${provider}. expected a did:web:`);\n    }\n    const { out } = await agent.invokeAndExecute(Provider.add, {\n        with: account,\n        nb: {\n            provider,\n            consumer,\n        },\n        proofs,\n    });\n    return out;\n};\n//# sourceMappingURL=provider.js.map", "import * as API from './types.js';\n/**\n * Known valid provider/algorithm combinations\n *\n * @type {Record<string, string[]>}\n */\nconst VALID_COMBINATIONS = {\n    'google-kms': ['RSA_DECRYPT_OAEP_3072_SHA256'],\n    // Add more providers and algorithms here as needed\n};\n/**\n * Space access utilities and validation\n */\nexport class SpaceAccess {\n    /**\n     * Creates and validates a space access configuration\n     *\n     * @template {API.SpaceAccessType} T\n     * @param {T} [access] - The access configuration to validate\n     * @returns {T}\n     * @throws {Error} When access configuration is invalid\n     */\n    static from(access) {\n        if (!access || access.type === 'public') {\n            return /** @type {T} */ ({ type: 'public' });\n        }\n        if (access.type === 'private') {\n            if (!access.encryption) {\n                throw new Error('Private access type requires encryption configuration');\n            }\n            const { provider, algorithm } = access.encryption;\n            if (!VALID_COMBINATIONS[provider]) {\n                throw new Error(`unknown encryption provider: ${provider}`);\n            }\n            if (!VALID_COMBINATIONS[provider].includes(algorithm)) {\n                throw new Error(`unknown encryption algorithm: ${algorithm} for provider: ${provider}`);\n            }\n            return /** @type {T} */ (access);\n        }\n        throw new Error(`unknown access type: ${ /** @type {any} */(access).type}`);\n    }\n    /**\n     * Creates a public space access configuration\n     *\n     * @returns {API.PublicAccess}\n     */\n    static public() {\n        return { type: 'public' };\n    }\n    /**\n     * Creates a private space access configuration with encryption provider\n     *\n     * @param {string} [provider] - The encryption provider. Defaults to `google-kms`.\n     * @param {string} [algorithm] - The encryption algorithm. Defaults to `RSA_DECRYPT_OAEP_3072_SHA256`.\n     * @returns {API.PrivateAccess<API.EncryptionProvider>}\n     * @throws {Error} When provider/algorithm combination is invalid\n     */\n    static private(provider = 'google-kms', algorithm = 'RSA_DECRYPT_OAEP_3072_SHA256') {\n        if (!VALID_COMBINATIONS[provider]) {\n            throw new Error(`unknown encryption provider: ${provider}`);\n        }\n        if (!VALID_COMBINATIONS[provider].includes(algorithm)) {\n            throw new Error(`unknown encryption algorithm: ${algorithm} for provider: ${provider}`);\n        }\n        return {\n            type: 'private',\n            encryption: { provider, algorithm },\n        };\n    }\n}\n//# sourceMappingURL=space-access.js.map", "import * as ucanto from '@ucanto/core';\nimport * as API from './types.js';\nimport { canDelegateAbility } from '@storacha/capabilities/utils';\n/**\n *\n * @param {API.Delegation} delegation\n */\nexport function isExpired(delegation) {\n    if (delegation.expiration === undefined ||\n        delegation.expiration <= Math.floor(Date.now() / 1000)) {\n        return true;\n    }\n    return false;\n}\n/**\n *\n * @param {API.Delegation} delegation\n */\nexport function isTooEarly(delegation) {\n    if (!delegation.notBefore) {\n        return false;\n    }\n    return delegation.notBefore > Math.floor(Date.now() / 1000);\n}\n/**\n *\n * @param {API.Delegation} delegation\n * @param {object} [opts]\n * @param {API.Principal} [opts.checkAudience]\n * @param {boolean} [opts.checkIsExpired]\n * @param {boolean} [opts.checkIsTooEarly]\n */\nexport function validate(delegation, opts) {\n    const { checkAudience, checkIsExpired = true, checkIsTooEarly = true, } = opts ?? {};\n    if (checkAudience && delegation.audience.did() !== checkAudience.did()) {\n        throw new Error(`Delegation audience ${delegation.audience.did()} does not match required DID ${checkAudience.did()}`);\n    }\n    if (checkIsExpired && isExpired(delegation)) {\n        throw new Error(`Delegation expired.`);\n    }\n    if (checkIsTooEarly && isTooEarly(delegation)) {\n        throw new Error(`Delegation is not active yet (too early).`);\n    }\n}\n/**\n * Returns true if the delegation includes capability been queried.\n *\n * @param {API.Delegation} delegation\n * @param {API.CapabilityQuery} capability\n */\nexport function canDelegateCapability(delegation, capability) {\n    const allowsCapabilities = ucanto.Delegation.allows(delegation);\n    for (const [uri, abilities] of Object.entries(allowsCapabilities)) {\n        if (matchResource(/** @type {API.Resource} */ (uri), capability.with)) {\n            const cans = /** @type {API.Ability[]} */ (Object.keys(abilities));\n            for (const can of cans) {\n                if (canDelegateAbility(can, capability.can)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n/**\n * Returns true if given `resource` matches the resource query per UCAN\n * specification.\n *\n * @param {API.Resource} resource\n * @param {API.ResourceQuery} query\n */\nexport const matchResource = (resource, query) => {\n    if (query === 'ucan:*') {\n        return true;\n    }\n    else if (typeof query === 'string') {\n        return resource === query;\n    }\n    else {\n        return query.test(resource);\n    }\n};\n//# sourceMappingURL=delegations.js.map", "import { webcrypto } from 'one-webcrypto'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as API from './rsa/type.js'\nimport * as DID from '@ipld/dag-ucan/did'\nimport { tagWith, untagWith } from './multiformat.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as SPKI from './rsa/spki.js'\nimport * as PKCS8 from './rsa/pkcs8.js'\nimport * as PrivateKey from './rsa/private-key.js'\nimport * as PublicKey from './rsa/public-key.js'\nimport * as Verifier from './verifier.js'\nimport * as Signer from './signer.js'\nexport * from './rsa/type.js'\n\nexport const name = 'RSA'\n\n/** @type {API.RSASigner['code']} */\nexport const code = 0x1305\n\n/** @type {API.RSAVerifier['code']} */\nconst verifierCode = 0x1205\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.RS256\nexport const signatureAlgorithm = 'RS256'\n\nconst ALG = 'RSASSA-PKCS1-v1_5'\nconst HASH_ALG = 'SHA-256'\nconst KEY_SIZE = 2048\nconst SALT_LENGTH = 128\nconst IMPORT_PARAMS = {\n  name: ALG,\n  hash: { name: HASH_ALG },\n}\n\n/**\n * @param {object} options\n * @param {number} [options.size]\n * @param {boolean} [options.extractable]\n * @returns {Promise<API.RSASigner>}\n */\nexport const generate = async ({\n  size = KEY_SIZE,\n  extractable = false,\n} = {}) => {\n  // We start by generate an RSA keypair using web crypto API.\n  const { publicKey, privateKey } = await webcrypto.subtle.generateKey(\n    {\n      name: ALG,\n      modulusLength: size,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: HASH_ALG },\n    },\n\n    extractable,\n    ['sign', 'verify']\n  )\n\n  // Next we need to encode public key, because `RSAVerifier` uses it to\n  // for implementing a `did()` method. To do this we first export\n  // Subject Public Key Info (SPKI) using web crypto API.\n  const spki = await webcrypto.subtle.exportKey('spki', publicKey)\n  // Then we extract public key from the SPKI and tag it with RSA public key\n  // multicode\n  const publicBytes = tagWith(verifierCode, SPKI.decode(new Uint8Array(spki)))\n  // Now that we have publicKey and it's multiformat representation we can\n  // create a verifier.\n  const verifier = new RSAVerifier({ bytes: publicBytes, publicKey })\n\n  // If we generated non extractable key we just wrap actual keys and verifier\n  // in the RSASigner view.\n  if (!extractable) {\n    return new UnextractableRSASigner({\n      privateKey,\n      verifier,\n    })\n  }\n  // Otherwise we export key in Private Key Cryptography Standards (PKCS)\n  // format and extract a bytes corresponding to the private key, which\n  // we tag with RSA private key multiformat code. With both binary and actual\n  // key representation we create a RSASigner view.\n  // Please note that do key export flow during generation so that we can:\n  // 1. Guarantee that it will be exportable.\n  // 2. Make `export` method sync.\n  else {\n    const pkcs8 = await webcrypto.subtle.exportKey('pkcs8', privateKey)\n    const bytes = tagWith(code, PKCS8.decode(new Uint8Array(pkcs8)))\n    return new ExtractableRSASigner({\n      privateKey,\n      bytes,\n      verifier,\n    })\n  }\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.RSASigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const did = /** @type {API.DIDKey} */ (id)\n    const key = keys[did]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    } else {\n      return new UnextractableRSASigner({\n        privateKey: key,\n        verifier: RSAVerifier.parse(did),\n      })\n    }\n  } else {\n    throw new TypeError(\n      `RSA can not import from ${id} archive, try generic Signer instead`\n    )\n  }\n}\n\n/**\n * @template {API.SignerImporter} Other\n * @param {Other} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {EncodedSigner} bytes\n * @returns {API.RSASigner}\n */\nexport const decode = bytes => {\n  // First we decode RSA key data from the private key with multicode tag.\n  const rsa = PrivateKey.decode(untagWith(code, bytes))\n  // Then we encode RSA key data as public key with multicode tag.\n  const publicBytes = tagWith(verifierCode, PublicKey.encode(rsa))\n\n  return new ExtractableRSASigner({\n    bytes,\n    privateKey: webcrypto.subtle.importKey(\n      'pkcs8',\n      PKCS8.encode(untagWith(code, bytes)),\n      IMPORT_PARAMS,\n      true,\n      ['sign']\n    ),\n\n    verifier: RSAVerifier.decode(publicBytes),\n  })\n}\n\n/**\n * @implements {API.RSAVerifier}\n */\nclass RSAVerifier {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.publicKey\n   * @param {API.ByteView<API.RSAVerifier>} options.bytes\n   */\n  constructor({ publicKey, bytes }) {\n    /** @private */\n    this.publicKey = publicKey\n    /** @private */\n    this.bytes = bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n\n  /**\n   * @param {API.ByteView<API.RSAVerifier>} bytes\n   * @returns {API.RSAVerifier}\n   */\n  static decode(bytes) {\n    return new this({\n      bytes,\n      publicKey: webcrypto.subtle.importKey(\n        'spki',\n        SPKI.encode(untagWith(verifierCode, bytes)),\n        IMPORT_PARAMS,\n        true,\n        ['verify']\n      ),\n    })\n  }\n  /**\n   * @param {API.DIDKey} did\n   * @returns {API.RSAVerifier}\n   */\n  static parse(did) {\n    return RSAVerifier.decode(/** @type {Uint8Array} */ (DID.parse(did)))\n  }\n\n  /**\n   * @param {API.PrincipalParser} other\n   */\n  static or(other) {\n    return Verifier.or(this, other)\n  }\n\n  /** @type {typeof verifierCode} */\n  get code() {\n    return verifierCode\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this.bytes)}`\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   * @returns {Promise<boolean>}\n   */\n  async verify(payload, signature) {\n    // if signature code does not match RS256 it's not signed by corresponding\n    // signer.\n    if (signature.code !== signatureCode) {\n      return false\n    }\n\n    return webcrypto.subtle.verify(\n      { name: ALG, hash: { name: HASH_ALG } },\n      await this.publicKey,\n      signature.raw,\n      payload\n    )\n  }\n}\n\nconst RSAVerifier$ = /** @type {API.ComposedDIDParser} */ (RSAVerifier)\nexport { RSAVerifier as Verifier }\n\n/**\n * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner\n */\n\nclass RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor({ privateKey, verifier }) {\n    /** @readonly */\n    this.verifier = verifier\n    /** @protected */\n    this.privateKey = privateKey\n  }\n  get signer() {\n    return this\n  }\n\n  /**\n   * @type {typeof code}\n   */\n  get code() {\n    return code\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}\n   */\n  async sign(payload) {\n    const buffer = await webcrypto.subtle.sign(\n      { name: ALG, saltLength: SALT_LENGTH },\n      await this.privateKey,\n      payload\n    )\n\n    return Signature.create(signatureCode, new Uint8Array(buffer))\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass ExtractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {EncodedSigner} options.bytes\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.bytes = options.bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.bytes },\n    }\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass UnextractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {CryptoKey} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.privateKey = options.privateKey\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.privateKey },\n    }\n  }\n}\n", "const _globalReference = globalThis || window || self\n\nexport const webcrypto = _globalReference.crypto\n", "import { varint } from 'multiformats'\n\n/**\n *\n * @param {number} code\n * @param {Uint8Array} bytes\n */\nexport const tagWith = (code, bytes) => {\n  const offset = varint.encodingLength(code)\n  const multiformat = new Uint8Array(bytes.byteLength + offset)\n  varint.encodeTo(code, multiformat, 0)\n  multiformat.set(bytes, offset)\n\n  return multiformat\n}\n\n/**\n * @param {number} code\n * @param {Uint8Array} source\n * @param {number} byteOffset\n * @returns\n */\nexport const untagWith = (code, source, byteOffset = 0) => {\n  const bytes = byteOffset !== 0 ? source.subarray(byteOffset) : source\n  const [tag, size] = varint.decode(bytes)\n  if (tag !== code) {\n    throw new Error(\n      `Expected multiformat with 0x${code.toString(\n        16\n      )} tag instead got 0x${tag.toString(16)}`\n    )\n  } else {\n    return new Uint8Array(bytes.buffer, bytes.byteOffset + size)\n  }\n}\n\nexport const encodingLength = varint.encodingLength\nexport const encodeTo = varint.encodeTo\nexport const decode = varint.decode\n", "import * as API from '@ucanto/interface'\nimport {\n  encodeSequence,\n  encodeBitString,\n  enterSequence,\n  skipSequence,\n  readBitString,\n} from './asn1.js'\n\n/**\n * @typedef {import('./public-key.js').RSAPublicKey} RSAPublicKey\n */\n/**\n * Described in RFC 5208 Section 4.1: https://tools.ietf.org/html/rfc5280#section-4.1\n * ```\n * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n *    algorithm            AlgorithmIdentifier,\n *    subjectPublicKey     BIT STRING  }\n * ```\n *\n * @typedef {object} SubjectPublicKeyInfo\n * @property {API.ByteView<AlgorithmIdentifier>} algorithm\n * @property {API.ByteView<RSAPublicKey>} subjectPublicKey\n * @typedef {import('./pkcs8.js').AlgorithmIdentifier} AlgorithmIdentifier\n */\n\n/**\n * The ASN.1 DER encoded header that needs to be added to an\n * ASN.1 DER encoded RSAPublicKey to make it a SubjectPublicKeyInfo.\n *\n * This byte sequence is always the same.\n *\n * A human-readable version of this as part of a dumpasn1 dump:\n *\n *     SEQUENCE {\n *       OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)\n *       NULL\n *     }\n *\n * See https://github.com/ucan-wg/ts-ucan/issues/30\n */\nexport const SPKI_PARAMS_ENCODED = new Uint8Array([\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n\n/**\n * @param {API.ByteView<RSAPublicKey>} key\n * @returns {API.ByteView<SubjectPublicKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([SPKI_PARAMS_ENCODED, encodeBitString(key)])\n\n/**\n *\n * @param {API.ByteView<SubjectPublicKeyInfo>} info\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const decode = info => {\n  // go into the top-level SEQUENCE\n  const offset = enterSequence(info, 0)\n  // skip the header we expect (SKPI_PARAMS_ENCODED)\n  const keyOffset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readBitString(info, keyOffset)\n}\n", "/**\n * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst TAG_SIZE = 1\nexport const INT_TAG = 0x02\nexport const BITSTRING_TAG = 0x03\nexport const OCTET_STRING_TAG = 0x04\nexport const NULL_TAG = 0x05\nexport const OBJECT_TAG = 0x06\nexport const SEQUENCE_TAG = 0x30\n\nexport const UNUSED_BIT_PAD = 0x00\n\n/**\n * @param {number} length\n * @returns {Uint8Array}\n */\nexport const encodeDERLength = length => {\n  if (length <= 127) {\n    return new Uint8Array([length])\n  }\n\n  /** @type {number[]} */\n  const octets = []\n  while (length !== 0) {\n    octets.push(length & 0xff)\n    length = length >>> 8\n  }\n  octets.reverse()\n  return new Uint8Array([0x80 | (octets.length & 0xff), ...octets])\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {{number: number, consumed: number}}\n */\nexport const readDERLength = (bytes, offset = 0) => {\n  if ((bytes[offset] & 0x80) === 0) {\n    return { number: bytes[offset], consumed: 1 }\n  }\n\n  const numberBytes = bytes[offset] & 0x7f\n  /* c8 ignore next 5 */\n  if (bytes.length < numberBytes + 1) {\n    throw new Error(\n      `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`\n    )\n  }\n\n  let length = 0\n  for (let i = 0; i < numberBytes; i++) {\n    length = length << 8\n    length = length | bytes[offset + i + 1]\n  }\n\n  return { number: length, consumed: numberBytes + 1 }\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} position\n * @returns {number}\n */\nexport const skip = (input, expectedTag, position) => {\n  const parsed = into(input, expectedTag, position)\n  return parsed.position + parsed.length\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} offset\n * @returns {{ position: number, length: number }}\n */\nexport const into = (input, expectedTag, offset) => {\n  const actualTag = input[offset]\n  /* c8 ignore next 7 */\n  if (actualTag !== expectedTag) {\n    throw new Error(\n      `ASN parsing error: Expected tag 0x${expectedTag.toString(\n        16\n      )} at position ${offset}, but got 0x${actualTag.toString(16)}.`\n    )\n  }\n\n  // length\n  const length = readDERLength(input, offset + TAG_SIZE)\n  const position = offset + TAG_SIZE + length.consumed\n\n  // content\n  return { position, length: length.number }\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeBitString = input => {\n  // encode input length + 1 for unused bit pad\n  const length = encodeDERLength(input.byteLength + 1)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // ASN_BITSTRING_TAG\n      length.byteLength +\n      1 + // amount of unused bits at the end of our bitstring\n      input.byteLength\n  )\n\n  let byteOffset = 0\n  // write bytestring tag\n  bytes[byteOffset] = BITSTRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write length of the bytestring\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write unused bits at the end of our bitstring\n  bytes[byteOffset] = UNUSED_BIT_PAD\n  byteOffset += 1\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeOctetString = input => {\n  // encode input length\n  const length = encodeDERLength(input.byteLength)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength)\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = OCTET_STRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write octet string length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array[]} sequence\n */\nexport const encodeSequence = sequence => {\n  // calculate bytelength for all the parts\n  let byteLength = 0\n  for (const item of sequence) {\n    byteLength += item.byteLength\n  }\n\n  // encode sequence byte length\n  const length = encodeDERLength(byteLength)\n\n  // allocate the buffer to write sequence into\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength)\n\n  let byteOffset = 0\n\n  // write the sequence tag\n  bytes[byteOffset] = SEQUENCE_TAG\n  byteOffset += TAG_SIZE\n\n  // write sequence length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write each item in the sequence\n  for (const item of sequence) {\n    bytes.set(item, byteOffset)\n    byteOffset += item.byteLength\n  }\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nexport const readSequence = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, SEQUENCE_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeInt = input => {\n  const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0\n\n  // encode input length\n  const length = encodeDERLength(input.byteLength + extra)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // INT_TAG\n      length.byteLength +\n      input.byteLength +\n      extra\n  )\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = INT_TAG\n  byteOffset += TAG_SIZE\n\n  // write int length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // add 0 if the most-significant bit is set\n  if (extra > 0) {\n    bytes[byteOffset] = UNUSED_BIT_PAD\n    byteOffset += extra\n  }\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\n\nexport const enterSequence = (bytes, offset = 0) =>\n  into(bytes, SEQUENCE_TAG, offset).position\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipSequence = (bytes, offset = 0) =>\n  skip(bytes, SEQUENCE_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipInt = (bytes, offset = 0) => skip(bytes, INT_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readBitString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, BITSTRING_TAG, offset)\n  const tag = bytes[position]\n  /* c8 ignore next 5 */\n  if (tag !== UNUSED_BIT_PAD) {\n    throw new Error(\n      `Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`\n    )\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + 1,\n    length - 1\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} byteOffset\n * @returns {Uint8Array}\n */\nexport const readInt = (bytes, byteOffset = 0) => {\n  const { position, length } = into(bytes, INT_TAG, byteOffset)\n  let delta = 0\n\n  // drop leading 0s\n  while (bytes[position + delta] === 0) {\n    delta++\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + delta,\n    length - delta\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readOctetString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, OCTET_STRING_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @typedef {(bytes:Uint8Array, offset:number) => Uint8Array} Reader\n * @param {[Reader, ...Reader[]]} readers\n * @param {Uint8Array} source\n * @param {number} byteOffset\n */\nexport const readSequenceWith = (readers, source, byteOffset = 0) => {\n  const results = []\n  const sequence = readSequence(source, byteOffset)\n  let offset = 0\n  for (const read of readers) {\n    const chunk = read(sequence, offset)\n    results.push(chunk)\n    offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset\n  }\n  return results\n}\n", "import * as API from '@ucanto/interface'\nimport { base64url } from 'multiformats/bases/base64'\nimport {\n  encodeSequence,\n  encodeOctetString,\n  enterSequence,\n  skipSequence,\n  skipInt,\n  readOctetString,\n} from './asn1.js'\n\nconst PKSC8_HEADER = new Uint8Array([\n  // version\n  2, 1, 0,\n  // privateKeyAlgorithm\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n/**\n * @typedef {import('./private-key').RSAPrivateKey} RSAPrivateKey\n * @typedef {object} AlgorithmIdentifier\n * @property {Uint8Array} version\n * @property {Uint8Array} parameters\n *\n * @see https://datatracker.ietf.org/doc/html/rfc5208#section-5\n * @typedef {object} PrivateKeyInfo\n * @property {API.ByteView<number>} version\n * @property {API.ByteView<AlgorithmIdentifier>} privateKeyAlgorithm\n * @property {API.ByteView<RSAPrivateKey>} privateKey\n * @property {API.ByteView<unknown>} [attributes]\n */\n\n/**\n * @param {API.ByteView<PrivateKeyInfo>} info\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const decode = info => {\n  let offset = 0\n  // go into the top-level SEQUENCE\n  offset = enterSequence(info, offset)\n  offset = skipInt(info, offset)\n  offset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readOctetString(info, offset)\n}\n\n/**\n * @param {API.ByteView<RSAPrivateKey>} key\n * @returns {API.ByteView<PrivateKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([PKSC8_HEADER, encodeOctetString(key)])\n", "import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, readSequenceWith, encodeInt } from './asn1.js'\nimport { base64url } from 'multiformats/bases/base64'\nimport * as PKCS8 from './pkcs8.js'\nimport * as SPKI from './spki.js'\nimport * as PublicKey from './public-key.js'\n\nexport const code = 0x1305\nconst VERSION = new Uint8Array()\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2\n * @typedef {object} RSAPrivateKey\n * @property {Uint8Array} v\n * @property {Uint8Array} n\n * @property {Uint8Array} e\n * @property {Uint8Array} d\n * @property {Uint8Array} p\n * @property {Uint8Array} q\n * @property {Uint8Array} dp\n * @property {Uint8Array} dq\n * @property {Uint8Array} qi\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPrivateKey>} source\n * @param {number} byteOffset\n * @returns {RSAPrivateKey}\n */\nexport const decode = (source, byteOffset = 0) => {\n  const [v, n, e, d, p, q, dp, dq, qi] = readSequenceWith(\n    [\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n    ],\n    source,\n    byteOffset\n  )\n\n  return { v, n, e, d, p, q, dp, dq, qi }\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const encode = ({ v, n, e, d, p, q, dp, dq, qi }) => {\n  return encodeSequence([\n    encodeInt(v),\n    encodeInt(n),\n    encodeInt(e),\n    encodeInt(d),\n    encodeInt(p),\n    encodeInt(q),\n    encodeInt(dp),\n    encodeInt(dq),\n    encodeInt(qi),\n  ])\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['sign'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n  d: base64url.baseEncode(d),\n  p: base64url.baseEncode(p),\n  q: base64url.baseEncode(q),\n  dp: base64url.baseEncode(dp),\n  dq: base64url.baseEncode(dq),\n  qi: base64url.baseEncode(qi),\n})\n\n/**\n * @param {JsonWebKey} key\n * @returns {RSAPrivateKey}\n */\nexport const fromJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  v: VERSION,\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n  d: base64urlDecode(d),\n  p: base64urlDecode(p),\n  q: base64urlDecode(q),\n  dp: base64urlDecode(dp),\n  dq: base64urlDecode(dq),\n  qi: base64urlDecode(qi),\n})\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toPKCS8 = key => PKCS8.encode(encode(key))\n\n/**\n * @param {API.ByteView<PKCS8.PrivateKeyInfo>} info\n */\nexport const fromPKCS8 = info => decode(PKCS8.decode(info))\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toSPKI = key => SPKI.encode(PublicKey.encode(key))\n\n/**\n *\n * @param {string|undefined} input\n * @returns\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n", "import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, encodeInt, readSequenceWith } from './asn1.js'\nimport * as SPKI from './spki.js'\nimport { base64url } from 'multiformats/bases/base64'\n/**\n * RSA public key represenatation\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1\n *\n * @typedef {object} RSAPublicKey\n * @property {API.ByteView<number>} n\n * @property {API.ByteView<number>} e\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPublicKey>} key\n * @param {number} byteOffset\n * @returns {RSAPublicKey}\n */\nexport const decode = (key, byteOffset = 0) => {\n  const [n, e] = readSequenceWith([readInt, readInt], key, byteOffset)\n\n  return { n, e }\n}\n\n/**\n * @param {RSAPublicKey} key\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const encode = ({ n, e }) => encodeSequence([encodeInt(n), encodeInt(e)])\n\n/**\n * @param {RSAPublicKey} key\n */\nexport const toSPKI = key => SPKI.encode(encode(key))\n\n/**\n * @param {API.ByteView<SPKI.SubjectPublicKeyInfo>} info\n */\nexport const fromSPKI = info => decode(SPKI.decode(info))\n\n/**\n * @param {RSAPublicKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['verify'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n})\n\n/**\n * @param {JsonWebKey} jwk\n * @returns {RSAPublicKey}\n */\nexport const fromJWK = ({ n, e }) => ({\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n})\n\n/**\n * @param {string|undefined} input\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n", "import * as ed25519 from './ed25519.js'\nimport * as RSA from './rsa.js'\nimport * as Absentee from './absentee.js'\nexport * from './multiformat.js'\nexport const Verifier = ed25519.Verifier.or(RSA.Verifier)\nexport const Signer = ed25519.or(RSA)\n\n// exports\nexport { ed25519, RSA, Absentee }\n", "import { Signer } from '@ucanto/principal';\nimport { Signer as EdSigner } from '@ucanto/principal/ed25519';\nimport { importDAG } from '@ucanto/core/delegation';\nimport * as Ucanto from '@ucanto/interface';\nimport { CID } from 'multiformats';\nimport { UCAN } from '@storacha/capabilities';\nimport { isExpired } from './delegations.js';\nimport { uint8ArrayToArrayBuffer } from './utils/buffers.js';\n/** @typedef {import('./types.js').AgentDataModel} AgentDataModel */\n/** @implements {AgentDataModel} */\nexport class AgentData {\n    /** @type {(data: import('./types.js').AgentDataExport) => Promise<void> | void} */\n    #save;\n    /**\n     * @param {import('./types.js').AgentDataModel} data\n     * @param {import('./types.js').AgentDataOptions} [options]\n     */\n    constructor(data, options = {}) {\n        this.meta = data.meta;\n        this.principal = data.principal;\n        this.spaces = data.spaces;\n        this.delegations = data.delegations;\n        this.currentSpace = data.currentSpace;\n        this.#save = (data) => options.store ? options.store.save(data) : undefined;\n    }\n    /**\n     * Create a new AgentData instance from the passed initialization data.\n     *\n     * @param {Partial<import('./types.js').AgentDataModel>} [init]\n     * @param {import('./types.js').AgentDataOptions} [options]\n     */\n    static async create(init = {}, options = {}) {\n        const agentData = new AgentData({\n            meta: { name: 'agent', type: 'device', ...init.meta },\n            principal: init.principal ?? (await EdSigner.generate()),\n            spaces: init.spaces ?? new Map(),\n            delegations: init.delegations ?? new Map(),\n            currentSpace: init.currentSpace,\n        }, options);\n        if (options.store) {\n            await options.store.save(agentData.export());\n        }\n        return agentData;\n    }\n    /**\n     * Instantiate AgentData from previously exported data.\n     *\n     * @param {import('./types.js').AgentDataExport} raw\n     * @param {import('./types.js').AgentDataOptions} [options]\n     */\n    static fromExport(raw, options) {\n        /** @type {import('./types.js').AgentDataModel['delegations']} */\n        const dels = new Map();\n        for (const [key, value] of raw.delegations) {\n            dels.set(key, {\n                delegation: importDAG(value.delegation.map((d) => ({\n                    cid: CID.parse(d.cid).toV1(),\n                    bytes: d.bytes instanceof Uint8Array ? d.bytes : new Uint8Array(d.bytes),\n                }))),\n                meta: value.meta,\n            });\n        }\n        return new AgentData({\n            meta: raw.meta,\n            // @ts-expect-error for some reason TS thinks this is a EdSigner\n            principal: Signer.from(raw.principal),\n            currentSpace: raw.currentSpace,\n            spaces: raw.spaces,\n            delegations: dels,\n        }, options);\n    }\n    /**\n     * Export data in a format safe to pass to `structuredClone()`.\n     */\n    export() {\n        /** @type {import('./types.js').AgentDataExport} */\n        const raw = {\n            meta: this.meta,\n            principal: this.principal.toArchive(),\n            currentSpace: this.currentSpace,\n            spaces: this.spaces,\n            delegations: new Map(),\n        };\n        for (const [key, value] of this.delegations) {\n            raw.delegations.set(key, {\n                meta: value.meta,\n                delegation: [...value.delegation.export()].map((b) => ({\n                    cid: b.cid.toString(),\n                    bytes: uint8ArrayToArrayBuffer(b.bytes),\n                })),\n            });\n        }\n        return raw;\n    }\n    /**\n     * @param {import('@ucanto/interface').DID} did\n     * @param {import('./types.js').SpaceMeta} meta\n     * @param {import('@ucanto/interface').Delegation} [proof]\n     */\n    async addSpace(did, meta, proof) {\n        this.spaces.set(did, meta);\n        await (proof ? this.addDelegation(proof) : this.#save(this.export()));\n    }\n    /**\n     * @deprecated\n     * @param {import('@ucanto/interface').DID<'key'>} did\n     */\n    async setCurrentSpace(did) {\n        this.currentSpace = did;\n        await this.#save(this.export());\n    }\n    /**\n     * @param {import('@ucanto/interface').Delegation} delegation\n     * @param {import('./types.js').DelegationMeta} [meta]\n     */\n    async addDelegation(delegation, meta) {\n        this.delegations.set(delegation.cid.toString(), {\n            delegation,\n            meta: meta ?? {},\n        });\n        await this.#save(this.export());\n    }\n    /**\n     * @param {import('@ucanto/interface').UCANLink} cid\n     */\n    async removeDelegation(cid) {\n        this.delegations.delete(cid.toString());\n        await this.#save(this.export());\n    }\n}\n/**\n * Is the given capability a session attestation?\n *\n * @param {Ucanto.Capability} cap\n * @returns {boolean}\n */\nconst isSessionCapability = (cap) => cap.can === UCAN.attest.can;\n/**\n * Is the given delegation a session proof?\n *\n * @param {Ucanto.Delegation} delegation\n * @returns {delegation is Ucanto.Delegation<[import('./types.js').UCANAttest]>}\n */\nexport const isSessionProof = (delegation) => delegation.capabilities.some((cap) => isSessionCapability(cap));\n/**\n * @typedef {string} SessionProofAuthorizationCid - the nb.proof CID of the ucan/attest in the session proof\n * @typedef {Ucanto.DID} SessionProofIssuer - issuer of ucan/attest session proof\n * @typedef {Record<SessionProofAuthorizationCid, Record<SessionProofIssuer, [Ucanto.Delegation, ...Ucanto.Delegation[]]>>} SessionProofIndexedByAuthorizationAndIssuer\n */\n/**\n * Get a map from CIDs to the session proofs that reference them\n *\n * @param {AgentData} data\n * @returns {SessionProofIndexedByAuthorizationAndIssuer}\n */\nexport function getSessionProofs(data) {\n    /** @type {SessionProofIndexedByAuthorizationAndIssuer} */\n    const proofs = {};\n    for (const { delegation } of data.delegations.values()) {\n        if (isSessionProof(delegation)) {\n            const cap = delegation.capabilities[0];\n            if (cap && !isExpired(delegation)) {\n                const proof = cap.nb.proof;\n                if (proof) {\n                    const proofCid = proof.toString();\n                    const issuerDid = delegation.issuer.did();\n                    proofs[proofCid] = proofs[proofCid] ?? {};\n                    proofs[proofCid][issuerDid] = proofs[proofCid][issuerDid] ?? [];\n                    proofs[proofCid][issuerDid].push(delegation);\n                }\n            }\n        }\n    }\n    return proofs;\n}\n//# sourceMappingURL=agent-data.js.map", "import { capability, URI, Schema, ok } from '@ucanto/validator';\nimport { and, equal, equalLinkOrDigestContent, equalWith } from './utils.js';\nconst linkOrDigest = () => Schema.link().or(Schema.struct({ digest: Schema.bytes() }));\nexport const assert = capability({\n    can: 'assert/*',\n    with: URI.match({ protocol: 'did:' }),\n});\n/**\n * Claims that a CID is available at a URL.\n */\nexport const location = capability({\n    can: 'assert/location',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** Blob CID or multihash */\n        content: linkOrDigest(),\n        location: Schema.array(URI),\n        range: Schema.struct({\n            offset: Schema.integer(),\n            length: Schema.integer().optional(),\n        }).optional(),\n        space: Schema.principal().optional(),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalLinkOrDigestContent(claimed, delegated)) ||\n        and(equal(claimed.nb.location, delegated.nb.location, 'location')) ||\n        and(equal(claimed.nb.range?.offset, delegated.nb.range?.offset, 'offset')) ||\n        and(equal(claimed.nb.range?.length, delegated.nb.range?.length, 'length')) ||\n        and(equal(claimed.nb.space, delegated.nb.space, 'space')) ||\n        ok({}),\n});\n/**\n * Claims that a CID includes the contents claimed in another CID.\n */\nexport const inclusion = capability({\n    can: 'assert/inclusion',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** CAR CID */\n        content: linkOrDigest(),\n        /** CARv2 index CID */\n        includes: Schema.link({ version: 1 }),\n        proof: Schema.link({ version: 1 }).optional(),\n    }),\n});\n/**\n * Claims that a content graph can be found in blob(s) that are identified and\n * indexed in the given index CID.\n */\nexport const index = capability({\n    can: 'assert/index',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** DAG root CID */\n        content: linkOrDigest(),\n        /**\n         * Link to a Content Archive that contains the index.\n         * e.g. `index/sharded/dag@0.1`\n         *\n         * @see https://github.com/storacha/specs/blob/main/w3-index.md\n         */\n        index: Schema.link({ version: 1 }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equal(claimed.nb.content, delegated.nb.content, 'content')) ||\n        and(equal(claimed.nb.index, delegated.nb.index, 'index')) ||\n        ok({}),\n});\n/**\n * Claims that a CID's graph can be read from the blocks found in parts.\n */\nexport const partition = capability({\n    can: 'assert/partition',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** Content root CID */\n        content: linkOrDigest(),\n        /** CIDs CID */\n        blocks: Schema.link({ version: 1 }).optional(),\n        parts: Schema.array(Schema.link({ version: 1 })),\n    }),\n});\n/**\n * Claims that a CID links to other CIDs.\n */\nexport const relation = capability({\n    can: 'assert/relation',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        content: linkOrDigest(),\n        /** CIDs this content links to directly. */\n        children: Schema.array(Schema.link()),\n        /** Parts this content and it's children can be read from. */\n        parts: Schema.array(Schema.struct({\n            content: Schema.link({ version: 1 }),\n            /** CID of contents (CARv2 index) included in this part. */\n            includes: Schema.struct({\n                content: Schema.link({ version: 1 }),\n                /** CIDs of parts this index may be found in. */\n                parts: Schema.array(Schema.link({ version: 1 })).optional(),\n            }).optional(),\n        })),\n    }),\n});\n/**\n * Claim data is referred to by another CID and/or multihash.\n * e.g CAR CID & CommP CID\n */\nexport const equals = capability({\n    can: 'assert/equals',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        content: linkOrDigest(),\n        equals: Schema.link(),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalLinkOrDigestContent(claimed, delegated)) ||\n        and(equal(claimed.nb.equals, delegated.nb.equals, 'equals')) ||\n        ok({}),\n});\n//# sourceMappingURL=assert.js.map", "import { capability, URI, Schema, ok, fail } from '@ucanto/validator';\nimport * as Bytes from 'multiformats/bytes';\nimport { and, equal, equalWith } from './utils.js';\n/** @import * as API from '@ucanto/interface' */\nconst multiaddr = Schema.bytes();\nexport const claim = capability({\n    can: 'claim/*',\n    with: URI.match({ protocol: 'did:' }),\n});\n/**\n * Cache the provided content claim.\n */\nexport const cache = capability({\n    can: 'claim/cache',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        claim: Schema.link({ version: 1 }),\n        provider: Schema.struct({\n            addresses: Schema.array(multiaddr),\n        }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equal(claimed.nb.claim, delegated.nb.claim, 'claim')) ||\n        and(equalProviderAddresses(claimed, delegated)) ||\n        ok({}),\n});\n/**\n * @template {API.ParsedCapability<API.Ability, API.URI, { provider: { addresses: Uint8Array[] } }>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nconst equalProviderAddresses = (claimed, delegated) => {\n    if (delegated.nb?.provider?.addresses) {\n        const delegatedAddrs = delegated.nb.provider.addresses;\n        const claimedAddrs = claimed.nb?.provider?.addresses ?? [];\n        if (claimedAddrs.length !== delegatedAddrs.length) {\n            return fail(`Constraint violation: ${claimedAddrs.length} provider addresses violates imposed constraint ${delegatedAddrs.length} provider addresses`);\n        }\n        for (let i = 0; i < delegatedAddrs.length; i++) {\n            const addr = delegatedAddrs[i];\n            const found = claimedAddrs.some((a) => Bytes.equals(addr, a));\n            if (!found) {\n                return fail(`Constraint violation: provider address ${i} is not an allowed provider address`);\n            }\n        }\n    }\n    return ok({});\n};\n//# sourceMappingURL=claim.js.map", "import { capability, DID, struct, ok } from '@ucanto/validator';\nimport { equalWith, and, equal, SpaceDID } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\n/**\n * Capability can be invoked by a provider to check if it has given space as\n * a consumer.\n */\nexport const has = capability({\n    can: 'consumer/has',\n    with: ProviderDID,\n    nb: struct({\n        consumer: SpaceDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by a provider to get information about a consumer.\n */\nexport const get = capability({\n    can: 'consumer/get',\n    with: ProviderDID,\n    nb: struct({\n        consumer: SpaceDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=consumer.js.map", "import { capability, DID, struct, ok } from '@ucanto/validator';\nimport { AccountDID, equalWith, and, equal } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\n/**\n * Capability can be invoked by a provider to get information about the\n * customer.\n */\nexport const get = capability({\n    can: 'customer/get',\n    with: ProviderDID,\n    nb: struct({\n        customer: AccountDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.customer, parent.nb.customer, 'customer')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=customer.js.map", "import { capability, Schema } from '@ucanto/validator';\nimport { equalWith } from './utils.js';\nexport const console = capability({\n    can: 'console/*',\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * Capability that succeeds with the `nb.value` value.\n */\nexport const log = capability({\n    can: 'console/log',\n    with: Schema.did(),\n    nb: Schema.struct({\n        value: Schema.unknown(),\n    }),\n    derives: equalWith,\n});\n/**\n * Capability that fails with an error provided to `nb.error` field.\n */\nexport const error = capability({\n    can: 'console/error',\n    with: Schema.did(),\n    nb: Schema.struct({\n        error: Schema.unknown(),\n    }),\n    derives: equalWith,\n});\n//# sourceMappingURL=console.js.map", "/**\n * Rate Limit Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as RateLimit from '@storacha/capabilities/rate-limit'\n * ```\n *\n * @module\n */\nimport { capability, DID, struct, Schema, ok } from '@ucanto/validator';\nimport { equalWith, and, equal } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const Provider = DID;\n/**\n * Capability can be invoked by the provider or an authorized delegate to add a rate limit to a subject.\n */\nexport const add = capability({\n    can: 'rate-limit/add',\n    with: Provider,\n    nb: struct({\n        subject: Schema.string(),\n        rate: Schema.number(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.subject, parent.nb.subject, 'subject')) ||\n            and(equal(child.nb.rate, parent.nb.rate, 'rate')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by the provider are an authorized delegate to remove rate limits from a subject.\n */\nexport const remove = capability({\n    can: 'rate-limit/remove',\n    with: Provider,\n    nb: struct({\n        id: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.id, parent.nb.id, 'id')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by the provider or an authorized delegate to list rate limits on the given subject\n */\nexport const list = capability({\n    can: 'rate-limit/list',\n    with: Provider,\n    nb: struct({\n        subject: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.subject, parent.nb.subject, 'subject')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=rate-limit.js.map", "import { capability, struct, ok, Link } from '@ucanto/validator';\nimport { equalWith, and, equal, ProviderDID } from './utils.js';\nexport const admin = capability({\n    can: 'admin/*',\n    with: ProviderDID,\n    derives: equalWith,\n});\nexport const upload = {\n    /**\n     * Capability can be invoked by a provider to get information about a content CID.\n     */\n    inspect: capability({\n        can: 'admin/upload/inspect',\n        with: ProviderDID,\n        nb: struct({\n            root: Link,\n        }),\n        derives: (child, parent) => {\n            return (and(equalWith(child, parent)) ||\n                and(equal(child.nb.root, parent.nb.root, 'root')) ||\n                ok({}));\n        },\n    }),\n};\nexport const store = {\n    /**\n     * Capability can be invoked by a provider to get information an upload shard CID.\n     */\n    inspect: capability({\n        can: 'admin/store/inspect',\n        with: ProviderDID,\n        nb: struct({\n            link: Link,\n        }),\n        derives: (child, parent) => {\n            return (and(equalWith(child, parent)) ||\n                and(equal(child.nb.link, parent.nb.link, 'link')) ||\n                ok({}));\n        },\n    }),\n};\n//# sourceMappingURL=admin.js.map", "import { capability, DID, struct, ok, Schema } from '@ucanto/validator';\nimport { AccountDID, equalWith, and, equal } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\n/**\n * Capability can be invoked by a provider to get information about a subscription.\n */\nexport const get = capability({\n    can: 'subscription/get',\n    with: ProviderDID,\n    nb: struct({\n        subscription: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.subscription, parent.nb.subscription, 'consumer')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked to retrieve the list of subscriptions for an\n * account.\n */\nexport const list = capability({\n    can: 'subscription/list',\n    with: AccountDID,\n    derives: equalWith,\n});\n//# sourceMappingURL=subscription.js.map", "/**\n * Filecoin Capabilities\n *\n * These capabilities are the entrypoint to the filecoin pipeline and are\n * aliases for the filecoin storefront capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as Filecoin from '@storacha/capabilities/filecoin'\n * ```\n *\n * @module\n */\nexport { filecoinOffer as offer, filecoinSubmit as submit, filecoinAccept as accept, filecoinInfo as info, filecoin as filecoin, } from './storefront.js';\n//# sourceMappingURL=index.js.map", "import { Schema } from '@ucanto/validator';\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE = /** @type {const} */ (0x1011);\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst RAW_CODE = /** @type {const} */ (0x55);\nexport const PieceLink = /** @type {import('../types.js').PieceLinkSchema} */ (Schema.link({\n    code: RAW_CODE,\n    version: 1,\n    multihash: {\n        code: FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE,\n    },\n}));\n//# sourceMappingURL=lib.js.map", "/**\n * Filecoin Storefront Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Storefront from '@storacha/capabilities/filecoin/storefront'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equalWith, checkLink, and } from '../utils.js';\n/**\n * Top-level capability for Filecoin operations.\n */\nexport const filecoin = capability({\n    can: 'filecoin/*',\n    /**\n     * DID of the space the content is stored in.\n     */\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * Capability allowing an agent to _request_ storing a content piece in\n * Filecoin.\n */\nexport const filecoinOffer = capability({\n    can: 'filecoin/offer',\n    /**\n     * DID of the space the content is stored in.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content that resulted in Filecoin piece.\n         */\n        content: Schema.link(),\n        /**\n         * CID of the piece.\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n/**\n * Capability allowing a Storefront to signal that an offered piece has been\n * submitted to the filecoin storage pipeline.\n */\nexport const filecoinSubmit = capability({\n    can: 'filecoin/submit',\n    /**\n     * DID of the Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content that resulted in Filecoin piece.\n         */\n        content: Schema.link(),\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n/**\n * Capability allowing a Storefront to signal that a submitted piece has been\n * accepted in a Filecoin deal. The receipt contains the proof.\n */\nexport const filecoinAccept = capability({\n    can: 'filecoin/accept',\n    /**\n     * DID of the Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content that resulted in Filecoin piece.\n         */\n        content: Schema.link(),\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n/**\n * Capability allowing an agent to _request_ info about a content piece in\n * Filecoin deals.\n */\nexport const filecoinInfo = capability({\n    can: 'filecoin/info',\n    /**\n     * DID of the space the content is stored in.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=storefront.js.map", "/**\n * Filecoin Aggregator Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Aggregator from '@storacha/capabilities/filecoin/aggregator'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equal, equalWith, checkLink, and } from '../utils.js';\n/**\n * Capability that allows a Storefront to request that a piece be aggregated\n * for inclusion in an upcoming an Filecoin deal.\n */\nexport const pieceOffer = capability({\n    can: 'piece/offer',\n    /**\n     * DID of an authorized Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         */\n        piece: PieceLink,\n        /**\n         * Grouping of joining segments into an aggregate.\n         */\n        group: Schema.text(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n            ok({}));\n    },\n});\n/**\n * Capability that allows an Aggregator to signal a piece has been accepted\n * or rejected for inclusion in an aggregate.\n */\nexport const pieceAccept = capability({\n    can: 'piece/accept',\n    /**\n     * DID of the Aggregator.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n        /**\n         * Grouping of joining segments into an aggregate.\n         */\n        group: Schema.text(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=aggregator.js.map", "/**\n * Filecoin Dealer Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Dealer from '@storacha/capabilities/filecoin/dealer'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equalWith, checkLink, and } from '../utils.js';\n/**\n * Capability allowing an Aggregator to request an aggregate to be added to a\n * deal with a Storage Provider.\n */\nexport const aggregateOffer = capability({\n    can: 'aggregate/offer',\n    /**\n     * DID of an authorized Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Commitment proof for the aggregate being offered.\n         */\n        aggregate: PieceLink,\n        /**\n         * CID of the DAG-CBOR encoded block with offer details.\n         * Service will queue given offer to be validated and handled.\n         */\n        pieces: Schema.link({ version: 1 }),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n            and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n            ok({}));\n    },\n});\n/**\n * Capability that allows a Dealer to signal an aggregate has been accepted\n * for inclusion in a Filecoin deal.\n */\nexport const aggregateAccept = capability({\n    can: 'aggregate/accept',\n    /**\n     * did:key identifier of the broker authority where offer is made available.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Commitment proof for the aggregate being offered.\n         */\n        aggregate: PieceLink,\n        /**\n         * CID of the DAG-CBOR encoded block with offer details.\n         * Service will queue given offer to be validated and handled.\n         */\n        pieces: Schema.link(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n            and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=dealer.js.map", "/**\n * Filecoin Deal Tracker Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as DealTracker from '@storacha/capabilities/filecoin/deal-tracker'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equalWith, checkLink, and } from '../utils.js';\n/**\n * Capability allowing a Storefront or Aggregator to obtain deal information\n * for a given aggregate piece.\n */\nexport const dealInfo = capability({\n    can: 'deal/info',\n    /**\n     * DID of the Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=deal-tracker.js.map", "/**\n * Index Capabilities.\n *\n * W3 Indexing protocol allows authorized agents to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n *\n * These can be imported directly with:\n * ```js\n * import * as Index from '@storacha/capabilities/space/index'\n * ```\n *\n * @module\n */\nimport { CAR as SpaceIndex } from '@ucanto/core';\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { equalWith, SpaceDID, and, equal } from '../utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derive any `space/index/` prefixed capability for the space identified by the DID\n * in the `with` field.\n */\nexport const index = capability({\n    can: 'space/index/*',\n    /** DID of the space where indexed data is stored. */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `space/index/add` capability allows an agent to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n */\nexport const add = capability({\n    can: 'space/index/add',\n    /** DID of the space where indexed data is stored. */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** Content Archive (CAR) containing the `Index`. */\n        index: Schema.link({ code: SpaceIndex.code, version: 1 }),\n        /** The content root CID - the root of the DAG that is indexed. */\n        content: Schema.link().optional(),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equal(claimed.nb.index, delegated.nb.index, 'index')) ||\n        ok({}),\n});\n//  We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema };\n//# sourceMappingURL=index.js.map", "import { DID, Schema, capability, ok, struct } from '@ucanto/validator';\nimport { AccountDID, equal, equalWith, and } from './utils.js';\n/**\n * Capability can be invoked by an account to get information about\n * the plan it is currently signed up for.\n */\nexport const get = capability({\n    can: 'plan/get',\n    with: AccountDID,\n    derives: (child, parent) => {\n        return and(equalWith(child, parent)) || ok({});\n    },\n});\n/**\n * Capability can be invoked by an account to change its billing plan.\n */\nexport const set = capability({\n    can: 'plan/set',\n    with: AccountDID,\n    nb: struct({\n        product: DID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.product, parent.nb.product, 'product')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by an account to generate a billing admin session.\n *\n * May not be possible with all billing providers - this is designed with\n * https://docs.stripe.com/api/customer_portal/sessions/create in mind.\n */\nexport const createAdminSession = capability({\n    can: 'plan/create-admin-session',\n    with: AccountDID,\n    nb: struct({\n        returnURL: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.returnURL, parent.nb.returnURL, 'returnURL')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=plan.js.map", "import { capability, ok, Schema } from '@ucanto/validator';\nimport { and, equal, equalWith, SpaceDID } from './utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * be derived any `usage/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const usage = capability({\n    can: 'usage/*',\n    /** DID of the (memory) space where usage is derived. */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Capability can be invoked by an agent to retrieve usage data for a space in\n * a given period.\n */\nexport const report = capability({\n    can: 'usage/report',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** Period to retrieve events between. */\n        period: Schema.struct({\n            /** Time in seconds after Unix epoch (inclusive). */\n            from: Schema.integer().greaterThan(-1),\n            /** Time in seconds after Unix epoch (exclusive). */\n            to: Schema.integer().greaterThan(-1),\n        }),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.period?.from, parent.nb.period?.from, 'period.from')) ||\n            and(equal(child.nb.period?.to, parent.nb.period?.to, 'period.to')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=usage.js.map", "/**\n * Blob Capabilities.\n *\n * Blob is a fixed size byte array addressed by the multihash.\n * Usually blobs are used to represent set of IPLD blocks at different byte ranges.\n *\n * These can be imported directly with:\n * ```js\n * import * as Blob from '@storacha/capabilities/space/blob'\n * ```\n *\n * @module\n */\nimport { equals } from 'multiformats/bytes';\nimport { capability, Schema, fail, ok } from '@ucanto/validator';\nimport { equalBlob, equalWith, SpaceDID, and, equal, checkLink, } from '../utils.js';\n/**\n * Agent capabilities for Blob protocol\n */\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `space/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n    can: 'space/blob/*',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Blob description for being ingested by the service.\n */\nexport const content = Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n    /**\n     * Number of bytes contained by this blob. Service will provision write target\n     * for this exact size. Attempt to write a larger Blob file will fail.\n     */\n    size: Schema.integer(),\n});\n/**\n * `space/blob/add` capability allows agent to store a Blob into a (memory) space\n * identified by did:key in the `with` field. Agent should compute blob multihash\n * and size and provide it under `nb.blob` field, allowing a service to provision\n * a write location for the agent to PUT desired Blob into.\n */\nexport const add = capability({\n    can: 'space/blob/add',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Blob to be added on the space.\n         */\n        blob: content,\n    }),\n    derives: equalBlob,\n});\n/**\n * Capability can be used to remove the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n    can: 'space/blob/remove',\n    /**\n     * DID of the (memory) space where Blob is stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A multihash digest of the blob payload bytes, uniquely identifying blob.\n         */\n        digest: Schema.bytes(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        else if (delegated.nb.digest &&\n            !equals(delegated.nb.digest, claimed.nb.digest)) {\n            return fail(`Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ''} violates imposed ${delegated.nb.digest} constraint.`);\n        }\n        return ok({});\n    },\n});\n/**\n * Capability can be invoked to request a list of stored Blobs in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n    can: 'space/blob/list',\n    /**\n     * DID of the (memory) space where Blobs to be listed are stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A pointer that can be moved back and forth on the list.\n         * It can be used to paginate a list for instance.\n         */\n        cursor: Schema.string().optional(),\n        /**\n         * Maximum number of items per page.\n         */\n        size: Schema.integer().optional(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        return ok({});\n    },\n});\n/**\n * Capability can be used to get the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const get = capability({\n    can: 'space/blob/get/0/1',\n    /**\n     * DID of the (memory) space where Blob is stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A multihash digest of the blob payload bytes, uniquely identifying blob.\n         */\n        digest: Schema.bytes(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        else if (delegated.nb.digest &&\n            !equals(delegated.nb.digest, claimed.nb.digest)) {\n            return fail(`Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ''} violates imposed ${delegated.nb.digest} constraint.`);\n        }\n        return ok({});\n    },\n});\n/**\n * The `space/blob/replicate` capability allows an agent to replicate a Blob\n * into a space identified by did:key in the `with` field.\n *\n * A replicate capability may only be invoked after a `blob/accept` receipt has\n * been receieved, indicating the source node has successfully received the\n * blob.\n *\n * Each Replicate task MUST target a different node, and they MUST NOT target\n * the original upload target.\n *\n * The Replicate task receipt includes async tasks for `blob/replica/allocate`\n * and `blob/replica/transfer`. Successful completion of the\n * `blob/replica/transfer` task indicates the replication target has transferred\n * and stored the blob. The number of `blob/replica/allocate` and\n * `blob/replica/transfer` tasks corresponds directly to number of replicas\n * requested.\n */\nexport const replicate = capability({\n    can: 'space/blob/replicate',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** Blob to replicate. */\n        blob: content,\n        /**\n         * The number of replicas to ensure. e.g. `replicas: 2` will ensure 2 copies\n         * of the data exist in the network.\n         */\n        replicas: Schema.integer().greaterThan(0),\n        /** Link to a location commitment indicating where the Blob must be fetched from. */\n        site: Schema.link({ version: 1 }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalBlob(claimed, delegated)) ||\n        and(equal(claimed.nb.replicas, delegated.nb.replicas, 'replicas')) ||\n        and(checkLink(claimed.nb.site, delegated.nb.site, 'site')) ||\n        ok({}),\n});\n//  We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema };\n//# sourceMappingURL=blob.js.map", "/**\n * Blob Capabilities.\n *\n * The blob protocol allows authorized agents allocate memory space on a storage\n * node and subsequently verify the content has been accepted by / delivered to\n * said node.\n *\n * These can be imported directly with:\n * ```js\n * import * as Index from '@storacha/capabilities/blob'\n * ```\n *\n * @module\n * @see https://github.com/storacha/specs/blob/main/w3-blob.md\n */\nimport { capability, Schema, Link, ok } from '@ucanto/validator';\nimport { content } from '../space/blob.js';\nimport { equalBlob, equalWith, and, equal, checkLink, Await } from '../utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derive any `blob/` prefixed capability.\n */\nexport const blob = capability({\n    can: 'blob/*',\n    /** Storage provider DID. */\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * The `blob/allocate` capability can be invoked to create a memory address on a\n * storage node where blob content can be written via a HTTP PUT request.\n */\nexport const allocate = capability({\n    can: 'blob/allocate',\n    /** Storage provider DID. */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /** Blob to allocate. */\n        blob: content,\n        /** Link to the add blob task that initiated the allocation. */\n        cause: Schema.link({ version: 1 }),\n        /** DID of the user space where the allocation takes place. */\n        space: Schema.principal({ method: 'key' }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalBlob(claimed, delegated)) ||\n        and(checkLink(claimed.nb.cause, delegated.nb.cause, 'cause')) ||\n        and(equal(claimed.nb.space?.did(), delegated.nb.space?.did(), 'space')) ||\n        ok({}),\n});\n/**\n * The `blob/accept` capability invocation should either succeed when content is\n * delivered on allocated address or fail if no content is allocation expires\n * without content being delivered.\n */\nexport const accept = capability({\n    can: 'blob/accept',\n    /** Storage provider DID. */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /** Blob to accept. */\n        blob: content,\n        /** DID of the user space where allocation took place. */\n        space: Schema.principal({ method: 'key' }),\n        /** This task is blocked on `http/put` receipt available */\n        _put: Await,\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalBlob(claimed, delegated)) ||\n        and(equal(claimed.nb.space?.did(), delegated.nb.space?.did(), 'space')) ||\n        ok({}),\n});\n//  We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };\n//# sourceMappingURL=index.js.map", "import { capability, Schema, Link, ok } from '@ucanto/validator';\nimport { content } from '../space/blob.js';\nimport { equalBlob, equalWith, SpaceDID, and, equal, checkLink, Await, } from '../utils.js';\n/**\n * Service capabilities for Blob protocol\n */\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `web3.storage/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n *\n * @deprecated These capabilities were used by w3up to invoke on itself.\n */\nexport const blob = capability({\n    can: 'web3.storage/blob/*',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `web3.storage/blob//allocate` capability can be invoked to create a memory\n * address where blob content can be written via HTTP PUT request.\n *\n * @deprecated These capabilities were used by w3up to invoke on itself.\n */\nexport const allocate = capability({\n    can: 'web3.storage/blob/allocate',\n    /**\n     * Provider DID.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Blob to allocate on the space.\n         */\n        blob: content,\n        /**\n         * The Link for an Add Blob task, that caused an allocation\n         */\n        cause: Link,\n        /**\n         * DID of the user space where allocation takes place\n         */\n        space: SpaceDID,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equalBlob(claim, from)) ||\n            and(checkLink(claim.nb.cause, from.nb.cause, 'cause')) ||\n            and(equal(claim.nb.space, from.nb.space, 'space')) ||\n            ok({}));\n    },\n});\n/**\n * `blob/accept` capability invocation should either succeed when content is\n * delivered on allocated address or fail if no content is allocation expires\n * without content being delivered.\n *\n * @deprecated These capabilities were used by w3up to invoke on itself.\n */\nexport const accept = capability({\n    can: 'web3.storage/blob/accept',\n    /**\n     * Provider DID.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Blob to accept.\n         */\n        blob: content,\n        /**\n         * Content location commitment time to live, which will be encoded as expiry of the issued location claim.\n         */\n        ttl: Schema.integer().optional(),\n        /**\n         * DID of the user space where allocation took place\n         */\n        space: SpaceDID,\n        /**\n         * This task is blocked on `http/put` receipt available\n         */\n        _put: Await,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equalBlob(claim, from)) ||\n            and(equal(claim.nb.ttl, from.nb.ttl, 'ttl')) ||\n            and(equal(claim.nb.space, from.nb.space, 'space')) ||\n            ok({}));\n    },\n});\n//  We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };\n//# sourceMappingURL=blob.js.map", "/**\n * HTTP Capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as HTTP from '@storacha/capabilities/http'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { content } from './space/blob.js';\nimport { equal, equalBody, equalWith, SpaceDID, Await, and } from './utils.js';\n/**\n * `http/put` capability invocation MAY be performed by any authorized agent on behalf of the subject\n * as long as they have referenced `body` content to do so.\n */\nexport const put = capability({\n    can: 'http/put',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Description of body to send (digest/size).\n         */\n        body: content,\n        /**\n         * HTTP(S) location that can receive blob content via HTTP PUT request.\n         */\n        url: Schema.string().or(Await),\n        /**\n         * HTTP headers.\n         */\n        headers: Schema.dictionary({ value: Schema.string() }).or(Await),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equalBody(claim, from)) ||\n            and(equal(claim.nb.url, from.nb, 'url')) ||\n            and(equal(claim.nb.headers, from.nb, 'headers')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=http.js.map", "import { capability, fail, ok, Schema } from '@ucanto/validator';\nimport { AccountDID, SpaceDID, equalWith, and, equal, containedWithin, } from '../utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * be derived any `account/usage/` prefixed capability for the account identified\n * by DID in the `with` field.\n */\nexport const accountUsage = capability({\n    can: 'account/usage/*',\n    with: AccountDID,\n    derives: equalWith,\n});\n/**\n * Capability can be invoked by an agent to retrieve usage data for all or a\n * specified set of spaces within an account in a given period.\n */\nexport const get = capability({\n    can: 'account/usage/get',\n    with: AccountDID,\n    nb: Schema.struct({\n        spaces: SpaceDID.array().optional(),\n        /** Period to retrieve events between. */\n        period: Schema.struct({\n            /** Time in seconds after Unix epoch (inclusive). */\n            from: Schema.integer().greaterThan(-1),\n            /** Time in seconds after Unix epoch (exclusive). */\n            to: Schema.integer().greaterThan(-1),\n        }).optional(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and((() => {\n                if (parent.nb.spaces === undefined) {\n                    return ok({});\n                }\n                if (child.nb.spaces === undefined) {\n                    return fail(`Constraint violation: violates imposed spaces constraint ${parent.nb.spaces} because it asks for all spaces`);\n                }\n                return containedWithin(child.nb.spaces, parent.nb.spaces, 'spaces');\n            })()) ||\n            and(equal(child.nb.period?.from, parent.nb.period?.from, 'period.from')) ||\n            and(equal(child.nb.period?.to, parent.nb.period?.to, 'period.to')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=usage.js.map", "import * as Assert from './assert.js';\nimport * as Claim from './claim.js';\nimport * as Provider from './provider.js';\nimport * as Space from './space.js';\nimport * as Top from './top.js';\nimport * as Store from './store.js';\nimport * as Upload from './upload.js';\nimport * as Access from './access.js';\nimport * as Utils from './utils.js';\nimport * as Consumer from './consumer.js';\nimport * as Customer from './customer.js';\nimport * as Console from './console.js';\nimport * as RateLimit from './rate-limit.js';\nimport * as Admin from './admin.js';\nimport * as Subscription from './subscription.js';\nimport * as Filecoin from './filecoin/index.js';\nimport * as Storefront from './filecoin/storefront.js';\nimport * as Aggregator from './filecoin/aggregator.js';\nimport * as Dealer from './filecoin/dealer.js';\nimport * as DealTracker from './filecoin/deal-tracker.js';\nimport * as SpaceIndex from './space/index.js';\nimport * as UCAN from './ucan.js';\nimport * as Plan from './plan.js';\nimport * as Usage from './usage.js';\nimport * as Blob from './blob/index.js';\nimport * as SpaceBlob from './space/blob.js';\nimport * as W3sBlob from './web3.storage/blob.js';\nimport * as HTTP from './http.js';\nimport * as AccountUsage from './account/usage.js';\nexport { Access, Assert, Claim, Provider, Space, Top, Store, Upload, Consumer, Customer, Console, Utils, RateLimit, Subscription, Filecoin, SpaceIndex, Storefront, Aggregator, Dealer, DealTracker, Admin, UCAN, Plan, Usage, Blob, SpaceBlob, W3sBlob, HTTP, AccountUsage, };\n/** @type {import('./types.js').ServiceAbility[]} */\nexport const abilitiesAsStrings = [\n    Top.top.can,\n    Assert.assert.can,\n    Assert.equals.can,\n    Assert.inclusion.can,\n    Assert.index.can,\n    Assert.location.can,\n    Assert.partition.can,\n    Assert.relation.can,\n    Claim.claim.can,\n    Claim.cache.can,\n    Provider.add.can,\n    Space.space.can,\n    Space.info.can,\n    Space.EncryptionSetup.can,\n    Space.EncryptionKeyDecrypt.can,\n    Upload.upload.can,\n    Upload.add.can,\n    Upload.get.can,\n    Upload.remove.can,\n    Upload.list.can,\n    Store.store.can,\n    Store.add.can,\n    Store.get.can,\n    Store.remove.can,\n    Store.list.can,\n    Access.access.can,\n    Access.authorize.can,\n    UCAN.attest.can,\n    UCAN.conclude.can,\n    Customer.get.can,\n    Consumer.has.can,\n    Consumer.get.can,\n    Subscription.get.can,\n    Subscription.list.can,\n    RateLimit.add.can,\n    RateLimit.remove.can,\n    RateLimit.list.can,\n    Storefront.filecoinOffer.can,\n    Storefront.filecoinSubmit.can,\n    Storefront.filecoinAccept.can,\n    Storefront.filecoinInfo.can,\n    Aggregator.pieceOffer.can,\n    Aggregator.pieceAccept.can,\n    Dealer.aggregateOffer.can,\n    Dealer.aggregateAccept.can,\n    DealTracker.dealInfo.can,\n    Admin.admin.can,\n    Admin.upload.inspect.can,\n    Admin.store.inspect.can,\n    Plan.get.can,\n    Plan.set.can,\n    Plan.createAdminSession.can,\n    Usage.usage.can,\n    Usage.report.can,\n    Blob.blob.can,\n    Blob.allocate.can,\n    Blob.accept.can,\n    SpaceBlob.blob.can,\n    SpaceBlob.add.can,\n    SpaceBlob.remove.can,\n    SpaceBlob.list.can,\n    W3sBlob.blob.can,\n    W3sBlob.allocate.can,\n    W3sBlob.accept.can,\n    HTTP.put.can,\n    SpaceIndex.index.can,\n    SpaceIndex.add.can,\n    AccountUsage.get.can,\n];\n//# sourceMappingURL=index.js.map", "/**\n * Convert a Uint8Array to an ArrayBuffer, taking into account\n * that we may be looking at a \"data view\".\n * thanks, https://stackoverflow.com/a/54646864\n *\n * If we aren't looking at a data view, simply returns the underlying ArrayBuffer\n * directly.\n *\n * @param {Uint8Array} array\n * @returns ArrayBuffer\n */\nexport function uint8ArrayToArrayBuffer(array) {\n    if (array.byteOffset === 0 && array.byteLength === array.buffer.byteLength) {\n        return array.buffer;\n    }\n    else {\n        return array.buffer.slice(array.byteOffset, array.byteLength + array.byteOffset);\n    }\n}\n//# sourceMappingURL=buffers.js.map", "import { addSpacesFromDelegations, Agent as AccessAgent } from './agent.js';\nimport * as Access from '@storacha/capabilities/access';\nimport { bytesToDelegations } from './encoding.js';\nimport { Provider, Plan } from '@storacha/capabilities';\nimport * as w3caps from '@storacha/capabilities';\nimport { Schema, delegate } from '@ucanto/core';\nimport { AgentData, isSessionProof } from './agent-data.js';\nimport * as DidMailto from '@storacha/did-mailto';\nimport * as API from './types.js';\nconst DIDWeb = Schema.DID.match({ method: 'web' });\n/**\n * Request access by a session allowing this agent to issue UCANs\n * signed by the account.\n *\n * @param {AccessAgent} access\n * @param {API.Principal<API.AccountDID>} account\n * @param {Iterable<{ can: API.Ability }>} capabilities\n */\nexport async function requestAccess(access, account, capabilities) {\n    const res = await access.invokeAndExecute(Access.authorize, {\n        audience: access.connection.id,\n        with: access.issuer.did(),\n        nb: {\n            iss: account.did(),\n            att: [...capabilities],\n        },\n    });\n    if (res?.out.error) {\n        throw res.out.error;\n    }\n}\n/**\n * claim delegations delegated to an audience\n *\n * @param {AccessAgent} access\n * @param {API.DID} [audienceOfClaimedDelegations] - audience of claimed delegations. defaults to access.connection.id.did()\n * @param {object} opts\n * @param {string} [opts.nonce] - nonce to use for the claim\n * @param {boolean} [opts.addProofs] - whether to addProof to access agent\n */\nexport async function claimAccess(access, audienceOfClaimedDelegations = access.connection.id.did(), { addProofs = false, nonce } = {}) {\n    const res = await access.invokeAndExecute(Access.claim, {\n        audience: access.connection.id,\n        with: audienceOfClaimedDelegations,\n        nonce,\n    });\n    if (res.out.error) {\n        throw res.out.error;\n    }\n    const delegations = Object.values(res.out.ok.delegations).flatMap((bytes) => bytesToDelegations(bytes));\n    if (addProofs) {\n        for (const d of delegations) {\n            await access.addProof(d);\n        }\n        await addSpacesFromDelegations(access, delegations);\n    }\n    return delegations;\n}\n/**\n * @param {object} opts\n * @param {AccessAgent} opts.access\n * @param {API.SpaceDID} opts.space\n * @param {API.Principal<API.AccountDID>} opts.account\n * @param {API.ProviderDID} opts.provider - e.g. 'did:web:staging.storacha.network'\n */\nexport async function addProvider({ access, space, account, provider }) {\n    const result = await access.invokeAndExecute(Provider.add, {\n        audience: access.connection.id,\n        with: account.did(),\n        nb: {\n            provider,\n            consumer: space,\n        },\n    });\n    if (result.out.error) {\n        throw result.out.error;\n    }\n}\n/**\n * @typedef {(delegations: API.Delegation[]) => boolean} DelegationsChecker\n */\n/**\n * @type DelegationsChecker\n */\nexport function delegationsIncludeSessionProof(delegations) {\n    return delegations.some((d) => isSessionProof(d));\n}\n/**\n * @param {DelegationsChecker} delegationsMatch\n * @param {AccessAgent} access\n * @param {API.DID} delegee\n * @param {object} [opts]\n * @param {number} [opts.interval]\n * @param {AbortSignal} [opts.signal]\n * @returns {Promise<Iterable<API.Delegation>>}\n */\nexport async function pollAccessClaimUntil(delegationsMatch, access, delegee, opts) {\n    const interval = opts?.interval || 250;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        if (opts?.signal?.aborted)\n            throw opts.signal.reason ?? new Error('operation aborted');\n        const res = await access.invokeAndExecute(w3caps.Access.claim, {\n            with: delegee,\n        });\n        if (res.out.error)\n            throw res.out.error;\n        const claims = Object.values(res.out.ok.delegations).flatMap((d) => bytesToDelegations(d));\n        if (delegationsMatch(claims))\n            return claims;\n        await new Promise((resolve) => setTimeout(resolve, interval));\n    }\n}\n/**\n * @template [T={}]\n * @typedef {{ signal?: AbortSignal } & T} AuthorizationWaiterOpts\n */\n/**\n * @template [U={}]\n * @typedef {(accessAgent: AccessAgent, opts: AuthorizationWaiterOpts<U>) => Promise<Iterable<API.Delegation>>} AuthorizationWaiter\n */\n/**\n * Wait for authorization process to complete by polling executions of the\n * `access/claim` capability and waiting for the result to include\n * a session delegation.\n *\n * @type AuthorizationWaiter<{interval?: number}>\n */\nexport async function waitForAuthorizationByPolling(access, opts = {}) {\n    const claimed = await pollAccessClaimUntil(delegationsIncludeSessionProof, access, access.issuer.did(), {\n        signal: opts?.signal,\n        interval: opts?.interval,\n    });\n    return [...claimed];\n}\n/**\n * Request authorization of a session allowing this agent to issue UCANs\n * signed by the passed email address.\n *\n * @param {AccessAgent} access\n * @param {`${string}@${string}`} email\n * @param {object} [opts]\n * @param {AbortSignal} [opts.signal]\n * @param {boolean} [opts.dontAddProofs] - whether to skip adding proofs to the agent\n * @param {Iterable<{ can: API.Ability }>} [opts.capabilities]\n * @param {AuthorizationWaiter} [opts.expectAuthorization] - function that will resolve once account has confirmed the authorization request\n */\nexport async function authorizeAndWait(access, email, opts = {}) {\n    const expectAuthorization = opts.expectAuthorization || waitForAuthorizationByPolling;\n    const account = { did: () => DidMailto.fromEmail(email) };\n    await requestAccess(access, account, opts?.capabilities || [\n        { can: 'space/*' },\n        { can: 'store/*' },\n        { can: 'provider/add' },\n        { can: 'subscription/list' },\n        { can: 'upload/*' },\n        { can: 'ucan/*' },\n        { can: 'plan/*' },\n        { can: 'usage/*' },\n        { can: 'w3up/*' },\n    ]);\n    const sessionDelegations = [...(await expectAuthorization(access, opts))];\n    if (!opts?.dontAddProofs) {\n        await Promise.all(sessionDelegations.map(async (d) => access.addProof(d)));\n    }\n}\n/**\n * Request authorization of a session allowing this agent to issue UCANs\n * signed by the passed email address.\n *\n * @param {AccessAgent} accessAgent\n * @param {`${string}@${string}`} email\n * @param {object} [opts]\n * @param {AbortSignal} [opts.signal]\n * @param {Iterable<{ can: API.Ability }>} [opts.capabilities]\n * @param {boolean} [opts.addProofs]\n * @param {AuthorizationWaiter} [opts.expectAuthorization] - function that will resolve once account has confirmed the authorization request\n */\nexport async function authorizeWaitAndClaim(accessAgent, email, opts) {\n    await authorizeAndWait(accessAgent, email, opts);\n    await claimAccess(accessAgent, accessAgent.issuer.did(), {\n        addProofs: opts?.addProofs ?? true,\n    });\n}\n/**\n * Provisions space with the specified account and sets up a recovery with the\n * same account.\n *\n * @param {AccessAgent} access\n * @param {AgentData} agentData\n * @param {string} email\n * @param {object} [opts]\n * @param {AbortSignal} [opts.signal]\n * @param {API.DID<'key'>} [opts.space]\n * @param {API.ProviderDID} [opts.provider] - provider to register - defaults to this.connection.id\n */\nexport async function addProviderAndDelegateToAccount(access, agentData, email, opts) {\n    const space = opts?.space || access.currentSpace();\n    const spaceMeta = space ? agentData.spaces.get(space) : undefined;\n    const provider = opts?.provider ||\n        (() => {\n            const service = access.connection.id.did();\n            if (DIDWeb.is(service)) {\n                // connection.id did is a valid provider value. Try using that.\n                return service;\n            }\n            throw new Error(`unable to determine provider to use to addProviderAndDelegateToAccount using access.connection.id did ${service}. expected a did:web:`);\n        })();\n    if (!space || !spaceMeta) {\n        throw new Error('No space selected');\n    }\n    if (spaceMeta) {\n        throw new Error('Space already registered with storacha.network.');\n    }\n    const account = { did: () => DidMailto.fromEmail(DidMailto.email(email)) };\n    await addProvider({ access, space, account, provider });\n    const delegateSpaceAccessResult = await delegateSpaceAccessToAccount(access, space, account);\n    if (delegateSpaceAccessResult.out.error) {\n        throw delegateSpaceAccessResult.out.error;\n    }\n    await agentData.addSpace(space, spaceMeta);\n}\n/**\n * @param {AccessAgent} access\n * @param {API.SpaceDID} space\n * @param {API.Principal<API.AccountDID>} account\n */\nasync function delegateSpaceAccessToAccount(access, space, account) {\n    const issuerSaysAccountCanAdminSpace = await createIssuerSaysAccountCanAdminSpace(access.issuer, space, account, undefined, access.proofs([{ with: space, can: '*' }]), \n    // we want to sign over control of this space forever\n    Infinity);\n    return access.invokeAndExecute(Access.delegate, {\n        audience: access.connection.id,\n        with: space,\n        expiration: Infinity,\n        nb: {\n            delegations: {\n                [issuerSaysAccountCanAdminSpace.cid.toString()]: issuerSaysAccountCanAdminSpace.cid,\n            },\n        },\n        proofs: [\n            // must be embedded here because it's referenced by cid in .nb.delegations\n            issuerSaysAccountCanAdminSpace,\n        ],\n    });\n}\n/**\n * @param {API.Signer<API.DIDKey>} issuer\n * @param {API.SpaceDID} space\n * @param {API.Principal<API.AccountDID>} account\n * @param {API.Capabilities} capabilities\n * @param {API.Delegation[]} proofs\n * @param {number} expiration\n * @returns\n */\nasync function createIssuerSaysAccountCanAdminSpace(issuer, space, account, capabilities = [\n    {\n        can: '*',\n        with: space,\n    },\n], proofs = [], expiration) {\n    return delegate({\n        issuer,\n        audience: account,\n        capabilities,\n        proofs,\n        expiration,\n    });\n}\n/**\n *\n * @param {AccessAgent} agent\n * @param {API.AccountDID} account\n */\nexport async function getAccountPlan(agent, account) {\n    const receipt = await agent.invokeAndExecute(Plan.get, {\n        with: account,\n    });\n    return receipt.out;\n}\n//# sourceMappingURL=agent-use-cases.js.map", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "import defer from 'p-defer';\n/**\n * @template T\n * @typedef {import('./types.js').Driver<T>} Driver\n */\nconst STORE_NAME = 'AccessStore';\nconst DATA_ID = 1;\n/**\n * Driver implementation for the browser.\n *\n * Usage:\n *\n * ```js\n * import { IndexedDBDriver } from '@storacha/access/drivers/indexeddb'\n * ```\n *\n * @template T\n * @implements {Driver<T>}\n */\nexport class IndexedDBDriver {\n    /** @type {string} */\n    #dbName;\n    /** @type {number|undefined} */\n    #dbVersion;\n    /** @type {string} */\n    #dbStoreName;\n    /** @type {IDBDatabase|undefined} */\n    #db;\n    /** @type {boolean} */\n    #autoOpen;\n    /**\n     * @param {string} dbName\n     * @param {object} [options]\n     * @param {number} [options.dbVersion]\n     * @param {string} [options.dbStoreName]\n     * @param {boolean} [options.autoOpen]\n     */\n    constructor(dbName, options = {}) {\n        this.#dbName = dbName;\n        this.#dbVersion = options.dbVersion;\n        this.#dbStoreName = options.dbStoreName ?? STORE_NAME;\n        this.#autoOpen = options.autoOpen ?? true;\n    }\n    /** @returns {Promise<IDBDatabase>} */\n    async #getOpenDB() {\n        if (!this.#db) {\n            if (!this.#autoOpen)\n                throw new Error('Store is not open');\n            await this.open();\n        }\n        // @ts-expect-error open sets this.#db\n        return this.#db;\n    }\n    async open() {\n        const db = this.#db;\n        if (db)\n            return;\n        /** @type {import('p-defer').DeferredPromise<void>} */\n        const { resolve, reject, promise } = defer();\n        const openReq = indexedDB.open(this.#dbName, this.#dbVersion);\n        openReq.addEventListener('upgradeneeded', () => {\n            const db = openReq.result;\n            db.createObjectStore(this.#dbStoreName, { keyPath: 'id' });\n        });\n        openReq.addEventListener('success', () => {\n            this.#db = openReq.result;\n            resolve();\n        });\n        openReq.addEventListener('error', () => reject(openReq.error));\n        return promise;\n    }\n    async close() {\n        const db = this.#db;\n        if (!db)\n            throw new Error('Store is not open');\n        db.close();\n        this.#db = undefined;\n    }\n    /** @param {T} data */\n    async save(data) {\n        const db = await this.#getOpenDB();\n        const putData = withObjectStore(db, 'readwrite', this.#dbStoreName, async (store) => {\n            /** @type {import('p-defer').DeferredPromise<void>} */\n            const { resolve, reject, promise } = defer();\n            const putReq = store.put({ id: DATA_ID, ...data });\n            putReq.addEventListener('success', () => resolve());\n            putReq.addEventListener('error', () => reject(new Error('failed to query DB', { cause: putReq.error })));\n            return promise;\n        });\n        return await putData();\n    }\n    async load() {\n        const db = await this.#getOpenDB();\n        const getData = withObjectStore(db, 'readonly', this.#dbStoreName, async (store) => {\n            /** @type {import('p-defer').DeferredPromise<T|undefined>} */\n            const { resolve, reject, promise } = defer();\n            const getReq = store.get(DATA_ID);\n            getReq.addEventListener('success', () => resolve(getReq.result));\n            getReq.addEventListener('error', () => reject(new Error('failed to query DB', { cause: getReq.error })));\n            return promise;\n        });\n        return await getData();\n    }\n    async reset() {\n        const db = await this.#getOpenDB();\n        const clear = withObjectStore(db, 'readwrite', this.#dbStoreName, (s) => {\n            /** @type {import('p-defer').DeferredPromise<void>} */\n            const { resolve, reject, promise } = defer();\n            const req = s.clear();\n            req.addEventListener('success', () => {\n                resolve();\n            });\n            req.addEventListener('error', () => reject(new Error('failed to query DB', { cause: req.error })));\n            return promise;\n        });\n        await clear();\n    }\n}\n/**\n * @template T\n * @param {IDBDatabase} db\n * @param {IDBTransactionMode} txnMode\n * @param {string} storeName\n * @param {(s: IDBObjectStore) => Promise<T>} fn\n * @returns\n */\nfunction withObjectStore(db, txnMode, storeName, fn) {\n    return async () => {\n        const tx = db.transaction(storeName, txnMode);\n        /** @type {import('p-defer').DeferredPromise<T>} */\n        const { resolve, reject, promise } = defer();\n        /** @type {T} */\n        let result;\n        tx.addEventListener('complete', () => resolve(result));\n        tx.addEventListener('abort', () => reject(tx.error || new Error('transaction aborted')));\n        tx.addEventListener('error', () => reject(new Error('transaction error', { cause: tx.error })));\n        try {\n            result = await fn(tx.objectStore(storeName));\n            tx.commit();\n        }\n        catch (error) {\n            reject(error);\n            tx.abort();\n        }\n        return promise;\n    };\n}\n//# sourceMappingURL=indexeddb.js.map", "import { IndexedDBDriver } from '../drivers/indexeddb.js';\n/**\n * Store implementation for the browser.\n *\n * Usage:\n *\n * ```js\n * import { StoreIndexedDB } from '@storacha/access/stores/store-indexeddb'\n * ```\n *\n * @extends {IndexedDBDriver<import('../types.js').AgentDataExport>}\n */\nexport class StoreIndexedDB extends IndexedDBDriver {\n}\n//# sourceMappingURL=store-indexeddb.js.map", "import * as API from './api.js'\nimport {\n  IN_BYTES_PER_QUAD,\n  IN_BITS_FR,\n  OUT_BITS_FR,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\nimport * as ZeroPad from './zero-comm.js'\nimport { computeNode } from './proof.js'\nimport { split } from './piece/tree.js'\nimport { pad } from './fr32.js'\nimport { fromHeight as piceSizeFromHeight } from './piece/size/expanded.js'\nimport { Unpadded } from './piece/size.js'\nimport * as Digest from './digest.js'\nimport { varint } from 'multiformats'\n\nexport { Digest }\n\n/**\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const name = /** @type {const} */ (\n  'fr32-sha2-256-trunc254-padded-binary-tree'\n)\n\n/**\n * @type {API.MulticodecCode<0x1011, typeof name>}\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const code = 0x1011\n\n/**\n * Since first byte in the digest is the tree height, the maximum height is 255.\n *\n * @type {255}\n */\nexport const MAX_HEIGHT = 255\n\n/**\n * Max payload is determined by the maximum height of the tree, which is limited\n * by the int we could store in one byte. We calculate the max piece size\n * and derive max payload size that can would produce it after FR32 padding.\n */\nexport const MAX_PAYLOAD_SIZE =\n  (piceSizeFromHeight(MAX_HEIGHT) * BigInt(IN_BITS_FR)) / BigInt(OUT_BITS_FR)\n\n/**\n * Computes the digest of the given payload.\n *\n * @param {Uint8Array} payload\n * @returns {API.PieceDigest}\n */\nexport const digest = (payload) => {\n  const hasher = new Hasher()\n  hasher.write(payload)\n  return hasher.digest()\n}\n\n/**\n * Creates a streaming hasher that can be used to consumer larger streams\n * of data than it would be practical to load into memory all at once.\n *\n * @returns {API.StreamingHasher<typeof code, number, API.PieceDigest>}\n */\nexport const create = () => new Hasher()\n\n/**\n * @typedef {[API.MerkleTreeNode[], ...API.MerkleTreeNode[][]]} Layers\n *\n * @implements {API.StreamingHasher<typeof code, number, API.PieceDigest>}\n */\nclass Hasher {\n  constructor() {\n    /**\n     * The number of bytes consumed by the hasher.\n     *\n     * @private\n     */\n    this.bytesWritten = 0n\n\n    /**\n     * This buffer is used to accumulate bytes until we have enough to fill a\n     * quad.\n     *\n     *  Note that you should never read bytes past {@link offset} as those\n     * are considered dirty and may contain garbage.\n     *\n     * @protected\n     */\n    this.buffer = new Uint8Array(IN_BYTES_PER_QUAD)\n\n    /**\n     * Offset is the number of bytes in we have written into the buffer. If\n     * offset is 0 it means that the buffer is effectively empty. When `offset`\n     * is equal to `this.buffer.length` we have a quad that can be processed.\n     *\n     * @protected\n     */\n    this.offset = 0\n\n    /**\n     * The layers of the tree. Each layer will contain either 0 or 1 nodes\n     * between writes. When we write into a hasher, if we have enough nodes\n     * leaves will be created and pushed into the `layers[0]` array, after\n     * which we flush and combine every two leafs into a node which is moved\n     * to the next layer. This process is repeated until we reach the top\n     * layer, leaving each layer either empty or with a single node.\n     *\n     * @type {Layers}\n     */\n    this.layers = [[]]\n  }\n\n  /**\n   * Return the total number of bytes written into the hasher. Calling\n   * {@link reset} will reset the hasher and the count will be reset to 0.\n   *\n   * @returns {bigint}\n   */\n  count() {\n    return this.bytesWritten\n  }\n\n  /**\n   * Computes the digest of all the data that has been written into this hasher.\n   * This method does not have side-effects, meaning that you can continue\n   * writing and call this method again to compute digest of all the data\n   * written from the very beginning.\n   */\n  digest() {\n    const bytes = new Uint8Array(Digest.MAX_SIZE)\n    const count = this.digestInto(bytes, 0, true)\n    return Digest.fromBytes(bytes.subarray(0, count))\n  }\n\n  /**\n   * Computes the digest and writes into the given buffer. You can provide\n   * optional `byteOffset` to write digest at that offset in the buffer. By\n   * default the multihash prefix will be written into the buffer, but you can\n   * opt-out by passing `false` as the `asMultihash` argument.\n   *\n   * @param {Uint8Array} output\n   * @param {number} [byteOffset]\n   * @param {boolean} asMultihash\n   */\n  digestInto(output, byteOffset = 0, asMultihash = true) {\n    const { buffer, layers, offset, bytesWritten } = this\n\n    // We do not want to mutate the layers, so we create a shallow copy of it\n    // which we will use to compute the root.\n    let [leaves, ...nodes] = layers\n\n    // If we have some bytes in the buffer we fill rest with zeros and compute\n    // leaves from it. Note that it is safe to mutate the buffer here as bytes\n    // past `offset` are considered dirty and should not be read.\n    if (offset > 0 || bytesWritten === 0n) {\n      leaves = [...leaves, ...split(pad(buffer.fill(0, offset)))]\n    }\n\n    const tree = build([leaves, ...nodes])\n    const height = tree.length - 1\n    const [root] = tree[height]\n    const padding = Number(Unpadded.toPadding(this.bytesWritten))\n\n    const paddingLength = varint.encodingLength(\n      /** @type {number & bigint} */ (padding)\n    )\n\n    let endOffset = byteOffset\n    // Write the multihash prefix if requested\n    if (asMultihash) {\n      varint.encodeTo(code, output, endOffset)\n      endOffset += Digest.TAG_SIZE\n\n      const size = paddingLength + Digest.HEIGHT_SIZE + Digest.ROOT_SIZE\n      const sizeLength = varint.encodingLength(size)\n      varint.encodeTo(size, output, endOffset)\n      endOffset += sizeLength\n    }\n\n    varint.encodeTo(padding, output, endOffset)\n    endOffset += paddingLength\n\n    // Write the tree height as the first byte of the digest\n    output[endOffset] = height\n    endOffset += 1\n\n    // Write the root as the remaining 32 bytes of the digest\n    output.set(root, endOffset)\n    endOffset += root.length\n\n    // Return number of bytes written\n    return endOffset - byteOffset\n  }\n  /**\n   * @param {Uint8Array} bytes\n   */\n  write(bytes) {\n    const { buffer, offset, layers } = this\n    const leaves = layers[0]\n    const { length } = bytes\n    // If we got no bytes there is nothing to do here\n    if (length === 0) {\n      return this\n      /* c8 ignore next 5 */\n    } else if (this.bytesWritten + BigInt(length) > MAX_PAYLOAD_SIZE) {\n      throw new RangeError(\n        `Writing ${length} bytes exceeds max payload size of ${MAX_PAYLOAD_SIZE}`\n      )\n    }\n    // If we do not have enough bytes to form a quad, just add append new bytes\n    // to the buffer and return.\n    else if (offset + length < buffer.length) {\n      buffer.set(bytes, offset)\n      this.offset += length\n      this.bytesWritten += BigInt(length)\n      return this\n    }\n    // Otherwise we first fill the buffer to form a quad and create some leaves.\n    // Then we slice remaining bytes into quads sized chunks and create leaves\n    // from them. If we have some bytes left we copy them into the buffer and\n    // flush to combining node pairs and propagate them up the tree.\n    else {\n      // Number of bytes required to fill the quad buffer\n      const bytesRequired = buffer.length - offset\n      // copy required bytes into the buffer and turn them into leaves\n      // which we push into the leaf layer.\n      buffer.set(bytes.subarray(0, bytesRequired), offset)\n      leaves.push(...split(pad(buffer)))\n\n      // Now we slice remaining bytes into quads, create leaves from them\n      // and push them into the leaf layer.\n      let readOffset = bytesRequired\n      while (readOffset + IN_BYTES_PER_QUAD < length) {\n        const quad = bytes.subarray(readOffset, readOffset + IN_BYTES_PER_QUAD)\n        leaves.push(...split(pad(quad)))\n        readOffset += IN_BYTES_PER_QUAD\n      }\n\n      // Whatever byte were left are copied into the buffer and we update\n      // the offset to reflect that.\n      this.buffer.set(bytes.subarray(readOffset), 0)\n      this.offset = length - readOffset\n\n      // We also update the total number of bytes written.\n      this.bytesWritten += BigInt(length)\n\n      // Now prune the layers to propagate all the new leaves up the tree.\n      prune(this.layers)\n\n      return this\n    }\n  }\n\n  /**\n   * Resets this hasher to its initial state so it could be recycled as new\n   * instance.\n   */\n  reset() {\n    this.offset = 0\n    this.bytesWritten = 0n\n    this.layers.length = 1\n    this.layers[0].length = 0\n    return this\n  }\n\n  /* c8 ignore next 3 */\n  dispose() {\n    this.reset()\n  }\n  get code() {\n    return code\n  }\n  get name() {\n    return name\n  }\n}\n\n/**\n * Prunes layers by combining node pairs into nodes in the next layer and\n * removing them from the layer that they were in. After pruning each layer\n * will end up with at most one node. New layers may be created in the process\n * when nodes from the top layer are combined.\n *\n * @param {Layers} layers\n */\nconst prune = (layers) => flush(layers, false)\n\n/**\n * Flushes all the nodes in layers by combining node pairs into nodes in the\n * next layer. Layers with only one node are combined with zero padded nodes\n * (corresponding to the level of the layer). Unlike {@link prune} combined\n * nodes are not removed and layers are copied instead of been mutated.\n *\n * @param {Layers} layers\n */\nconst build = (layers) => flush([...layers], true)\n\n/**\n * @param {Layers} layers\n * @param {boolean} build\n * @returns {Layers}\n */\nconst flush = (layers, build) => {\n  // Note it is important that we do not mutate any of the layers otherwise\n  // writing more data into the hasher and computing the digest will produce\n  // wrong results.\n  let level = 0\n  // We will walk up the tree until we reach the top layer. However, we may end\n  // up with creating new layers in the process, so we will keep track of the\n  while (level < layers.length) {\n    let next = layers[level + 1]\n    const layer = layers[level]\n\n    // If we have the odd number of nodes and we have not reached the top\n    // layer, we push a zero padding node corresponding to the current level.\n    if (build && layer.length % 2 > 0 && next) {\n      layer.push(ZeroPad.fromLevel(level))\n    }\n\n    level += 1\n\n    // If we have 0 nodes in the current layer we just move to the next one.\n\n    // If we have a next layer and we are building  will combine nodes from the current layer\n    next = next ? (build ? [...next] : next) : []\n    let index = 0\n    // Note that we have checked that we have an even number of nodes so\n    // we will never end up with an extra node when consuming two at a time.\n    while (index + 1 < layer.length) {\n      const node = computeNode(layer[index], layer[index + 1])\n\n      // we proactively delete nodes in order to free up a memory used.\n      delete layer[index]\n      delete layer[index + 1]\n\n      next.push(node)\n      index += 2\n    }\n\n    if (next.length) {\n      layers[level] = next\n    }\n\n    // we remove nodes that we have combined from the current layer to reduce\n    // memory overhead and move to the next layer.\n    layer.splice(0, index)\n  }\n\n  return layers\n}\n", "/**\n * Number of bits per byte\n */\nconst BITS_PER_BYTE = 8\n\n/**\n * The number of Frs per Block.\n */\nexport const FRS_PER_QUAD = 4\n\nexport const LEAFS_PER_QUAD = /** @type {4n} */ (BigInt(FRS_PER_QUAD))\n\n/**\n * The amount of bits in an Fr when not padded.\n */\nexport const IN_BITS_FR = 254\n/**\n * The amount of bits in an Fr when padded.\n */\nexport const OUT_BITS_FR = 256\n\nexport const IN_BYTES_PER_QUAD =\n  /** @type {127} */\n  ((FRS_PER_QUAD * IN_BITS_FR) / BITS_PER_BYTE)\n\nexport const OUT_BYTES_PER_QUAD =\n  /** @type {128} */\n  ((FRS_PER_QUAD * OUT_BITS_FR) / BITS_PER_BYTE)\n\nexport const PADDED_BYTES_PER_QUAD = /** @type {127n} */ (\n  BigInt(IN_BYTES_PER_QUAD)\n)\n\nexport const EXPANDED_BYTES_PER_QUAD = /** @type {128n} */ (\n  BigInt(OUT_BYTES_PER_QUAD)\n)\n\nexport const BYTES_PER_FR =\n  /** @type {32} */\n  OUT_BYTES_PER_QUAD / FRS_PER_QUAD\n\nexport const FR_RATIO = IN_BITS_FR / OUT_BITS_FR\n\n/**\n * Size of a node in the merkle tree.\n */\nexport const NODE_SIZE =\n  /** @type {32} */\n  (OUT_BYTES_PER_QUAD / FRS_PER_QUAD)\n\nexport const EXPANDED_BYTES_PER_NODE = /** @type {32n} */ (BigInt(NODE_SIZE))\n\n/**\n * The smallest amount of data for which FR32 padding has a defined result.\n * Silently upgrading 2 leaves to 4 would break the symmetry so we require\n * an extra byte and the rest can be 0 padded to expand to 4 leaves.\n */\nexport const MIN_PAYLOAD_SIZE = 2 * NODE_SIZE + 1\n", "import * as API from './api.js'\nimport { NODE_SIZE as Size } from './constant.js'\n\nexport { Size }\n\n/**\n * @param {number[]} bytes\n */\nexport const of = (...bytes) => from(bytes)\n\n/**\n * @param {Iterable<number>} bytes\n * @returns {API.MerkleTreeNode}\n */\nexport const from = (bytes) => {\n  /* c8 ignore next 7 */\n  if (bytes instanceof Uint8Array) {\n    if (bytes.length > Size) {\n      return bytes.subarray(0, Size)\n    } else if (bytes.length == Size) {\n      return bytes\n    }\n  }\n\n  const node = new Uint8Array(Size)\n  node.set([...bytes])\n  return node\n}\n\nexport const empty = () => EMPTY\n\nconst EMPTY = from(new Uint8Array(Size).fill(0))\nObject.freeze(EMPTY.buffer)\n", "import * as API from '../api.js'\nimport * as SHA256 from 'sync-multihash-sha2/sha256'\nexport * from 'sync-multihash-sha2/sha256'\n\n/**\n * @type {API.MulticodecCode<typeof SHA256.code, typeof SHA256.name>}\n */\nexport const code = SHA256.code\n", "/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n", "export const name = 'sha2-256'\nexport const code = 0x12\nexport const size = 32\n\nexport const prefix = new Uint8Array([18, 32])\n\nexport class Digest {\n  /**\n   * @param {Uint8Array} bytes\n   */\n  constructor(bytes) {\n    /** @type {typeof code} */\n    this.code = code\n    /** @type {typeof name} */\n    this.name = name\n    this.bytes = bytes\n    /** @type {typeof size} */\n    this.size = size\n    this.digest = bytes.subarray(2)\n  }\n}\n", "/* c8 ignore next */\nimport { sha256 } from '@noble/hashes/sha256'\nimport { name, size, code, prefix, Digest } from './digest.js'\nexport { name, size, code }\n\n/**\n * @param {Uint8Array} payload\n * @returns {import('multiformats').MultihashDigest<typeof code>}\n */\nexport const digest = (payload) => {\n  const digest = new Uint8Array(prefix.length + size)\n  digest.set(prefix, 0)\n  digest.set(sha256(payload), prefix.length)\n\n  return new Digest(digest)\n}\n", "import * as API from './api.js'\n\nimport * as Bytes from 'multiformats/bytes'\nimport { Size as NodeSize } from './node.js'\nimport { CBOR, SHA256 } from './ipld.js'\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.MerkleTreePath}\n */\nexport const path = ([, path]) => path\n\n/**\n * @param {API.ProofData} proof\n * @returns {API.uint64}\n */\nexport const offset = ([offset]) => offset\n\n/**\n * @param {API.ProofData} proof\n * @returns {number}\n */\nexport const depth = (proof) => path(proof).length\n\n/**\n * Verifies that `proof` proves that `claim.node` is contained by\n * the `claim.tree` merkle tree.\n *\n * @param {API.ProofData} proof\n * @param {object} claim\n * @param {API.MerkleTreeNode} claim.tree\n * @param {API.MerkleTreeNode} claim.node\n * @returns {API.Result<{}, Error>}\n */\nexport const verify = (proof, { tree, node }) => {\n  const computedRoot = resolveRoot(proof, node)\n  if (computedRoot.error) {\n    return { error: new Error(`computing root: ${computedRoot.error.message}`) }\n  }\n\n  if (!Bytes.equals(computedRoot.ok, tree)) {\n    return {\n      error: new Error('inclusion proof does not lead to the same root'),\n    }\n  }\n  return { ok: {} }\n}\n\nconst MAX_DEPTH = 63\n\n/**\n * Resolves the root of the merkle tree from given proof and node that root\n * supposedly includes. It does so by computing parent node from provided node\n * and node in the proof path, then combining that with the next node in the\n * path and so on until the root is reached. Function may return an error if\n * proof path is too long or if proof offset falls out of bounds.\n *\n * @param {API.ProofData} proof\n * @param {API.MerkleTreeNode} node\n * @returns {API.Result<API.MerkleTreeNode, RangeError>}\n */\nexport function resolveRoot(proof, node) {\n  if (depth(proof) > MAX_DEPTH) {\n    return {\n      error: new RangeError(\n        'merkle proofs with depths greater than 63 are not supported'\n      ),\n    }\n  }\n\n  let position = offset(proof)\n  if (position >> BigInt(depth(proof)) !== 0n) {\n    return { error: new RangeError('offset greater than width of the tree') }\n  }\n\n  let top = node\n  let right = 0n\n\n  for (const node of path(proof)) {\n    right =  position & 1n\n    position = position >> 1n\n    top = right === 1n ? computeNode(node, top) : computeNode(top, node)\n  }\n\n  return { ok: top }\n}\n\n/**\n * @param {Uint8Array} payload\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport function truncatedHash(payload, options = {}) {\n  const hasher = options.hasher || SHA256\n  const { digest } = hasher.digest(payload)\n  return truncate(digest)\n}\n\n/**\n * @param {API.MerkleTreeNode} left\n * @param {API.MerkleTreeNode} right\n * @param {object} [options]\n * @param {API.SyncMultihashHasher<API.SHA256_CODE>} [options.hasher]\n * @returns {API.MerkleTreeNode}\n */\nexport const computeNode = (left, right, options) => {\n  const payload = new Uint8Array(left.length + right.length)\n  payload.set(left, 0)\n  payload.set(right, left.length)\n  return truncatedHash(payload, options)\n}\n\n/**\n * @param {API.MerkleTreeNode} node\n * @returns {API.MerkleTreeNode}\n */\nexport function truncate(node) {\n  node[NodeSize - 1] &= 0b00111111\n  return node\n}\n\n/**\n * Takes data model and returns an IPLD View of it.\n *\n * @param {object} source\n * @param {API.uint64} source.offset\n * @param {API.MerkleTreePath} source.path\n * @returns {API.ProofData}\n */\nexport const create = ({ offset, path }) => [offset, path]\n\n/**\n * Takes proof in somewhat arbitrary form and returns a proof data.\n *\n * @param {API.IntoProofData} source\n * @returns {API.ProofData}\n */\nexport const from = (source) => {\n  const [offset, path] = Array.isArray(source)\n    ? source\n    : [source.offset, source.path]\n\n  return create({ offset: BigInt(offset), path })\n}\n\n/**\n * @param {number} height - Height of the merkle tree\n * @param {number} level - Level of the node in the merkle tree\n * @param {API.uint64} index - Index of the node in the level\n */\nexport const validateLevelIndex = (height, level, index) => {\n  if (level < 0) {\n    throw new RangeError('level can not be negative')\n  }\n\n  if (level > height) {\n    throw new RangeError(`level too high: ${level} >= ${height}`)\n  }\n\n  if (index > (1 << (height - level)) - 1) {\n    throw new RangeError(\n      `index too large for level: idx ${index}, level ${level} : ${\n        (1 << (height - level)) - 1\n      }`\n    )\n  }\n}\n", "import * as API from './api.js'\nimport * as Node from './node.js'\nimport * as Proof from './proof.js'\n\nconst MAX_LEVEL = 64\n\n/**\n * This is a lazy zero-comm buffer which we fill up on demand.\n */\nclass ZeroComm {\n  constructor() {\n    this.bytes = new Uint8Array(MAX_LEVEL * Node.Size)\n    this.bytes.set(Node.empty(), 0)\n    /** @private */\n    this.node = Node.empty()\n    /** @private */\n    this.length = Node.Size\n  }\n  /**\n   * @param {number} start\n   * @param {number} end\n   */\n  slice(start, end) {\n    while (this.length < end) {\n      this.node = Proof.computeNode(this.node, this.node)\n      this.bytes.set(this.node, this.length)\n      this.length += Node.Size\n    }\n\n    return this.bytes.subarray(start, end)\n  }\n}\nconst ZERO_COMM = new ZeroComm()\n\n/**\n * simple access by level, only levels between `0` and `64` inclusive are\n * available otherwise throws an error.\n *\n * @param {number} level\n * @returns {API.MerkleTreeNode}\n */\nexport const fromLevel = (level) => {\n  if (level < 0 || level >= MAX_LEVEL) {\n    throw new Error(\n      `Only levels between 0 and ${MAX_LEVEL - 1} inclusive are available`\n    )\n  }\n\n  return ZERO_COMM.slice(Node.Size * level, Node.Size * (level + 1))\n}\n", "import * as API from '../api.js'\nimport { Size as NodeSize } from '../node.js'\nimport * as Proof from '../proof.js'\nexport { computeNode } from '../proof.js'\n\n// The value is an unsigned, 32-bit integer that is always numerically greater\n// than the highest index in the array. This means our tree can represent a\n// piece up to 128 GiB in size.\nexport const MAX_LEAF_COUNT = 2 ** 32 - 1\n\n/**\n * Allocates a tree for a given amount of leafs.\n *\n * The construction rounds the amount of leafs up to the nearest two-power with\n * zeroed nodes to ensure that the tree is perfect and hence all internal node's\n * have well-defined children.\n *\n * @param {number} leafs\n */\nexport function allocate(leafs) {\n  const adjustedLeafs = 2 ** Math.ceil(Math.log2(leafs))\n\n  if (adjustedLeafs > MAX_LEAF_COUNT) {\n    throw new RangeError(\n      `too many leafs ${adjustedLeafs} exceeds ${MAX_LEAF_COUNT} limit`\n    )\n  }\n\n  const height = Math.ceil(Math.log2(adjustedLeafs))\n  const nodes = new Array(height + 1)\n\n  for (const level of nodes.keys()) {\n    nodes[level] = new Array(1 << level)\n  }\n\n  return new PieceTree({ nodes, height })\n}\n\n/**\n * @param {API.TreeData} tree\n */\nconst depth = (tree) => {\n  return tree.nodes.length\n}\n\n/**\n *\n * @param {API.TreeData} tree\n * @returns {API.MerkleTreeNode}\n */\nexport const root = (tree) => {\n  return tree.nodes[0][0]\n}\n\n/**\n * @param {Uint8Array} source\n * @returns {API.MerkleTreeNode[]}\n */\nexport const split = (source) => {\n  const count = source.length / NodeSize\n  const chunks = new Array(count)\n  for (let n = 0; n < count; n++) {\n    const offset = n * NodeSize\n    const chunk = source.subarray(offset, offset + NodeSize)\n    chunks[n] = chunk\n  }\n  return chunks\n}\n\n/**\n * @param {API.Fr23Padded} source\n */\nexport const build = (source) => fromChunks(split(source))\n\n/**\n * @param {API.MerkleTreeNode[]} chunks\n */\nexport const fromChunks = (chunks) => {\n  if (chunks.length === 0) {\n    throw new RangeError('Empty source')\n  }\n\n  const leafs = chunks //await Promise.all(chunks.map(truncatedHash))\n  return fromLeafs(leafs)\n}\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.PieceTree}\n */\nexport const fromLeafs = (leafs) => {\n  const tree = allocate(leafs.length)\n  // Set the padded leaf nodes\n  tree.nodes[depth(tree) - 1] = padLeafs(leafs)\n  let parentNodes = tree.nodes[depth(tree) - 1]\n  // Construct the Merkle tree bottom-up, starting from the leafs\n  // Note the -1 due to 0-indexing the root level\n  for (let level = depth(tree) - 2; level >= 0; level--) {\n    /** @type {API.MerkleTreeNode[]} */\n    const currentLevel = new Array(Math.ceil(parentNodes.length / 2))\n    // Traverse the level left to right\n    for (let i = 0; i + 1 < parentNodes.length; i = i + 2) {\n      currentLevel[Math.floor(i / 2)] = Proof.computeNode(\n        parentNodes[i],\n        parentNodes[i + 1]\n      )\n    }\n    tree.nodes[level] = currentLevel\n    parentNodes = currentLevel\n  }\n\n  return new PieceTree(tree)\n}\n\n/**\n * @param {API.MerkleTreeNode[]} leafs\n * @returns {API.MerkleTreeNode[]}\n */\nexport const padLeafs = (leafs) => {\n  const paddingAmount = (1 << Math.ceil(Math.log2(leafs.length))) - leafs.length\n  // arrays are zeroed by default in JS\n  const paddingLeafs = new Array(paddingAmount)\n\n  return [...leafs, ...paddingLeafs]\n}\n\n/**\n * @implements {API.PieceTree}\n */\nclass PieceTree {\n  /**\n   * @param {object} data\n   * @param {API.MerkleTreeNode[][]} data.nodes\n   * @param {number} data.height\n   */\n  constructor({ nodes, height }) {\n    this.nodes = nodes\n    this.height = height\n  }\n\n  get root() {\n    return root(this)\n  }\n  get leafs() {\n    const { nodes } = this\n    return nodes[nodes.length - 1]\n  }\n  get leafCount() {\n    return 2 ** this.height\n  }\n  /**\n   *\n   * @param {number} level\n   * @param {number} index\n   */\n  node(level, index) {\n    const { nodes } = this\n    return nodes[level][index]\n  }\n}\n", "import * as API from './api.js'\nimport {\n  OUT_BYTES_PER_QUAD,\n  FR_RATIO,\n  IN_BYTES_PER_QUAD,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\n\n/**\n * Determine the additional bytes of zeroed padding to append to the\n * end of a resource of `size` length in order to fit within a pow2 piece while\n * leaving enough room for Fr32 padding (2 bits per 254).\n *\n * @param {number} payloadSize - The size of the payload.\n * @returns {number}\n */\nexport function toZeroPaddedSize(payloadSize) {\n  const size = Math.max(payloadSize, MIN_PAYLOAD_SIZE)\n  const highestBit = Math.floor(Math.log2(size))\n\n  const bound = Math.ceil(FR_RATIO * 2 ** (highestBit + 1))\n  // the size is either the closest pow2 number, or the next pow2 number if we\n  // don't have space for padding\n  return size <= bound ? bound : Math.ceil(FR_RATIO * 2 ** (highestBit + 2))\n}\n\n/**\n * Derives fr32 padded size from the source content size (that MUST be\n * multiples of {@link IN_BYTES_PER_QUAD}) in bytes.\n *\n * @param {number} size\n */\nexport const toPieceSize = (size) => toZeroPaddedSize(size) / FR_RATIO\n\n/**\n * Derives fr32 unpadded size from the Fr32 padded size in bytes.\n *\n * @param {number} size\n */\nexport const fromPieceSize = (size) => size * FR_RATIO\n\n/**\n * Takes source bytes that returns fr32 padded bytes.\n *\n * @param {Uint8Array} source\n * @param {Uint8Array} output\n * @returns {API.Fr23Padded}\n */\nexport const pad = (\n  source,\n  output = new Uint8Array(toPieceSize(source.length))\n) => {\n  const size = toZeroPaddedSize(source.byteLength)\n  // Calculate number of quads in the given source\n  const quadCount = size / IN_BYTES_PER_QUAD\n\n  // Cycle over four(4) 31-byte groups, leaving 1 byte in between:\n  // 31 + 1 + 31 + 1 + 31 + 1 + 31 = 127\n  for (let n = 0; n < quadCount; n++) {\n    const readOffset = n * IN_BYTES_PER_QUAD\n    const writeOffset = n * OUT_BYTES_PER_QUAD\n\n    // First 31 bytes + 6 bits are taken as-is (trimmed later)\n    output.set(source.subarray(readOffset, readOffset + 32), writeOffset)\n\n    // first 2-bit \"shim\" forced into the otherwise identical output\n    output[writeOffset + 31] &= 0b00111111\n\n    // copy next Fr32 preceded with the last two bits of the previous Fr32\n    for (let i = 32; i < 64; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 2) | (source[readOffset + i - 1] >> 6)\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 63] &= 0b00111111\n\n    for (let i = 64; i < 96; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 4) | (source[readOffset + i - 1] >> 4)\n    }\n\n    // next 2-bit shim\n    output[writeOffset + 95] &= 0b00111111\n\n    for (let i = 96; i < 127; i++) {\n      output[writeOffset + i] =\n        (source[readOffset + i] << 6) | (source[readOffset + i - 1] >> 2)\n    }\n\n    // we shim last 2-bits by shifting the last byte by two bits\n    output[writeOffset + 127] = source[readOffset + 126] >> 2\n  }\n\n  return output\n}\n\n/**\n * @param {API.Fr23Padded} source\n * @param {Uint8Array} [out]\n */\nexport const unpad = (\n  source,\n  out = new Uint8Array(fromPieceSize(source.length))\n) => {\n  const chunks = source.length / 128\n  for (let chunk = 0; chunk < chunks; chunk++) {\n    const inOffNext = chunk * 128 + 1\n    const outOff = chunk * 127\n\n    let at = source[chunk * 128]\n\n    for (let i = 0; i < 32; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at\n\n      at = next\n    }\n\n    out[outOff + 31] |= at << 6\n\n    for (let i = 32; i < 64; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at >> 2\n      out[outOff + i] |= next << 6\n\n      at = next\n    }\n\n    out[outOff + 63] ^= (at << 6) ^ (at << 4)\n\n    for (let i = 64; i < 96; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i] = at >> 4\n      out[outOff + i] |= next << 4\n\n      at = next\n    }\n\n    out[outOff + 95] ^= (at << 4) ^ (at << 2)\n\n    for (let i = 96; i < 127; i++) {\n      const next = source[i + inOffNext]\n\n      out[outOff + i]\n      out[outOff + i] = at >> 6\n      out[outOff + i] |= next << 2\n\n      at = next\n    }\n  }\n\n  return out\n}\n", "import * as API from './api.js'\n\n/**\n * Returns the base 2 logarithm of the given `n`, rounded down.\n *\n * @param {API.uint64} n\n * @returns {number}\n */\nexport const log2Floor = (n) => {\n  let result = 0n\n  while ((n >>= 1n)) result++\n  return Number(result)\n}\n\n/**\n * Return the integer logarithm with ceiling for 64 bit unsigned ints.\n *\n * @param {API.uint64} n\n */\nexport const log2Ceil = (n) => (n <= 1n ? 0 : log2Floor(BigInt(n) - 1n) + 1)\n\n/**\n * @param {API.uint64} n\n */\nexport const trailingZeros64 = (n) => {\n  if (n === 0n) {\n    return 64\n  }\n\n  let count = 0\n  while ((n & 1n) === 0n) {\n    n >>= 1n\n    count++\n  }\n\n  return count\n}\n\n/**\n * @param {API.uint64} value\n */\nexport const onesCount64 = (value) => {\n  let count = 0\n  const mask = 1n\n\n  for (let i = 0n; i < 64n; i++) {\n    if ((value & (mask << i)) !== 0n) {\n      count++\n    }\n  }\n\n  return count\n}\n\n/**\n * @param {API.uint64} n\n * @returns {API.uint64}\n */\nexport const pow2 = (n) => 1n << n\n", "import * as API from '../../api.js'\nimport { log2Ceil, trailingZeros64 } from '../../uint64.js'\nimport {\n  PADDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_QUAD,\n  LEAFS_PER_QUAD,\n} from '../../constant.js'\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} and\n * returns {@link API.UnpaddedPieceSize} capturing the validation at the type\n * level. If given `size` is not a valid `UnpaddedPieceSize` throws an error.\n *\n * This function is a variation on {@link validate} that throws exceptions\n * instead of returning a {@link API.Result}.\n *\n * @param {number|API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const from = (size) => {\n  const result = tryFrom(size)\n  if (result.error) {\n    throw result.error\n  } else {\n    return result.ok\n  }\n}\n\n/**\n * Validates that given `size` is a valid {@link API.UnpaddedPieceSize} that is\n * a power of 2 multiple of 127. Returns {@link API.Result} with\n * `UnpaddedPieceSize` ok case and an Error in the error case.\n *\n * @param {API.uint64|number} input\n * @returns {API.Result<API.PaddedSize, Error>}\n */\nexport const tryFrom = (input) => {\n  const size = BigInt(input)\n  if (size < PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(\n        `Padded payload must contain at least ${PADDED_BYTES_PER_QUAD} bytes`\n      ),\n    }\n  }\n\n  if (size >> BigInt(trailingZeros64(size)) !== PADDED_BYTES_PER_QUAD) {\n    return {\n      error: new RangeError(\n        `Padded payload size must be (2 * ${PADDED_BYTES_PER_QUAD})`\n      ),\n    }\n  }\n\n  return { ok: size }\n}\n\n/**\n * @param {API.PieceSize} size\n * @returns {API.PaddedSize}\n */\nexport const fromExpanded = (size) => fromQuads(size / EXPANDED_BYTES_PER_QUAD)\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * {@link API.PieceSize}.\n *\n * Please note that this function does not validate the input size and\n * relies that type-checker will ensure that user passes valid unpadded\n * piece size created with {@link from} or {@link validate} functions.\n *\n *\n * @see https://github.com/filecoin-project/go-state-types/blob/master/abi/piece.go#L14-L16\n *\n * @param {API.PaddedSize} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = (size) => toQauds(size) * EXPANDED_BYTES_PER_QUAD\n\n/**\n * Calculates the padded size of the piece from the given tree height.\n *\n * @param {number} height\n * @returns {API.uint64}\n */\nexport const fromHeight = (height) => {\n  // We calculate number of quads tree by calculating number of nodes tree\n  // at second layer. This works because we deal with a binary tree so first\n  // layer nodes will contain 2 leaves and second layer nodes will contain 4\n  // leaves hence number of quads.\n  const quads = 2n ** BigInt(height - 2)\n  return quads * PADDED_BYTES_PER_QUAD\n}\n\n/**\n * Calculates the height of the piece tree from unpadded size.\n *\n * @param {API.PaddedSize} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * piece tree width (leaf count).\n *\n * @param {API.PaddedSize} size\n */\nexport const toWidth = (size) => toQauds(size) * LEAFS_PER_QUAD\n\n/**\n *\n * @param {API.uint64} width\n * @returns {API.PaddedSize}\n */\nexport const fromWidth = (width) => fromQuads(width / LEAFS_PER_QUAD)\n\n/**\n * @param {API.PaddedSize} size\n */\nconst toQauds = (size) => size / PADDED_BYTES_PER_QUAD\n\n/**\n *\n * @param {API.uint64} count\n * @returns {API.PaddedSize}\n */\nconst fromQuads = (count) => count * PADDED_BYTES_PER_QUAD\n", "import * as API from '../../api.js'\nimport {\n  PADDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_QUAD,\n  LEAFS_PER_QUAD,\n} from '../../constant.js'\nimport { log2Ceil } from '../../uint64.js'\nimport * as Padded from './padded.js'\n\n/**\n * Takes the {@link API.Piece} sizing details (height and padding) and\n * calculates original payload size.\n *\n * @param {object} piece\n * @param {number} piece.height\n * @param {API.uint64} piece.padding\n */\nexport const fromPiece = ({ height, padding }) =>\n  Padded.fromHeight(height) - padding\n\n/**\n * Takes arbitrary payload size and calculates 0-padding required to\n * produce a {@link API.PaddedSize}.\n *\n * @param {API.uint64} size\n */\nexport const toPadding = (size) => toPadded(size) - size\n\n/**\n * Takes arbitrary payload size and calculates size after required 0-padding.\n *\n * @param {API.uint64} size\n * @returns {API.PaddedSize}\n */\nexport const toPadded = (size) => toQauds(size) * PADDED_BYTES_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates the piece size after required\n * 0-padding and FR32 expansion is applied.\n *\n * @param {API.uint64} size\n * @returns {API.PieceSize}\n */\nexport const toExpanded = (size) => toQauds(size) * EXPANDED_BYTES_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates width of the piece tree (leaf\n * count) that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toWidth = (size) => toQauds(size) * LEAFS_PER_QUAD\n\n/**\n * Takes arbitrary payload size and calculates height of the piece tree that will be required to represent it.\n *\n * @param {API.uint64} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes arbitrary payload size and calculates number of quads that will be\n * required to represent it.\n *\n * @param {API.uint64} size\n */\nconst toQauds = (size) => {\n  // Number of quads required to fit given payload size.\n  // Since bigint division truncates we add another quads shy of 1 number of\n  // bytes to round up.\n  const quadCount = (size + PADDED_BYTES_PER_QUAD - 1n) / PADDED_BYTES_PER_QUAD\n  // Next we we log2 then pow2 with some rounding to ensure that result\n  // is 2 ^ n.\n  return 2n ** BigInt(log2Ceil(quadCount))\n}\n", "import * as API from '../../api.js'\nimport {\n  EXPANDED_BYTES_PER_QUAD,\n  EXPANDED_BYTES_PER_NODE,\n} from '../../constant.js'\nimport { log2Ceil, onesCount64 } from '../../uint64.js'\n\nexport { toExpanded as fromPadded, fromExpanded as toPadded } from './padded.js'\nexport { toExpanded as fromUnpadded } from './unpadded.js'\n\n/**\n * Validates that given `size` is a valid {@link API.PieceSize} that is a\n * power of 2. Returns {@link API.Result} with `PaddedPieceSize` ok case and an\n * Error in the error case.\n *\n * @see https://github.com/filecoin-project/go-state-types/blob/ff2ed169ff566458f2acd8b135d62e8ca27e7d0c/abi/piece.go#L18-L29\n *\n * @param {number|API.uint64} input\n * @returns {API.Result<API.PieceSize, RangeError>}\n */\nexport const tryFrom = (input) => {\n  const size = BigInt(input)\n  if (size < EXPANDED_BYTES_PER_QUAD) {\n    return {\n      error: RangeError(\n        `Minimum piece size is ${EXPANDED_BYTES_PER_QUAD} bytes`\n      ),\n    }\n  }\n\n  if (onesCount64(size) !== 1) {\n    return { error: RangeError('Piece size must be a power of 2') }\n  }\n\n  return { ok: size }\n}\n\n/**\n * Validates that given `size` is a valid {@link API.PieceSize} and\n * returns {@link API.PieceSize} capturing the validation at the type\n * level. If given `size` is not a valid `PaddedPieceSize` throws an error.\n *\n * This function is a variation on {@link validate} that throws exceptions\n * instead of returning a {@link API.Result}.\n *\n * @param {number|API.uint64} size\n */\nexport const from = (size) => {\n  const result = tryFrom(size)\n  if (result.error) {\n    throw result.error\n  } else {\n    return result.ok\n  }\n}\n\n/**\n * Calculates the {@link API.PieceSize} for the given height of the piece tree.\n *\n * @param {number} height\n * @returns {API.PieceSize}\n */\nexport const fromHeight = (height) => fromWidth(2n ** BigInt(height))\n\n/**\n * Calculates the height of the piece tree from unpadded size.\n *\n * @param {API.PieceSize} size\n */\nexport const toHeight = (size) => log2Ceil(toWidth(size))\n\n/**\n * Takes piece tree width (leaf count) and returns corresponding\n * {@link API.PieceSize}.\n *\n * @param {API.uint64} width\n * @returns {API.PieceSize}\n */\nexport const fromWidth = (width) => width * EXPANDED_BYTES_PER_NODE\n\n/**\n * Takes `{@link API.PaddedPieceSize}` and returns corresponding\n * piece tree width (leaf count).\n *\n * @param {API.PieceSize} size\n */\nexport const toWidth = (size) => size / EXPANDED_BYTES_PER_NODE\n", "import { varint } from 'multiformats'\nimport * as API from './api.js'\nimport {\n  IN_BYTES_PER_QUAD,\n  IN_BITS_FR,\n  OUT_BITS_FR,\n  MIN_PAYLOAD_SIZE,\n} from './constant.js'\nimport { SHA256 } from './ipld.js'\nimport { fromHeight as piceSizeFromHeight } from './piece/size/expanded.js'\n\n/**\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const name = /** @type {const} */ (\n  'fr32-sha2-256-trunc254-padded-binary-tree'\n)\n\n/**\n * @type {API.MulticodecCode<0x1011, typeof name>}\n * @see https://github.com/multiformats/multicodec/pull/331/files\n */\nexport const code = 0x1011\n\n/**\n * Varint is used to encode the tree height which is limited to 9 bytes.\n *\n * @see https://github.com/multiformats/unsigned-varint#practical-maximum-of-9-bytes-for-security\n */\nconst MAX_PADDING_SIZE = 9\n/**\n * One byte is used to store the tree height.\n */\nexport const HEIGHT_SIZE = 1\n\n/**\n * Amount of bytes used to store the tree root.\n */\nexport const ROOT_SIZE = SHA256.size\n\n/**\n * Size of the multihash digest in bytes.\n */\nexport const MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + SHA256.size\n\nexport const TAG_SIZE = varint.encodingLength(code)\n\n/**\n * Max size of the multihash in bytes\n */\nexport const MAX_SIZE =\n  TAG_SIZE + varint.encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE\n\n/**\n * Since first byte in the digest is the tree height, the maximum height is 255.\n *\n * @type {255}\n */\nexport const MAX_HEIGHT = 255\n\n/**\n * Max payload is determined by the maximum height of the tree, which is limited\n * by the int we could store in one byte. We calculate the max piece size\n * and derive max payload size that can would produce it after FR32 padding.\n */\nexport const MAX_PAYLOAD_SIZE =\n  (piceSizeFromHeight(MAX_HEIGHT) * BigInt(IN_BITS_FR)) / BigInt(OUT_BITS_FR)\n\n/**\n * @param {API.Piece} piece\n * @returns {API.PieceDigest}\n */\nexport const fromPiece = ({ padding, height, root }) => {\n  const paddingLength = varint.encodingLength(Number(padding))\n  const size = paddingLength + HEIGHT_SIZE + ROOT_SIZE\n  const sizeLength = varint.encodingLength(size)\n\n  const multihashLength = TAG_SIZE + sizeLength + size\n\n  let offset = 0\n  const bytes = new Uint8Array(multihashLength)\n  varint.encodeTo(code, bytes, offset)\n  offset += TAG_SIZE\n\n  varint.encodeTo(size, bytes, offset)\n  offset += sizeLength\n\n  varint.encodeTo(Number(padding), bytes, offset)\n  offset += paddingLength\n\n  bytes[offset] = height\n  offset += HEIGHT_SIZE\n\n  bytes.set(root, offset)\n\n  return new Digest(bytes)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.PieceDigest}\n */\nexport const fromBytes = (bytes) => new Digest(bytes)\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const toBytes = ({ digest }) => {\n  const SIZE_BYTE_LENGTH = varint.encodingLength(digest.length)\n\n  // number of bytes prefix will take up\n  const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE\n\n  // if digest is view within a buffer that has enough bytes in front to\n  // fit the prefix it may be already include a prefix in which case we\n  // will simply use a larger slice.\n  if (digest.byteOffset >= prefixByteLength) {\n    const bytes = new Uint8Array(\n      digest.buffer,\n      digest.byteOffset - prefixByteLength,\n      digest.byteOffset + digest.length\n    )\n\n    // if the prefix matches our bytes represent a multihash\n    const [tag, offset] = varint.decode(bytes)\n    if (tag === code && varint.decode(bytes, offset)[0] === digest.length) {\n      return bytes\n    }\n  }\n\n  const bytes = new Uint8Array(digest.length + prefixByteLength)\n  varint.encodeTo(code, bytes)\n  varint.encodeTo(digest.length, bytes, TAG_SIZE)\n  bytes.set(digest, prefixByteLength)\n\n  return bytes\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const height = ({ digest }) => {\n  const [, offset] = varint.decode(digest)\n  return digest[offset]\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const padding = ({ digest }) => {\n  const [padding] = varint.decode(digest)\n  return BigInt(padding)\n}\n\n/**\n * @param {object} input\n * @param {Uint8Array} input.digest\n */\nexport const root = ({ digest }) => {\n  const [, offset] = varint.decode(digest)\n  return digest.subarray(\n    offset + HEIGHT_SIZE,\n    offset + HEIGHT_SIZE + SHA256.size\n  )\n}\n\n/**\n * @implements {API.PieceDigest}\n */\nclass Digest {\n  /**\n   * @param {Uint8Array} bytes\n   */\n  constructor(bytes) {\n    this.bytes = bytes\n    const [tag] = varint.decode(bytes)\n    if (tag !== code) {\n      throw new RangeError(`Expected multihash with code ${code}`)\n    }\n\n    let offset = TAG_SIZE\n    const [size, length] = varint.decode(bytes, offset)\n    offset += length\n    const digest = bytes.subarray(offset)\n\n    if (digest.length !== size) {\n      throw new RangeError(\n        `Invalid multihash size expected ${offset + size} bytes, got ${\n          bytes.length\n        } bytes`\n      )\n    }\n\n    this.digest = digest\n  }\n  get name() {\n    return name\n  }\n  get code() {\n    return code\n  }\n  get size() {\n    return this.digest.length\n  }\n  get padding() {\n    return padding(this)\n  }\n  get height() {\n    return height(this)\n  }\n  get root() {\n    return root(this)\n  }\n}\n", "import { connect } from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport * as Storefront from '@storacha/capabilities/filecoin/storefront';\nimport { services } from './service.js';\n/**\n * @typedef {import('./types.js').StorefrontService} StorefrontService\n * @typedef {import('@ucanto/interface').ConnectionView<StorefrontService>} ConnectionView\n */\n/** @type {ConnectionView} */\nexport const connection = connect({\n    id: services.STOREFRONT.principal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: services.STOREFRONT.url,\n        method: 'POST',\n    }),\n});\n/**\n * The `filecoin/offer` task can be executed to request storing a content piece\n * in Filecoin. It issues a signed receipt of the execution result.\n *\n * A receipt for successful execution will contain an effect, linking to a\n * `filecoin/submit` task that will complete asynchronously.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#filecoinoffer\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('multiformats').UnknownLink} content\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {import('./types.js').RequestOptions<StorefrontService>} [options]\n */\nexport async function filecoinOffer({ issuer, with: resource, proofs, audience }, content, piece, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Storefront.filecoinOffer.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.STOREFRONT.principal,\n        with: resource,\n        nb: {\n            content,\n            piece,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    return await invocation.execute(conn);\n}\n/**\n * The `filecoin/submit` task is an _effect_ linked from successful execution\n * of a `filecoin/offer` task, it is executed to issue a receipt for the\n * success or failure of the task.\n *\n * A receipt for successful execution indicates that the offered piece has been\n * submitted to the pipeline. In this case the receipt will contain an effect,\n * linking to a `piece/offer` task that will complete asynchronously.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#filecoinsubmit\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('multiformats').UnknownLink} content\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {import('./types.js').RequestOptions<StorefrontService>} [options]\n */\nexport async function filecoinSubmit({ issuer, with: resource, proofs, audience }, content, piece, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Storefront.filecoinSubmit.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.STOREFRONT.principal,\n        with: resource,\n        nb: {\n            content,\n            piece,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    return await invocation.execute(conn);\n}\n/**\n * The `filecoin/accept` task is an _effect_ linked from successful execution\n * of a `filecoin/offer` task, it is executed to issue a receipt for the\n * success or failure of the task.\n *\n * A receipt for successful execution indicates that the offered piece has been\n * accepted in a Filecoin deal. In this case the receipt will contain proofs\n * that the piece was included in an aggregate and deal.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#filecoinaccept\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('multiformats').UnknownLink} content\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {import('./types.js').RequestOptions<StorefrontService>} [options]\n */\nexport async function filecoinAccept({ issuer, with: resource, proofs, audience }, content, piece, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Storefront.filecoinAccept.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.STOREFRONT.principal,\n        with: resource,\n        nb: {\n            content,\n            piece,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    return await invocation.execute(conn);\n}\n/**\n * The `filecoin/info` task can be executed to request info about a content piece\n * in Filecoin. It issues a signed receipt of the execution result.\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {import('./types.js').RequestOptions<StorefrontService>} [options]\n */\nexport async function filecoinInfo({ issuer, with: resource, proofs, audience }, piece, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Storefront.filecoinInfo.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.STOREFRONT.principal,\n        with: resource,\n        nb: {\n            piece,\n        },\n        proofs,\n    });\n    return await invocation.execute(conn);\n}\n//# sourceMappingURL=storefront.js.map", "export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nexport const decode = bytes => decoder.decode(bytes)\n", "import * as API from '@ucanto/interface'\nimport * as CBOR from '@ucanto/core/cbor'\nexport const contentType = 'application/cbor'\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into a legacy CBOR representation.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const legacyResults = []\n  for (const receipt of message.receipts.values()) {\n    const result = receipt.out\n    if (result.ok) {\n      legacyResults.push(result.ok)\n    } else {\n      legacyResults.push({\n        ...result.error,\n        error: true,\n      })\n    }\n  }\n\n  /** @type {Uint8Array} */\n  const body = CBOR.encode(legacyResults)\n\n  return /** @type {API.HTTPResponse<Message>} */ ({\n    headers: HEADERS,\n    body,\n  })\n}\n", "import * as CAR from '@ucanto/core/car'\nimport * as API from '@ucanto/interface'\nimport { Invocation, Message } from '@ucanto/core'\n\nexport const contentType = 'application/car'\n\n/**\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n */\nexport const decode = async ({ body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  /** @type {API.IssuedInvocation[]} */\n  const run = []\n  for (const { cid } of roots) {\n    // We don't have a way to know if the root matches a ucan link.\n    const invocation = Invocation.view({\n      root: /** @type {API.Link} */ (cid),\n      blocks,\n    })\n    run.push(invocation)\n  }\n\n  const message = await Message.build({\n    invocations: /** @type {API.Tuple<API.IssuedInvocation>} */ (run),\n  })\n\n  return /** @type {Message} */ (message)\n}\n", "import * as Codec from './codec.js'\nimport * as CAR from './car.js'\nimport * as response from './legacy/response.js'\nimport * as request from './legacy/request.js'\n\nexport const { contentType } = request\nexport { request, response }\n\n/**\n * This is an inbound codec designed to support legacy clients and encode\n * responses in a legacy (CBOR) format.\n */\nexport const inbound = Codec.inbound({\n  decoders: {\n    [contentType]: request,\n    [CAR.contentType]: CAR.request,\n  },\n  encoders: {\n    // Here we configure encoders such that if accept header is `*/*` (which is\n    // the default if omitted) we will encode the response in CBOR. If\n    // `application/vnd.ipld.car` is set we will encode the response in current\n    // format.\n    // Here we exploit the fact that legacy clients do not send an accept header\n    // and therefore will get response in legacy format. New clients on the other\n    // hand will send `application/vnd.ipld.car` and consequently get response\n    // in current format.\n    '*/*;q=0.1': response,\n    [CAR.contentType]: CAR.response,\n  },\n})\n", "import * as DID from '@ipld/dag-ucan/did';\n/**\n * @typedef {import('./types.js').SERVICE} Service\n * @typedef {import('./types.js').ServiceConfig} ServiceConfig\n */\n/**\n * @type {Record<Service, ServiceConfig>}\n */\nexport const services = {\n    STOREFRONT: {\n        url: new URL('https://up.storacha.network'),\n        principal: DID.parse('did:web:up.storacha.network'),\n    },\n    AGGREGATOR: {\n        url: new URL('https://aggregator.web3.storage'),\n        principal: DID.parse('did:web:web3.storage'),\n    },\n    DEALER: {\n        url: new URL('https://dealer.web3.storage'),\n        principal: DID.parse('did:web:web3.storage'),\n    },\n    DEAL_TRACKER: {\n        url: new URL('https://tracker.web3.storage'),\n        principal: DID.parse('did:web:web3.storage'),\n    },\n};\n//# sourceMappingURL=service.js.map", "import { connect } from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport * as Aggregator from '@storacha/capabilities/filecoin/aggregator';\nimport { services } from './service.js';\n/**\n * @typedef {import('./types.js').AggregatorService} AggregatorService\n * @typedef {import('@ucanto/interface').ConnectionView<AggregatorService>} ConnectionView\n */\n/** @type {ConnectionView} */\nexport const connection = connect({\n    id: services.AGGREGATOR.principal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: services.AGGREGATOR.url,\n        method: 'POST',\n    }),\n});\n/**\n * The `piece/offer` task can be executed to request that a piece be aggregated\n * for inclusion in an upcoming an Filecoin deal. It issues a signed receipt\n * of the execution result. It is _also_ an effect linked from successful\n * execution of a `filecoin/submit` task.\n *\n * A receipt for successful execution will contain an effect, linking to a\n * `piece/accept` task that will complete asynchronously.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#pieceoffer\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {string} group\n * @param {import('./types.js').RequestOptions<AggregatorService>} [options]\n */\nexport async function pieceOffer({ issuer, with: resource, proofs, audience }, piece, group, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Aggregator.pieceOffer.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.AGGREGATOR.principal,\n        with: resource,\n        nb: {\n            piece,\n            group,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    return await invocation.execute(conn);\n}\n/**\n * The `piece/accept` task is an _effect_ linked from successful execution of a\n * `piece/offer` task, it is executed to issue a receipt for the success or\n * failure of the task.\n *\n * A receipt for successful execution indicates that the offered piece was\n * included in an aggregate. In this case the receipt will contain the\n * aggregate piece CID and a proof that the piece was included in the\n * aggregate. It also includes an effect, linking to an `aggregate/offer` task\n * that will complete asynchronously.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#pieceaccept\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {string} group\n * @param {import('./types.js').RequestOptions<AggregatorService>} [options]\n */\nexport async function pieceAccept({ issuer, with: resource, proofs, audience }, piece, group, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Aggregator.pieceAccept.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.AGGREGATOR.principal,\n        with: resource,\n        nb: {\n            piece,\n            group,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    return await invocation.execute(conn);\n}\n//# sourceMappingURL=aggregator.js.map", "import { connect } from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport { CBOR } from '@ucanto/core';\nimport * as Dealer from '@storacha/capabilities/filecoin/dealer';\nimport { services } from './service.js';\n/**\n * @typedef {import('./types.js').DealerService} DealerService\n * @typedef {import('@ucanto/interface').ConnectionView<DealerService>} ConnectionView\n */\n/** @type {ConnectionView} */\nexport const connection = connect({\n    id: services.DEALER.principal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: services.DEALER.url,\n        method: 'POST',\n    }),\n});\n/**\n * The `aggregate/offer` task can be executed to request an aggregate be added\n * to a deal with a Storage Provider. It issues a signed receipt of the\n * execution result. It is _also_ an effect linked from successful execution of\n * a `piece/accept` task.\n *\n * A receipt for successful execution will contain an effect, linking to an\n * `aggregate/accept` task that will complete asynchronously.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#aggregateoffer\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('@web3-storage/data-segment').PieceLink} aggregate\n * @param {import('@web3-storage/data-segment').PieceLink[]} pieces\n * @param {import('./types.js').RequestOptions<DealerService>} [options]\n */\nexport async function aggregateOffer({ issuer, with: resource, proofs, audience }, aggregate, pieces, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const block = await CBOR.write(pieces);\n    const invocation = Dealer.aggregateOffer.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.AGGREGATOR.principal,\n        with: resource,\n        nb: {\n            aggregate,\n            pieces: block.cid,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    invocation.attach(block);\n    return await invocation.execute(conn);\n}\n/**\n * The `aggregate/accept` task is an _effect_ linked from successful execution\n * of a `aggregate/offer` task, it is executed to issue a receipt for the\n * success or failure of the task.\n *\n * A receipt for successful execution indicates that an aggregate has been\n * accepted for inclusion in a Filecoin deal. In this case the receipt will\n * contain proofs that the piece was included in an aggregate and deal.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure, as well as multiple effects, linking to\n * `piece/offer` tasks that will retry _valid_ pieces and complete\n * asynchronously.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#aggregateaccept\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('@web3-storage/data-segment').PieceLink} aggregate\n * @param {import('@ucanto/interface').Link} pieces\n * @param {import('./types.js').RequestOptions<DealerService>} [options]\n */\nexport async function aggregateAccept({ issuer, with: resource, proofs, audience }, aggregate, pieces, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = Dealer.aggregateAccept.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.AGGREGATOR.principal,\n        with: resource,\n        nb: {\n            aggregate,\n            pieces,\n        },\n        proofs,\n        expiration: Infinity,\n    });\n    return await invocation.execute(conn);\n}\n//# sourceMappingURL=dealer.js.map", "import { connect } from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport * as DealTracker from '@storacha/capabilities/filecoin/deal-tracker';\nimport { services } from './service.js';\n/**\n * @typedef {import('./types.js').DealTrackerService} DealTrackerService\n * @typedef {import('@ucanto/interface').ConnectionView<DealTrackerService>} ConnectionView\n */\n/** @type {ConnectionView} */\nexport const connection = connect({\n    id: services.DEAL_TRACKER.principal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: services.DEAL_TRACKER.url,\n        method: 'POST',\n    }),\n});\n/**\n * The `deal/info` task can be executed to request deal information for a given\n * piece. It issues a signed receipt of the execution result.\n *\n * A receipt for successful execution will contain details of deals the\n * provided piece CID is currently active in.\n *\n * Otherwise the task is failed and the receipt will contain details of the\n * reason behind the failure.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-filecoin.md#dealinfo\n *\n * @param {import('./types.js').InvocationConfig} conf - Configuration\n * @param {import('@web3-storage/data-segment').PieceLink} piece\n * @param {import('./types.js').RequestOptions<DealTrackerService>} [options]\n */\nexport async function dealInfo({ issuer, with: resource, proofs, audience }, piece, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const invocation = DealTracker.dealInfo.invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? services.DEAL_TRACKER.principal,\n        with: resource,\n        nb: {\n            piece,\n        },\n        proofs,\n    });\n    return await invocation.execute(conn);\n}\n//# sourceMappingURL=deal-tracker.js.map", "export { add } from './add.js';\nexport { get } from './get.js';\nexport { list } from './list.js';\nexport { remove } from './remove.js';\nexport { replicate } from './replicate.js';\n//# sourceMappingURL=index.js.map", "import retry from 'retry';\n\nconst networkErrorMsgs = new Set([\n\t'Failed to fetch', // Chrome\n\t'NetworkError when attempting to fetch resource.', // Firefox\n\t'The Internet connection appears to be offline.', // Safari\n\t'Network request failed', // `cross-fetch`\n\t'fetch failed', // Undici (Node.js)\n]);\n\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\n\t\tif (message instanceof Error) {\n\t\t\tthis.originalError = message;\n\t\t\t({message} = message);\n\t\t} else {\n\t\t\tthis.originalError = new Error(message);\n\t\t\tthis.originalError.stack = this.stack;\n\t\t}\n\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\nconst decorateErrorWithCounts = (error, attemptNumber, options) => {\n\t// Minus 1 from attemptNumber because the first attempt does not count as a retry\n\tconst retriesLeft = options.retries - (attemptNumber - 1);\n\n\terror.attemptNumber = attemptNumber;\n\terror.retriesLeft = retriesLeft;\n\treturn error;\n};\n\nconst isNetworkError = errorMessage => networkErrorMsgs.has(errorMessage);\n\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new Error(errorMessage)\n\t: new DOMException(errorMessage);\n\nexport default async function pRetry(input, options) {\n\treturn new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\tonFailedAttempt() {},\n\t\t\tretries: 10,\n\t\t\t...options,\n\t\t};\n\n\t\tconst operation = retry.operation(options);\n\n\t\toperation.attempt(async attemptNumber => {\n\t\t\ttry {\n\t\t\t\tresolve(await input(attemptNumber));\n\t\t\t} catch (error) {\n\t\t\t\tif (!(error instanceof Error)) {\n\t\t\t\t\treject(new TypeError(`Non-error was thrown: \"${error}\". You should only throw errors.`));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (error instanceof AbortError) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error.originalError);\n\t\t\t\t} else if (error instanceof TypeError && !isNetworkError(error.message)) {\n\t\t\t\t\toperation.stop();\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tdecorateErrorWithCounts(error, attemptNumber, options);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait options.onFailedAttempt(error);\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!operation.retry(error)) {\n\t\t\t\t\t\treject(operation.mainError());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (options.signal && !options.signal.aborted) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\toperation.stop();\n\t\t\t\tconst reason = options.signal.reason === undefined\n\t\t\t\t\t? getDOMException('The operation was aborted.')\n\t\t\t\t\t: options.signal.reason;\n\t\t\t\treject(reason instanceof Error ? reason : getDOMException(reason));\n\t\t\t}, {\n\t\t\t\tonce: true,\n\t\t\t});\n\t\t}\n\t});\n}\n", "import { connect } from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport * as DID from '@ipld/dag-ucan/did';\nexport const serviceURL = new URL('https://up.storacha.network');\nexport const servicePrincipal = DID.parse('did:web:up.storacha.network');\nexport const receiptsEndpoint = 'https://up.storacha.network/receipt/';\n/** @type {import('@ucanto/interface').ConnectionView<import('./types.js').Service>} */\nexport const connection = connect({\n    id: servicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: serviceURL,\n        method: 'POST',\n    }),\n});\n//# sourceMappingURL=service.js.map", "export const REQUEST_RETRIES = 3;\n//# sourceMappingURL=constants.js.map", "import retry, { AbortError } from 'p-retry';\nimport { CAR } from '@ucanto/transport';\nimport { isDelegation, Receipt } from '@ucanto/core';\nimport { receiptsEndpoint } from './service.js';\nimport { REQUEST_RETRIES } from './constants.js';\n/** @import * as API from './types.js' */\n/** @implements {API.ReceiptNotFound} */\nexport class ReceiptNotFound extends Error {\n    name = /** @type {const} */ ('ReceiptNotFound');\n    /**\n     * @param {API.UnknownLink} taskCid\n     */\n    constructor(taskCid) {\n        super();\n        this.taskCid = taskCid;\n    }\n    /* c8 ignore start */\n    get reason() {\n        return `receipt not found for task ${this.taskCid} in the indexed workflow`;\n    }\n}\n/** @implements {API.ReceiptMissing} */\nexport class ReceiptMissing extends Error {\n    name = /** @type {const} */ ('ReceiptMissing');\n    /**\n     * @param {API.UnknownLink} taskCid\n     */\n    constructor(taskCid) {\n        super();\n        this.taskCid = taskCid;\n    }\n    /* c8 ignore start */\n    get reason() {\n        return `receipt missing for task ${this.taskCid}`;\n    }\n}\n/**\n * Polls for a receipt for an executed task by its CID.\n *\n * @template {API.Capability} C\n * @template {Record<string, any>} S\n * @param {API.UCANLink<[C]>} taskCid\n * @param {API.ReceiptGetOptions<S> & API.Retryable} [options]\n * @returns {Promise<API.InferReceipt<C, S>>}\n */\nexport async function poll(taskCid, options) {\n    return await retry(async () => {\n        const res = await get(taskCid, options);\n        if (res.error) {\n            // @ts-ignore\n            if (res.error.name === 'ReceiptNotFound') {\n                // throw an error that will cause `p-retry` to retry with\n                throw res.error;\n            }\n            else {\n                throw new AbortError(new Error(`failed to fetch receipt for task: ${taskCid}`, {\n                    cause: res.error,\n                }));\n            }\n        }\n        return res.ok;\n    }, {\n        signal: options?.signal,\n        onFailedAttempt: console.warn,\n        /* c8 ignore next */\n        retries: options?.retries ?? REQUEST_RETRIES,\n    });\n}\n/**\n * Calculate a receipt endpoint from the URL of a channel, if it has one.\n *\n * @param {API.Channel<Record<string, any>>} channel\n */\nfunction receiptEndpointFromChannel(channel) {\n    if ('url' in channel && channel.url instanceof URL) {\n        const url = channel.url;\n        return new URL('/receipt/', url.toString());\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Get a receipt for an executed task by its CID.\n *\n * @template {API.Capability} C\n * @template {Record<string, any>} S\n * @param {API.UCANLink<[C]>} taskCid\n * @param {API.ReceiptGetOptions<S>} [options]\n * @returns {Promise<API.Result<API.InferReceipt<C, S>, API.ReceiptNotFound|API.ReceiptMissing>>}\n */\nexport async function get(taskCid, options) {\n    const channel = options?.connection?.channel;\n    const endpoint = options?.endpoint ??\n        (channel && receiptEndpointFromChannel(channel)) ??\n        receiptsEndpoint;\n    // Fetch receipt from endpoint\n    const url = new URL(taskCid.toString(), endpoint);\n    const fetchReceipt = options?.fetch ?? globalThis.fetch.bind(globalThis);\n    const workflowResponse = await fetchReceipt(url, { signal: options?.signal });\n    /* c8 ignore start */\n    if (workflowResponse.status === 404) {\n        return {\n            error: new ReceiptNotFound(taskCid),\n        };\n    }\n    /* c8 ignore stop */\n    // Get receipt from Message Archive\n    const agentMessageBytes = new Uint8Array(await workflowResponse.arrayBuffer());\n    // Decode message\n    const agentMessage = await CAR.request.decode({\n        body: agentMessageBytes,\n        headers: {},\n    });\n    // Get receipt from the potential multiple receipts in the message\n    const receipt = \n    /** @type {API.InferReceipt<C, S>|undefined} */\n    (agentMessage.receipts.get(`${taskCid}`));\n    if (!receipt) {\n        // This could be an agent message containing an invocation for ucan/conclude\n        // that includes the receipt as an attached block, or it may contain a\n        // receipt for ucan/conclude that includes the receipt as an attached block.\n        const blocks = new Map();\n        for (const b of agentMessage.iterateIPLDBlocks()) {\n            blocks.set(b.cid.toString(), b);\n        }\n        const invocations = [...agentMessage.invocations];\n        for (const receipt of agentMessage.receipts.values()) {\n            if (isDelegation(receipt.ran)) {\n                invocations.push(receipt.ran);\n            }\n        }\n        for (const inv of invocations) {\n            /* c8 ignore next */\n            if (inv.capabilities[0]?.can !== 'ucan/conclude')\n                continue;\n            const root = Object(inv.capabilities[0].nb).receipt;\n            /* c8 ignore next 5 */\n            const receipt = root\n                ? /** @type {API.InferReceipt<C, S>|null} */ (Receipt.view({ root, blocks }, null))\n                : null;\n            /* c8 ignore next */\n            if (!receipt)\n                continue;\n            /* c8 ignore next */\n            const ran = isDelegation(receipt.ran) ? receipt.ran.cid : receipt.ran;\n            if (ran.toString() === taskCid.toString()) {\n                return { ok: receipt };\n            }\n        }\n        return {\n            error: new ReceiptMissing(taskCid),\n        };\n    }\n    return {\n        ok: receipt,\n    };\n}\n//# sourceMappingURL=receipts.js.map", "/* c8 ignore next 3 */\nexport const isCloudflareWorkers = typeof navigator !== 'undefined' &&\n    navigator?.userAgent === 'Cloudflare-Workers';\n//# sourceMappingURL=runtime.js.map", "import { ed25519 } from '@ucanto/principal';\nimport * as UCAN from '@storacha/capabilities/ucan';\nimport { Delegation, Receipt } from '@ucanto/core';\nimport * as BlobCapabilities from '@storacha/capabilities/blob';\nimport * as W3sBlobCapabilities from '@storacha/capabilities/web3.storage/blob';\nimport * as SpaceBlobCapabilities from '@storacha/capabilities/space/blob';\nimport * as HTTPCapabilities from '@storacha/capabilities/http';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport retry, { AbortError } from 'p-retry';\nimport { servicePrincipal, connection } from '../service.js';\nimport { REQUEST_RETRIES } from '../constants.js';\nimport { poll } from '../receipts.js';\nimport { isCloudflareWorkers } from '../runtime.js';\n/** @import * as API from '../types.js' */\n/**\n * @param {string} url\n * @param {API.ProgressFn} handler\n */\nfunction createUploadProgressHandler(url, handler) {\n    /** @param {API.ProgressStatus} status */\n    const onUploadProgress = ({ total, loaded, lengthComputable }) => {\n        return handler({ total, loaded, lengthComputable, url });\n    };\n    return onUploadProgress;\n}\n// FIXME this code has been copied over from upload-api\n/**\n * @param {API.Invocation} concludeFx\n */\nfunction getConcludeReceipt(concludeFx) {\n    const receiptBlocks = new Map();\n    for (const block of concludeFx.iterateIPLDBlocks()) {\n        receiptBlocks.set(`${block.cid}`, block);\n    }\n    return Receipt.view({\n        // @ts-expect-error object of type unknown\n        root: concludeFx.capabilities[0].nb.receipt,\n        blocks: receiptBlocks,\n    });\n}\n// FIXME this code has been copied over from upload-api\n/**\n * @param {API.Receipt} receipt\n */\nfunction parseBlobAddReceiptNext(receipt) {\n    // Get invocations next\n    /**\n     * @type {API.Invocation[]}\n     */\n    // @ts-expect-error read only effect\n    const forkInvocations = receipt.fx.fork;\n    const allocateTask = forkInvocations.find((fork) => fork.capabilities[0].can === BlobCapabilities.allocate.can\n    /* c8 ignore next 4 */ // tested by legacy integration test in w3up-client\n    ) ??\n        forkInvocations.find((fork) => fork.capabilities[0].can === W3sBlobCapabilities.allocate.can);\n    const concludefxs = forkInvocations.filter((fork) => fork.capabilities[0].can === UCAN.conclude.can);\n    const putTask = forkInvocations.find((fork) => fork.capabilities[0].can === HTTPCapabilities.put.can);\n    const acceptTask = \n    /** @type {API.Invocation<API.BlobAccept>|undefined} */\n    (forkInvocations.find((fork) => fork.capabilities[0].can === BlobCapabilities.accept.can\n    /* c8 ignore next 4 */ // tested by legacy integration test in w3up-client\n    ) ??\n        forkInvocations.find((fork) => fork.capabilities[0].can === W3sBlobCapabilities.accept.can));\n    /* c8 ignore next 3 */\n    if (!allocateTask || !concludefxs.length || !putTask || !acceptTask) {\n        throw new Error('mandatory effects not received');\n    }\n    // Decode receipts available\n    const nextReceipts = concludefxs.map((fx) => getConcludeReceipt(fx));\n    /** @type {API.Receipt<API.BlobAllocateSuccess, API.BlobAllocateFailure> | undefined} */\n    // @ts-expect-error types unknown for next\n    const allocateReceipt = nextReceipts.find((receipt) => receipt.ran.link().equals(allocateTask.cid));\n    /** @type {API.Receipt<{}, API.Failure> | undefined} */\n    // @ts-expect-error types unknown for next\n    const putReceipt = nextReceipts.find((receipt) => receipt.ran.link().equals(putTask.cid));\n    /** @type {API.Receipt<API.BlobAcceptSuccess, API.BlobAcceptFailure> | undefined} */\n    // @ts-expect-error types unknown for next\n    const acceptReceipt = nextReceipts.find((receipt) => receipt.ran.link().equals(acceptTask.cid));\n    /* c8 ignore next 3 */\n    if (!allocateReceipt) {\n        throw new Error('mandatory effects not received');\n    }\n    return {\n        allocate: {\n            task: allocateTask,\n            receipt: allocateReceipt,\n        },\n        put: {\n            task: putTask,\n            receipt: putReceipt,\n        },\n        accept: {\n            task: acceptTask,\n            receipt: acceptReceipt,\n        },\n    };\n}\n// FIXME this code has been copied over from upload-api\n/**\n * @param {API.Signer} id\n * @param {API.Principal} serviceDid\n * @param {API.Receipt} receipt\n */\nexport function createConcludeInvocation(id, serviceDid, receipt) {\n    const receiptBlocks = [];\n    const receiptCids = [];\n    for (const block of receipt.iterateIPLDBlocks()) {\n        receiptBlocks.push(block);\n        receiptCids.push(block.cid);\n    }\n    const concludeAllocatefx = UCAN.conclude.invoke({\n        issuer: id,\n        audience: serviceDid,\n        with: id.toDIDKey(),\n        nb: {\n            receipt: receipt.link(),\n        },\n        expiration: Infinity,\n        facts: [\n            {\n                ...receiptCids,\n            },\n        ],\n    });\n    for (const block of receiptBlocks) {\n        concludeAllocatefx.attach(block);\n    }\n    return concludeAllocatefx;\n}\n/**\n * Store a blob to the service. The issuer needs the `blob/add`\n * delegated capability.\n *\n * Required delegated capability proofs: `blob/add`\n *\n * @param {API.InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add` delegated capability.\n * @param {import('multiformats').MultihashDigest} digest\n * @param {Blob|Uint8Array} data Blob data.\n * @param {API.RequestOptions} [options]\n * @returns {Promise<API.BlobAddOk>}\n */\nexport async function add({ issuer, with: resource, proofs, audience }, digest, data, options = {}) {\n    /* c8 ignore next 2 */\n    const bytes = data instanceof Uint8Array ? data : new Uint8Array(await data.arrayBuffer());\n    const size = bytes.length;\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await retry(async () => {\n        return await SpaceBlobCapabilities.add\n            .invoke({\n            issuer,\n            /* c8 ignore next */\n            audience: audience ?? servicePrincipal,\n            with: SpaceDID.from(resource),\n            nb: input(digest, size),\n            proofs,\n            nonce: options.nonce,\n        })\n            .execute(conn);\n    }, {\n        onFailedAttempt: console.warn,\n        retries: options.retries ?? REQUEST_RETRIES,\n    });\n    if (!result.out.ok) {\n        throw new Error(`failed ${SpaceBlobCapabilities.add.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    const nextTasks = parseBlobAddReceiptNext(result);\n    const { receipt: allocateReceipt } = nextTasks.allocate;\n    /* c8 ignore next 5 */\n    if (!allocateReceipt.out.ok) {\n        throw new Error(`failed ${SpaceBlobCapabilities.add.can} invocation`, {\n            cause: allocateReceipt.out.error,\n        });\n    }\n    const { address } = allocateReceipt.out.ok;\n    if (address) {\n        const fetchWithUploadProgress = options.fetchWithUploadProgress ||\n            options.fetch ||\n            globalThis.fetch.bind(globalThis);\n        let fetchDidCallUploadProgressCb = false;\n        await retry(async () => {\n            try {\n                const res = await fetchWithUploadProgress(address.url, {\n                    method: 'PUT',\n                    ...(!isCloudflareWorkers && { mode: 'cors' }),\n                    body: bytes,\n                    headers: address.headers,\n                    signal: options.signal,\n                    onUploadProgress: (status) => {\n                        fetchDidCallUploadProgressCb = true;\n                        if (options.onUploadProgress)\n                            createUploadProgressHandler(address.url, options.onUploadProgress)(status);\n                    },\n                    // @ts-expect-error - this is needed by recent versions of node - see https://github.com/bluesky-social/atproto/pull/470 for more info\n                    duplex: 'half',\n                });\n                // do not retry client errors\n                if (res.status >= 400 && res.status < 500) {\n                    throw new AbortError(`upload failed: ${res.status}`);\n                }\n                if (!res.ok) {\n                    throw new Error(`upload failed: ${res.status}`);\n                }\n                await res.arrayBuffer();\n            }\n            catch (err) {\n                if (options.signal?.aborted === true) {\n                    throw new AbortError('upload aborted');\n                }\n                throw err;\n            }\n        }, {\n            retries: options.retries ?? REQUEST_RETRIES,\n        });\n        if (!fetchDidCallUploadProgressCb && options.onUploadProgress) {\n            // the fetch implementation didn't support onUploadProgress\n            const blob = new Blob([bytes]);\n            options.onUploadProgress({\n                total: blob.size,\n                loaded: blob.size,\n                lengthComputable: false,\n            });\n        }\n    }\n    // Invoke `conclude` with `http/put` receipt\n    let { receipt: httpPutReceipt } = nextTasks.put;\n    if (!httpPutReceipt?.out.ok) {\n        const derivedSigner = ed25519.from(\n        /** @type {API.SignerArchive<API.DID, typeof ed25519.signatureCode>} */\n        (nextTasks.put.task.facts[0]['keys']));\n        httpPutReceipt = await Receipt.issue({\n            issuer: derivedSigner,\n            ran: nextTasks.put.task.cid,\n            result: { ok: {} },\n        });\n        const httpPutConcludeInvocation = createConcludeInvocation(issuer, \n        /* c8 ignore next */\n        audience ?? servicePrincipal, httpPutReceipt);\n        const ucanConclude = await httpPutConcludeInvocation.execute(conn);\n        if (!ucanConclude.out.ok) {\n            throw new Error(`failed ${UCAN.conclude.can} for ${HTTPCapabilities.put.can} invocation`, {\n                cause: ucanConclude.out.error,\n            });\n        }\n    }\n    // Ensure the blob has been accepted\n    let { receipt: acceptReceipt } = nextTasks.accept;\n    if (!acceptReceipt || !acceptReceipt.out.ok) {\n        acceptReceipt = await poll(nextTasks.accept.task.link(), {\n            ...options,\n            /* c8 ignore next 3 */\n            endpoint: options.receiptsEndpoint\n                ? new URL(options.receiptsEndpoint)\n                : undefined,\n            // The connection we have is for the upload service, which does not\n            // actually implement blob/accept. However, it does provide receipts for\n            // blob accept invocations it has made to storage nodes. Hence we type\n            // assert that this connection is a connecton to a service that\n            // implements blob/accept so that we can get a typed receipt back.\n            connection: /** @type {API.Connection<API.BlobService>} */ (Object(conn)),\n        });\n        /* c8 ignore next 5 */\n        if (acceptReceipt.out.error) {\n            throw new Error(`${BlobCapabilities.accept.can} failure`, {\n                cause: acceptReceipt.out.error,\n            });\n        }\n    }\n    const blocks = new Map([...acceptReceipt.iterateIPLDBlocks()].map((block) => [\n        `${block.cid}`,\n        block,\n    ]));\n    const site = Delegation.view({\n        root: /** @type {API.UCANLink<[import('@web3-storage/content-claims/capability/api').AssertLocation]>} */ (acceptReceipt.out.ok?.site),\n        blocks,\n    });\n    return { site };\n}\n/** Returns the ability used by an invocation. */\nexport const ability = SpaceBlobCapabilities.add.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('multiformats').MultihashDigest} digest\n * @param {number} size\n */\nexport const input = (digest, size) => ({\n    blob: {\n        digest: digest.bytes,\n        size,\n    },\n});\n//# sourceMappingURL=add.js.map", "import * as BlobCapabilities from '@storacha/capabilities/space/blob';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport { servicePrincipal, connection } from '../service.js';\n/**\n * Gets a stored Blob file by digest.\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/get/0/1` delegated capability.\n * @param {import('multiformats').MultihashDigest} multihash of the blob\n * @param {import('../types.js').RequestOptions} [options]\n */\nexport async function get({ issuer, with: resource, proofs, audience }, multihash, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await BlobCapabilities.get\n        .invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? servicePrincipal,\n        with: SpaceDID.from(resource),\n        nb: input(multihash),\n        proofs,\n        nonce: options.nonce,\n    })\n        .execute(conn);\n    if (!result.out.ok) {\n        throw new Error(`failed ${BlobCapabilities.get.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = BlobCapabilities.get.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('multiformats').MultihashDigest} digest\n */\nexport const input = (digest) => ({ digest: digest.bytes });\n//# sourceMappingURL=get.js.map", "import * as BlobCapabilities from '@storacha/capabilities/space/blob';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport { servicePrincipal, connection } from '../service.js';\n/**\n * List Blobs stored in the space.\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/list` delegated capability.\n * @param {import('../types.js').ListRequestOptions} [options]\n * @returns {Promise<import('../types.js').SpaceBlobListSuccess>}\n */\nexport async function list({ issuer, with: resource, proofs, audience }, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await BlobCapabilities.list\n        .invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? servicePrincipal,\n        with: SpaceDID.from(resource),\n        proofs,\n        nb: input(options.cursor, options.size),\n        nonce: options.nonce,\n    })\n        .execute(conn);\n    if (!result.out.ok) {\n        throw new Error(`failed ${BlobCapabilities.list.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = BlobCapabilities.list.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {string} [cursor]\n * @param {number} [size]\n */\nexport const input = (cursor, size) => ({ cursor, size });\n//# sourceMappingURL=list.js.map", "import * as BlobCapabilities from '@storacha/capabilities/space/blob';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport { servicePrincipal, connection } from '../service.js';\n/**\n * Remove a stored Blob file by digest.\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/remove` delegated capability.\n * @param {import('multiformats').MultihashDigest} multihash of the blob\n * @param {import('../types.js').RequestOptions} [options]\n */\nexport async function remove({ issuer, with: resource, proofs, audience }, multihash, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await BlobCapabilities.remove\n        .invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? servicePrincipal,\n        with: SpaceDID.from(resource),\n        nb: input(multihash),\n        proofs,\n        nonce: options.nonce,\n    })\n        .execute(conn);\n    if (!result.out.ok) {\n        throw new Error(`failed ${BlobCapabilities.remove.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = BlobCapabilities.remove.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('multiformats').MultihashDigest} digest\n */\nexport const input = (digest) => ({ digest: digest.bytes });\n//# sourceMappingURL=remove.js.map", "import * as BlobCapabilities from '@storacha/capabilities/space/blob';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport { servicePrincipal, connection } from '../service.js';\n/**\n * @import { MultihashDigest } from 'multiformats'\n * @import { Delegation } from '@ucanto/interface'\n * @import { AssertLocation } from '@web3-storage/content-claims/capability/api'\n */\n/**\n * Replicate a stored Blob by digest to the specified number of nodes.\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `space/blob/replicate` delegated capability.\n * @param {object} blob Details of the blob to replicate.\n * @param {MultihashDigest} blob.digest Hash of the blob.\n * @param {number} blob.size Total size of the blob in bytes.\n * @param {Delegation<[AssertLocation]>} site Location commitment describing\n * where the blob may be retrieved.\n * @param {number} replicas Total number of replicas to provision.\n * @param {import('../types.js').RequestOptions} [options]\n */\nexport async function replicate({ issuer, with: resource, proofs, audience }, blob, site, replicas, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const receipt = await BlobCapabilities.replicate\n        .invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? servicePrincipal,\n        with: SpaceDID.from(resource),\n        nb: input(blob, site, replicas),\n        proofs: [...proofs, site],\n        nonce: options.nonce,\n    })\n        .execute(conn);\n    if (!receipt.out.ok) {\n        throw new Error(`failed ${BlobCapabilities.replicate.can} invocation`, {\n            cause: receipt.out.error,\n        });\n    }\n    return receipt.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = BlobCapabilities.replicate.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {object} blob Details of the blob to replicate.\n * @param {MultihashDigest} blob.digest Hash of the blob.\n * @param {number} blob.size Total size of the blob in bytes.\n * @param {Delegation<[AssertLocation]>} site Location commitment describing\n * where the blob may be retrieved.\n * @param {number} replicas Total number of replicas to provision.\n */\nexport const input = (blob, site, replicas) => ({\n    blob: {\n        digest: blob.digest.bytes,\n        size: blob.size,\n    },\n    site: site.cid,\n    replicas,\n});\n//# sourceMappingURL=replicate.js.map", "export { add } from './add.js';\n//# sourceMappingURL=index.js.map", "import * as IndexCapabilities from '@storacha/capabilities/space/index';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport retry from 'p-retry';\nimport { servicePrincipal, connection } from '../service.js';\nimport { REQUEST_RETRIES } from '../constants.js';\n/**\n * Register an \"index\" with the service. The issuer needs the `index/add`\n * delegated capability.\n *\n * Required delegated capability proofs: `index/add`\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `index/add` delegated capability.\n * @param {import('../types.js').CARLink} index Index to store.\n * @param {import('../types.js').RequestOptions} [options]\n * @returns {Promise<import('../types.js').SpaceIndexAddSuccess>}\n */\nexport async function add({ issuer, with: resource, proofs, audience }, index, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await retry(async () => {\n        return await IndexCapabilities.add\n            .invoke({\n            issuer,\n            /* c8 ignore next */\n            audience: audience ?? servicePrincipal,\n            with: SpaceDID.from(resource),\n            nb: input(index),\n            proofs,\n        })\n            .execute(conn);\n    }, {\n        onFailedAttempt: console.warn,\n        retries: options.retries ?? REQUEST_RETRIES,\n    });\n    if (!result.out.ok) {\n        throw new Error(`failed ${IndexCapabilities.add.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = IndexCapabilities.add.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('../types.js').CARLink} index\n */\nexport const input = (index) => ({ index });\n//# sourceMappingURL=add.js.map", "export { add } from './add.js';\nexport { get } from './get.js';\nexport { list } from './list.js';\nexport { remove } from './remove.js';\n//# sourceMappingURL=index.js.map", "import * as UploadCapabilities from '@storacha/capabilities/upload';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport retry from 'p-retry';\nimport { servicePrincipal, connection } from '../service.js';\nimport { REQUEST_RETRIES } from '../constants.js';\n/**\n * Register an \"upload\" with the service. The issuer needs the `upload/add`\n * delegated capability.\n *\n * Required delegated capability proofs: `upload/add`\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `upload/add` delegated capability.\n * @param {import('multiformats/link').UnknownLink} root Root data CID for the DAG that was stored.\n * @param {import('../types.js').CARLink[]} shards CIDs of CAR files that contain the DAG.\n * @param {import('../types.js').RequestOptions} [options]\n * @returns {Promise<import('../types.js').UploadAddSuccess>}\n */\nexport async function add({ issuer, with: resource, proofs, audience }, root, shards, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await retry(async () => {\n        return await UploadCapabilities.add\n            .invoke({\n            issuer,\n            /* c8 ignore next */\n            audience: audience ?? servicePrincipal,\n            with: SpaceDID.from(resource),\n            nb: input(root, shards),\n            proofs,\n            nonce: options.nonce,\n        })\n            .execute(conn);\n    }, {\n        onFailedAttempt: console.warn,\n        retries: options.retries ?? REQUEST_RETRIES,\n    });\n    if (!result.out.ok) {\n        throw new Error(`failed ${UploadCapabilities.add.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = UploadCapabilities.add.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('multiformats/link').UnknownLink} root\n * @param {import('../types.js').CARLink[]} shards\n */\nexport const input = (root, shards) => ({ root, shards });\n//# sourceMappingURL=add.js.map", "import * as UploadCapabilities from '@storacha/capabilities/upload';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport retry from 'p-retry';\nimport { servicePrincipal, connection } from '../service.js';\nimport { REQUEST_RETRIES } from '../constants.js';\n/**\n * Get details of an \"upload\".\n *\n * Required delegated capability proofs: `upload/get`\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `upload/get` delegated capability.\n * @param {import('multiformats/link').UnknownLink} root Root data CID for the DAG that was stored.\n * @param {import('../types.js').RequestOptions} [options]\n * @returns {Promise<import('../types.js').UploadGetSuccess>}\n */\nexport async function get({ issuer, with: resource, proofs, audience }, root, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await retry(async () => {\n        return await UploadCapabilities.get\n            .invoke({\n            issuer,\n            /* c8 ignore next */\n            audience: audience ?? servicePrincipal,\n            with: SpaceDID.from(resource),\n            nb: input(root),\n            proofs,\n            nonce: options.nonce,\n        })\n            .execute(conn);\n    }, {\n        onFailedAttempt: console.warn,\n        retries: options.retries ?? REQUEST_RETRIES,\n    });\n    if (!result.out.ok) {\n        throw new Error(`failed ${UploadCapabilities.get.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = UploadCapabilities.get.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('multiformats/link').UnknownLink} root\n */\nexport const input = (root) => ({ root });\n//# sourceMappingURL=get.js.map", "import * as UploadCapabilities from '@storacha/capabilities/upload';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport { servicePrincipal, connection } from '../service.js';\n/**\n * List uploads created by the issuer.\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `upload/list` delegated capability.\n * @param {import('../types.js').ListRequestOptions} [options]\n * @returns {Promise<import('../types.js').UploadListSuccess>}\n */\nexport async function list({ issuer, with: resource, proofs, audience }, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await UploadCapabilities.list\n        .invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? servicePrincipal,\n        with: SpaceDID.from(resource),\n        proofs,\n        nb: input(options.cursor, options.size, options.pre),\n        nonce: options.nonce,\n    })\n        .execute(conn);\n    if (!result.out.ok) {\n        throw new Error(`failed ${UploadCapabilities.list.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = UploadCapabilities.list.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {string} [cursor]\n * @param {number} [size]\n * @param {boolean} [pre]\n */\nexport const input = (cursor, size, pre) => ({ cursor, size, pre });\n//# sourceMappingURL=list.js.map", "import * as UploadCapabilities from '@storacha/capabilities/upload';\nimport { SpaceDID } from '@storacha/capabilities/utils';\nimport { servicePrincipal, connection } from '../service.js';\n/**\n * Remove an upload by root data CID.\n *\n * @param {import('../types.js').InvocationConfig} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `upload/remove` delegated capability.\n * @param {import('multiformats').UnknownLink} root Root data CID to remove.\n * @param {import('../types.js').RequestOptions} [options]\n */\nexport async function remove({ issuer, with: resource, proofs, audience }, root, options = {}) {\n    /* c8 ignore next */\n    const conn = options.connection ?? connection;\n    const result = await UploadCapabilities.remove\n        .invoke({\n        issuer,\n        /* c8 ignore next */\n        audience: audience ?? servicePrincipal,\n        with: SpaceDID.from(resource),\n        nb: input(root),\n        proofs,\n        nonce: options.nonce,\n    })\n        .execute(conn);\n    if (!result.out.ok) {\n        throw new Error(`failed ${UploadCapabilities.remove.can} invocation`, {\n            cause: result.out.error,\n        });\n    }\n    return result.out.ok;\n}\n/** Returns the ability used by an invocation. */\nexport const ability = UploadCapabilities.remove.can;\n/**\n * Returns required input to the invocation.\n *\n * @param {import('multiformats').UnknownLink} root\n */\nexport const input = (root) => ({ root });\n//# sourceMappingURL=remove.js.map", "import * as PB from \"@ipld/dag-pb\"\nimport * as UnixFS from \"./unixfs.js\"\nimport { NodeType } from \"./unixfs.js\"\nimport { Data } from \"../gen/unixfs.js\"\n\nexport * from \"./unixfs.js\"\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([])\nconst EMPTY_BUFFER = new Uint8Array(0)\n\nconst BLANK = Object.freeze({})\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8)\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8)\n\nexport const code = PB.code\nexport const name = \"UnixFS\"\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({ data, links })\n\n  return PB.encode(\n    // We run through prepare as links need to be sorted by name which it will\n    // do.\n    PB.prepare({\n      Data: Data.encode(data).finish(),\n      // We can cast to mutable array as we know no mutation occurs there\n      Links:\n        /** @type {PB.PBLink[]} */ (links),\n    })\n  )\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content,\n})\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata =>\n  createSimpleFile(EMPTY_BUFFER, metadata)\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n})\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries,\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (\n  entries,\n  bitfield,\n  fanout,\n  hashType,\n  metadata = BLANK\n) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n})\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content =>\n  encodePB(\n    {\n      Type: NodeType.Raw,\n      // TODO:\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      // @ts-ignore\n      blocksizes: EMPTY,\n    },\n    []\n  )\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata)\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata)\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata)\n    default:\n      throw new TypeError(\n        `File with unknown layout \"${Object(node).layout}\" was passed`\n      )\n  }\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK)\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n\n      ...encodeMetadata(metadata),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid,\n})\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      // adding empty file to both go-ipfs and js-ipfs produces block in\n      // which `Data` is omitted but filesize and blocksizes are present.\n      // For the sake of hash consistency we do the same.\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      blocksizes: [],\n      ...encodeMetadata(metadata),\n    },\n    []\n  )\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      Data: content,\n      filesize: content.byteLength + cumulativeContentByteLength(parts),\n      blocksizes: parts.map(contentByteLength),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node =>\n  encodePB(\n    {\n      Type: node.type,\n      ...encodeDirectoryMetadata(node.metadata || BLANK),\n    },\n    node.entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK,\n}) =>\n  encodePB(\n    {\n      Type: NodeType.HAMTShard,\n      Data: bitfield.byteLength > 0 ? bitfield : undefined,\n      fanout: readFanout(fanout),\n      hashType: readInt(hashType),\n\n      ...encodeDirectoryMetadata(metadata),\n    },\n    entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n\n  } else {\n    throw new TypeError(\n      `Expected hamt size to be a power of two instead got ${n}`\n    )\n  }\n}\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => (bytes.byteLength > 0 ? bytes : undefined)\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB(\n    {\n      Type: NodeType.Symlink,\n      Data: node.content,\n      ...encodeMetadata(metadata || BLANK),\n    },\n    []\n  )\n}\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content)\n    case NodeType.File:\n      return encodeFile(node)\n    case NodeType.Directory:\n      return encodeDirectory(node)\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node)\n    case NodeType.Symlink:\n      return encodeSymlink(node)\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`)\n  }\n}\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes)\n  const message = Data.decode(/** @type {Uint8Array} */ (pb.Data))\n\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false,\n  })\n  const metadata = {\n    ...(mode && { mode }),\n    ...decodeMtime(mtime),\n  }\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links\n\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data)\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata)\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      } else {\n        return new ComplexFileView(\n          data,\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata)\n    case NodeType.HAMTShard:\n      return createShardedDirectory(\n        decodeDirectoryLinks(links),\n        data || EMPTY_BUFFER,\n        rest.fanout,\n        rest.hashType,\n        metadata\n      )\n    case NodeType.Symlink:\n      return createSymlink(data, metadata)\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`)\n  }\n}\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime =>\n  mtime == null\n    ? undefined\n    : {\n        mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 },\n      }\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? { blocksizes } : undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = []\n  const length = blocksizes.length\n  let n = 0\n  while (n < length) {\n    parts.push(\n      /** @type {UnixFS.FileLink} */ ({\n        cid: links[n].Hash,\n        dagByteLength: links[n].Tsize || 0,\n        contentByteLength: blocksizes[n],\n      })\n    )\n  }\n  return parts\n}\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links =>\n  links.map(\n    link =>\n      /** @type {UnixFS.DirectoryEntryLink} */ ({\n        cid: link.Hash,\n        name: link.Name || \"\",\n        dagByteLength: link.Tsize || 0,\n      })\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links =>\n  links.reduce((size, link) => size + link.contentByteLength, 0)\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) =>\n  links.reduce((size, link) => size + link.dagByteLength, root.byteLength)\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({ name, dagByteLength, cid }) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid,\n})\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata =>\n  encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE)\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = (\n  { mode, mtime },\n  defaultMode = DEFAULT_FILE_MODE\n) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined,\n})\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data =>\n  data == null\n    ? BLANK\n    : {\n        ...(data.mode == null ? undefined : { mode: decodeMode(data.mode) }),\n        ...(data.mtime == null ? undefined : { mtime: data.mtime }),\n      }\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null\n    ? undefined\n    : mtime.nsecs !== 0\n    ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs }\n    : { Seconds: mtime.secs }\n}\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode)\n  return mode === defaultMode || mode == null ? undefined : mode\n}\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => (mode & 0xfff) | (mode & 0xfffff000)\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata)\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata)\n  } else {\n    return new ComplexFileView(content, parts, metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content\n    this.metadata = metadata\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\"\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File\n  }\n\n  get filesize() {\n    return this.content.byteLength\n  }\n\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata)\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts)\n        case \"complex\":\n          return (\n            node.content.byteLength + cumulativeContentByteLength(node.parts)\n          )\n      }\n    default:\n      return 0\n  }\n}\n", "const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n", "const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n", "import { CID } from 'multiformats/cid'\n\n/* eslint-disable complexity, no-nested-ternary */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n", "import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink, toByteView } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode> | ArrayBufferView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const buf = toByteView(bytes)\n  const pbn = decodeNode(buf)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch {\n        // ignore parse fail\n      }\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n", "/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots.unixfs || ($protobuf.roots.unixfs = {});\n\nexport const Data = $root.Data = (() => {\n\n    /**\n     * Properties of a Data.\n     * @exports IData\n     * @interface IData\n     * @property {Data.DataType} Type Data Type\n     * @property {Uint8Array|null} [Data] Data Data\n     * @property {number|null} [filesize] Data filesize\n     * @property {Array.<number>|null} [blocksizes] Data blocksizes\n     * @property {number|null} [hashType] Data hashType\n     * @property {number|null} [fanout] Data fanout\n     * @property {number|null} [mode] Data mode\n     * @property {IUnixTime|null} [mtime] Data mtime\n     */\n\n    /**\n     * Constructs a new Data.\n     * @exports Data\n     * @classdesc Represents a Data.\n     * @implements IData\n     * @constructor\n     * @param {IData=} [p] Properties to set\n     */\n    function Data(p) {\n        this.blocksizes = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Data Type.\n     * @member {Data.DataType} Type\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Type = 0;\n\n    /**\n     * Data Data.\n     * @member {Uint8Array} Data\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Data filesize.\n     * @member {number} filesize\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data blocksizes.\n     * @member {Array.<number>} blocksizes\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.blocksizes = $util.emptyArray;\n\n    /**\n     * Data hashType.\n     * @member {number} hashType\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data fanout.\n     * @member {number} fanout\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data mode.\n     * @member {number} mode\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mode = 0;\n\n    /**\n     * Data mtime.\n     * @member {IUnixTime|null|undefined} mtime\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mtime = null;\n\n    /**\n     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encode\n     * @memberof Data\n     * @static\n     * @param {IData} m Data message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Data.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\"))\n            w.uint32(18).bytes(m.Data);\n        if (m.filesize != null && Object.hasOwnProperty.call(m, \"filesize\"))\n            w.uint32(24).uint64(m.filesize);\n        if (m.blocksizes != null && m.blocksizes.length) {\n            for (var i = 0; i < m.blocksizes.length; ++i)\n                w.uint32(32).uint64(m.blocksizes[i]);\n        }\n        if (m.hashType != null && Object.hasOwnProperty.call(m, \"hashType\"))\n            w.uint32(40).uint64(m.hashType);\n        if (m.fanout != null && Object.hasOwnProperty.call(m, \"fanout\"))\n            w.uint32(48).uint64(m.fanout);\n        if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n            w.uint32(56).uint32(m.mode);\n        if (m.mtime != null && Object.hasOwnProperty.call(m, \"mtime\"))\n            $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes a Data message from the specified reader or buffer.\n     * @function decode\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Data.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            case 3:\n                m.filesize = r.uint64();\n                break;\n            case 4:\n                if (!(m.blocksizes && m.blocksizes.length))\n                    m.blocksizes = [];\n                if ((t & 7) === 2) {\n                    var c2 = r.uint32() + r.pos;\n                    while (r.pos < c2)\n                        m.blocksizes.push(r.uint64());\n                } else\n                    m.blocksizes.push(r.uint64());\n                break;\n            case 5:\n                m.hashType = r.uint64();\n                break;\n            case 6:\n                m.fanout = r.uint64();\n                break;\n            case 7:\n                m.mode = r.uint32();\n                break;\n            case 8:\n                m.mtime = $root.UnixTime.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a Data message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Data} Data\n     */\n    Data.fromObject = function fromObject(d) {\n        if (d instanceof $root.Data)\n            return d;\n        var m = new $root.Data();\n        switch (d.Type) {\n        case \"Raw\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Directory\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"File\":\n        case 2:\n            m.Type = 2;\n            break;\n        case \"Metadata\":\n        case 3:\n            m.Type = 3;\n            break;\n        case \"Symlink\":\n        case 4:\n            m.Type = 4;\n            break;\n        case \"HAMTShard\":\n        case 5:\n            m.Type = 5;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        if (d.filesize != null) {\n            if ($util.Long)\n                (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;\n            else if (typeof d.filesize === \"string\")\n                m.filesize = parseInt(d.filesize, 10);\n            else if (typeof d.filesize === \"number\")\n                m.filesize = d.filesize;\n            else if (typeof d.filesize === \"object\")\n                m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n        }\n        if (d.blocksizes) {\n            if (!Array.isArray(d.blocksizes))\n                throw TypeError(\".Data.blocksizes: array expected\");\n            m.blocksizes = [];\n            for (var i = 0; i < d.blocksizes.length; ++i) {\n                if ($util.Long)\n                    (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;\n                else if (typeof d.blocksizes[i] === \"string\")\n                    m.blocksizes[i] = parseInt(d.blocksizes[i], 10);\n                else if (typeof d.blocksizes[i] === \"number\")\n                    m.blocksizes[i] = d.blocksizes[i];\n                else if (typeof d.blocksizes[i] === \"object\")\n                    m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n            }\n        }\n        if (d.hashType != null) {\n            if ($util.Long)\n                (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;\n            else if (typeof d.hashType === \"string\")\n                m.hashType = parseInt(d.hashType, 10);\n            else if (typeof d.hashType === \"number\")\n                m.hashType = d.hashType;\n            else if (typeof d.hashType === \"object\")\n                m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n        }\n        if (d.fanout != null) {\n            if ($util.Long)\n                (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;\n            else if (typeof d.fanout === \"string\")\n                m.fanout = parseInt(d.fanout, 10);\n            else if (typeof d.fanout === \"number\")\n                m.fanout = d.fanout;\n            else if (typeof d.fanout === \"object\")\n                m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n        }\n        if (d.mode != null) {\n            m.mode = d.mode >>> 0;\n        }\n        if (d.mtime != null) {\n            if (typeof d.mtime !== \"object\")\n                throw TypeError(\".Data.mtime: object expected\");\n            m.mtime = $root.UnixTime.fromObject(d.mtime);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Data message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Data\n     * @static\n     * @param {Data} m Data\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Data.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.blocksizes = [];\n        }\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"Raw\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.filesize = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.hashType = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.fanout = o.longs === String ? \"0\" : 0;\n            d.mode = 0;\n            d.mtime = null;\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        if (m.filesize != null && m.hasOwnProperty(\"filesize\")) {\n            if (typeof m.filesize === \"number\")\n                d.filesize = o.longs === String ? String(m.filesize) : m.filesize;\n            else\n                d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n        }\n        if (m.blocksizes && m.blocksizes.length) {\n            d.blocksizes = [];\n            for (var j = 0; j < m.blocksizes.length; ++j) {\n                if (typeof m.blocksizes[j] === \"number\")\n                    d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];\n                else\n                    d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n            }\n        }\n        if (m.hashType != null && m.hasOwnProperty(\"hashType\")) {\n            if (typeof m.hashType === \"number\")\n                d.hashType = o.longs === String ? String(m.hashType) : m.hashType;\n            else\n                d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n        }\n        if (m.fanout != null && m.hasOwnProperty(\"fanout\")) {\n            if (typeof m.fanout === \"number\")\n                d.fanout = o.longs === String ? String(m.fanout) : m.fanout;\n            else\n                d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n        }\n        if (m.mode != null && m.hasOwnProperty(\"mode\")) {\n            d.mode = m.mode;\n        }\n        if (m.mtime != null && m.hasOwnProperty(\"mtime\")) {\n            d.mtime = $root.UnixTime.toObject(m.mtime, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Data to JSON.\n     * @function toJSON\n     * @memberof Data\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Data.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * DataType enum.\n     * @name Data.DataType\n     * @enum {number}\n     * @property {number} Raw=0 Raw value\n     * @property {number} Directory=1 Directory value\n     * @property {number} File=2 File value\n     * @property {number} Metadata=3 Metadata value\n     * @property {number} Symlink=4 Symlink value\n     * @property {number} HAMTShard=5 HAMTShard value\n     */\n    Data.DataType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Raw\"] = 0;\n        values[valuesById[1] = \"Directory\"] = 1;\n        values[valuesById[2] = \"File\"] = 2;\n        values[valuesById[3] = \"Metadata\"] = 3;\n        values[valuesById[4] = \"Symlink\"] = 4;\n        values[valuesById[5] = \"HAMTShard\"] = 5;\n        return values;\n    })();\n\n    return Data;\n})();\n\nexport const UnixTime = $root.UnixTime = (() => {\n\n    /**\n     * Properties of an UnixTime.\n     * @exports IUnixTime\n     * @interface IUnixTime\n     * @property {number} Seconds UnixTime Seconds\n     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds\n     */\n\n    /**\n     * Constructs a new UnixTime.\n     * @exports UnixTime\n     * @classdesc Represents an UnixTime.\n     * @implements IUnixTime\n     * @constructor\n     * @param {IUnixTime=} [p] Properties to set\n     */\n    function UnixTime(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * UnixTime Seconds.\n     * @member {number} Seconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n    /**\n     * UnixTime FractionalNanoseconds.\n     * @member {number} FractionalNanoseconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.FractionalNanoseconds = 0;\n\n    /**\n     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.\n     * @function encode\n     * @memberof UnixTime\n     * @static\n     * @param {IUnixTime} m UnixTime message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    UnixTime.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int64(m.Seconds);\n        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, \"FractionalNanoseconds\"))\n            w.uint32(21).fixed32(m.FractionalNanoseconds);\n        return w;\n    };\n\n    /**\n     * Decodes an UnixTime message from the specified reader or buffer.\n     * @function decode\n     * @memberof UnixTime\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {UnixTime} UnixTime\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    UnixTime.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Seconds = r.int64();\n                break;\n            case 2:\n                m.FractionalNanoseconds = r.fixed32();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Seconds\"))\n            throw $util.ProtocolError(\"missing required 'Seconds'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof UnixTime\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {UnixTime} UnixTime\n     */\n    UnixTime.fromObject = function fromObject(d) {\n        if (d instanceof $root.UnixTime)\n            return d;\n        var m = new $root.UnixTime();\n        if (d.Seconds != null) {\n            if ($util.Long)\n                (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;\n            else if (typeof d.Seconds === \"string\")\n                m.Seconds = parseInt(d.Seconds, 10);\n            else if (typeof d.Seconds === \"number\")\n                m.Seconds = d.Seconds;\n            else if (typeof d.Seconds === \"object\")\n                m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n        }\n        if (d.FractionalNanoseconds != null) {\n            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof UnixTime\n     * @static\n     * @param {UnixTime} m UnixTime\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    UnixTime.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, false);\n                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.Seconds = o.longs === String ? \"0\" : 0;\n            d.FractionalNanoseconds = 0;\n        }\n        if (m.Seconds != null && m.hasOwnProperty(\"Seconds\")) {\n            if (typeof m.Seconds === \"number\")\n                d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;\n            else\n                d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n        }\n        if (m.FractionalNanoseconds != null && m.hasOwnProperty(\"FractionalNanoseconds\")) {\n            d.FractionalNanoseconds = m.FractionalNanoseconds;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this UnixTime to JSON.\n     * @function toJSON\n     * @memberof UnixTime\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    UnixTime.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return UnixTime;\n})();\n\nexport const Metadata = $root.Metadata = (() => {\n\n    /**\n     * Properties of a Metadata.\n     * @exports IMetadata\n     * @interface IMetadata\n     * @property {string|null} [MimeType] Metadata MimeType\n     */\n\n    /**\n     * Constructs a new Metadata.\n     * @exports Metadata\n     * @classdesc Represents a Metadata.\n     * @implements IMetadata\n     * @constructor\n     * @param {IMetadata=} [p] Properties to set\n     */\n    function Metadata(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Metadata MimeType.\n     * @member {string} MimeType\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.MimeType = \"\";\n\n    /**\n     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encode\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} m Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.MimeType != null && Object.hasOwnProperty.call(m, \"MimeType\"))\n            w.uint32(10).string(m.MimeType);\n        return w;\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.MimeType = r.string();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Metadata} Metadata\n     */\n    Metadata.fromObject = function fromObject(d) {\n        if (d instanceof $root.Metadata)\n            return d;\n        var m = new $root.Metadata();\n        if (d.MimeType != null) {\n            m.MimeType = String(d.MimeType);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Metadata\n     * @static\n     * @param {Metadata} m Metadata\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Metadata.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.MimeType = \"\";\n        }\n        if (m.MimeType != null && m.hasOwnProperty(\"MimeType\")) {\n            d.MimeType = m.MimeType;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Metadata to JSON.\n     * @function toJSON\n     * @memberof Metadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Metadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Metadata;\n})();\n\nexport { $root as default };\n", "// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n\nimport { Data } from \"../gen/unixfs.js\"\nexport const NodeType = Data.DataType\n", "import * as Task from \"./task.js\"\nexport * from \"./task.js\"\n\n/**\n * Turns a task (that never fails or sends messages) into an effect of it's\n * result.\n *\n * @template T\n * @param {Task.Task<T, never>} task\n * @returns {Task.Effect<T>}\n */\nexport const effect = function* (task) {\n  const message = yield* task\n  yield* send(message)\n}\n\n/**\n * Gets a handle to the task that invoked it. Useful when task needs to\n * suspend execution until some outside event occurs, in which case handle\n * can be used resume execution (see `suspend` code example for more details)\n *\n * @template T, M, X\n * @returns {Task.Task<Task.Controller<T, X, M>, never>}\n */\nexport function* current() {\n  return /** @type {Task.Controller<T, X, M>} */ (yield CURRENT)\n}\n\n/**\n * Suspends the current task (task that invokes it),  which can then be\n * resumed from another task or an outside event (e.g. `setTimeout` callback)\n * by calling the `resume` with an task's handle.\n *\n * Calling this in almost all cases is preceeded by call to `current()` in\n * order to obtain a `handle` which can be passed to `resume` function\n * to resume the execution.\n *\n * Note: This task never fails, although it may never resume either. However\n * you can utilize `finally` block to do a necessary cleanup in case execution\n * is aborted.\n *\n * @example\n * ```js\n * import { current, suspend, resume } from \"actor\"\n * function * sleep(duration) {\n *    // get a reference to this task so we can resume it.\n *    const self = yield * current()\n *    // resume this task when timeout fires\n *    const id = setTimeout(() => resume(self), duration)\n *    try {\n *      // suspend this task nothing below this line will run until task is\n *      // resumed.\n *      yield * suspend()\n *    } finally {\n *      // if task is aborted finally block will still run which given you\n *      // chance to cleanup.\n *      clearTimeout(id)\n *    }\n * }\n * ```\n *\n * @returns {Task.Task<void, never>}\n */\nexport const suspend = function* () {\n  yield SUSPEND\n}\n\n/**\n * Suspends execution for the given duration in milliseconds, after which\n * execution is resumed (unless it was aborted in the meantime).\n *\n * @example\n * ```js\n * function * demo() {\n *    console.log(\"I'm going to take small nap\")\n *    yield * sleep(200)\n *    console.log(\"I am back to work\")\n * }\n * ```\n *\n * @param {number} [duration]\n * @returns {Task.Task<void, never>}\n */\nexport function* sleep(duration = 0) {\n  const task = yield* current()\n  const id = setTimeout(enqueue, duration, task)\n\n  try {\n    yield* suspend()\n  } finally {\n    clearTimeout(id)\n  }\n}\n\n/**\n * Provides equivalent of `await` in async functions. Specifically it takes\n * a value that you can `await` on (that is `Promise<T>|T`) and suspends\n * execution until promise is settled. If promise succeeds execution is resumed\n * with `T` otherwise an error of type `X` is thrown (which is by default\n * `unknown` since promises do not encode error type).\n *\n * It is useful when you need to deal with potentially async set of operations\n * without having to check if thing is a promise at every step.\n *\n * Please note: This that execution is suspended even if given value is not a\n * promise, however scheduler will still resume it in the same tick of the event\n * loop after, just processing other scheduled tasks. This avoids problematic\n * race condititions that can otherwise occur when values are sometimes promises\n * and other times are not.\n *\n * @example\n * ```js\n * function * fetchJSON (url, options) {\n *    const response = yield * wait(fetch(url, options))\n *    const json = yield * wait(response.json())\n *    return json\n * }\n * ```\n *\n * @template T, [X=unknown]\n * @param {Task.Await<T>} input\n * @returns {Task.Task<T, Error>}\n */\nexport const wait = function* (input) {\n  const task = yield* current()\n  if (isAsync(input)) {\n    let failed = false\n    /** @type {unknown} */\n    let output = undefined\n    input.then(\n      value => {\n        failed = false\n        output = value\n        enqueue(task)\n      },\n      error => {\n        failed = true\n        output = error\n        enqueue(task)\n      }\n    )\n\n    yield* suspend()\n    if (failed) {\n      throw output\n    } else {\n      return /** @type {T} */ (output)\n    }\n  } else {\n    // This may seem redundunt but it is not, by enqueuing this task we allow\n    // scheduler to perform other queued tasks first. This way many race\n    // conditions can be avoided when values are sometimes promises and other\n    // times aren't.\n    // Unlike `await` however this will resume in the same tick.\n    main(wake(task))\n    yield* suspend()\n    return input\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n * @returns {Task.Task<void, never, never>}\n */\nfunction* wake(task) {\n  enqueue(task)\n}\n\n/**\n * Checks if value value is a promise (or it's lookalike).\n *\n * @template T\n * @param {any} node\n * @returns {node is PromiseLike<T>}\n */\n\nconst isAsync = node =>\n  node != null &&\n  typeof (/** @type {{then?:unknown}} */ (node).then) === \"function\"\n\n/**\n * Task that sends given message (or rather an effect producing this message).\n * Please note, that while you could use `yield message` instead, but you'd risk\n * having to deal with potential breaking changes if library internals change\n * in the future, which in fact may happen as anticipated improvements in\n * TS generator inference could enable replace need for `yield *`.\n *\n * @see https://github.com/microsoft/TypeScript/issues/43632\n *\n * @template T\n * @param {T} message\n * @returns {Task.Effect<T>}\n */\nexport const send = function* (message) {\n  yield /** @type {Task.Message<T>} */ (message)\n}\n\n/**\n * Takes several effects and merges them into a single effect of tagged\n * variants so that their source could be identified via `type` field.\n *\n * @example\n * ```js\n * listen({\n *    read: Task.effect(dbRead),\n *    write: Task.effect(dbWrite)\n * })\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {{ [K in Tag]: Task.Effect<T> }} source\n * @returns {Task.Effect<Tagged<Tag, T>>}\n */\nexport const listen = function* (source) {\n  /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */\n  const forks = []\n  for (const entry of Object.entries(source)) {\n    const [name, effect] = /** @type {[Tag, Task.Effect<T>]} */ (entry)\n    if (effect !== NONE) {\n      forks.push(yield* fork(tag(effect, name)))\n    }\n  }\n\n  yield* group(forks)\n}\n\n/**\n * Takes several tasks and creates an effect of them all.\n *\n * @example\n * ```js\n * Task.effects([\n *    dbRead,\n *    dbWrite\n * ])\n * ```\n *\n * @template {string} Tag\n * @template T\n * @param {Task.Task<T, never>[]} tasks\n * @returns {Task.Effect<T>}\n */\n\nexport const effects = tasks =>\n  tasks.length > 0 ? batch(tasks.map(effect)) : NONE\n\n/**\n * Takes several effects and combines them into a one.\n *\n * @template T\n * @param {Task.Effect<T>[]} effects\n * @returns {Task.Effect<T>}\n */\nexport function* batch(effects) {\n  const forks = []\n  for (const effect of effects) {\n    forks.push(yield* fork(effect))\n  }\n\n  yield* group(forks)\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @typedef {{type: Tag} & {[K in Tag]: T}} Tagged\n */\n/**\n * Tags an effect by boxing each event with an object that has `type` field\n * corresponding to given tag and same named field holding original message\n * e.g. given `nums` effect that produces numbers, `tag(nums, \"inc\")` would\n * create an effect that produces events like `{type:'inc', inc:1}`.\n *\n * @template {string} Tag\n * @template T, M, X\n * @param {Task.Task<T, X, M>} effect\n * @param {Tag} tag\n * @returns {Task.Task<T, X, Tagged<Tag, M>>}\n */\nexport const tag = (effect, tag) =>\n  // @ts-ignore\n  effect === NONE\n    ? NONE\n    : effect instanceof Tagger\n    ? new Tagger([...effect.tags, tag], effect.source)\n    : new Tagger([tag], effect)\n\n/**\n * @template {string} Tag\n * @template Success, Failure, Message\n *\n * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}\n * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}\n */\nclass Tagger {\n  /**\n   * @param {Task.Task<Success, Failure, Message>} source\n   * @param {string[]} tags\n   */\n  constructor(tags, source) {\n    this.tags = tags\n    this.source = source\n    /** @type {Task.Controller<Success, Failure, Message>} */\n    this.controller\n  }\n  /* c8 ignore next 3 */\n  [Symbol.iterator]() {\n    if (!this.controller) {\n      this.controller = this.source[Symbol.iterator]()\n    }\n    return this\n  }\n  /**\n   * @param {Task.TaskState<Success, Message>} state\n   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}\n   */\n  box(state) {\n    if (state.done) {\n      return state\n    } else {\n      switch (state.value) {\n        case SUSPEND:\n        case CURRENT:\n          return /** @type {Task.TaskState<Success, Tagged<Tag, Message>>} */ (\n            state\n          )\n        default: {\n          // Instead of boxing result at each transform step we perform in-place\n          // mutation as we know nothing else is accessing this value.\n          const tagged = /** @type {{ done: false, value: any }} */ (state)\n          let { value } = tagged\n          for (const tag of this.tags) {\n            value = withTag(tag, value)\n          }\n          tagged.value = value\n          return tagged\n        }\n      }\n    }\n  }\n  /**\n   *\n   * @param {Task.Instruction<Message>} instruction\n   */\n  next(instruction) {\n    return this.box(this.controller.next(instruction))\n  }\n  /**\n   *\n   * @param {Failure} error\n   */\n  throw(error) {\n    return this.box(this.controller.throw(error))\n  }\n  /**\n   * @param {Success} value\n   */\n  return(value) {\n    return this.box(this.controller.return(value))\n  }\n\n  get [Symbol.toStringTag]() {\n    return \"TaggedEffect\"\n  }\n}\n\n/**\n * Returns empty `Effect`, that is produces no messages. Kind of like `[]` or\n * `\"\"` but for effects.\n *\n * @type {() => Task.Effect<never>}\n */\nexport const none = () => NONE\n\n/**\n * Takes iterable of tasks and runs them concurrently, returning array of\n * results in an order of tasks (not the order of completion). If any of the\n * tasks fail all the rest are aborted and error is throw into calling task.\n *\n * > This is basically equivalent of `Promise.all` except cancelation logic\n * because tasks unlike promises can be cancelled.\n *\n * @template T, X\n * @param {Iterable<Task.Task<T, X>>} tasks\n * @returns {Task.Task<T[], X>}\n */\nexport const all = function* (tasks) {\n  const self = yield* current()\n\n  /** @type {(id:number) => (value:T) => void} */\n  const succeed = id => value => {\n    delete forks[id]\n    results[id] = value\n    count -= 1\n    if (count === 0) {\n      enqueue(self)\n    }\n  }\n\n  /** @type {(error:X) => void} */\n  const fail = error => {\n    for (const handle of forks) {\n      if (handle) {\n        enqueue(abort(handle, error))\n      }\n    }\n\n    enqueue(abort(self, error))\n  }\n\n  /** @type {Task.Fork<void, never>[]} */\n  let forks = []\n  let count = 0\n  for (const task of tasks) {\n    forks.push(yield* fork(then(task, succeed(count++), fail)))\n  }\n  const results = new Array(count)\n\n  if (count > 0) {\n    yield* suspend()\n  }\n\n  return results\n}\n\n/**\n * @template {string} Tag\n * @template T\n * @param {Tag} tag\n * @param {Task.Message<T>} value\n */\nconst withTag = (tag, value) =>\n  /** @type {Tagged<Tag, T>} */\n  ({ type: tag, [tag]: value })\n\n/**\n * Kind of like promise.then which is handy when you want to extract result\n * from the given task from the outside.\n *\n * @template T, U, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {(value:T) => U} resolve\n * @param {(error:X) => U} reject\n * @returns {Task.Task<U, never, M>}\n */\nexport function* then(task, resolve, reject) {\n  try {\n    return resolve(yield* task)\n  } catch (error) {\n    return reject(/** @type {X} */ (error))\n  }\n}\n\n// Special control instructions recognized by a scheduler.\nconst CURRENT = Symbol(\"current\")\nconst SUSPEND = Symbol(\"suspend\")\n/** @typedef {typeof SUSPEND|typeof CURRENT} Control */\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is M}\n */\nexport const isMessage = value => {\n  switch (value) {\n    case SUSPEND:\n    case CURRENT:\n      return false\n    default:\n      return true\n  }\n}\n\n/**\n * @template M\n * @param {Task.Instruction<M>} value\n * @returns {value is Control}\n */\nexport const isInstruction = value => !isMessage(value)\n\n/**\n * @template T, X, M\n * @implements {Task.TaskGroup<T, X, M>}\n */\nclass Group {\n  /**\n   * @template T, X, M\n   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member\n   * @returns {Task.Group<T, X, M>}\n   */\n  static of(member) {\n    return (\n      /** @type {{group?:Task.TaskGroup<T, X, M>}} */ (member).group || MAIN\n    )\n  }\n\n  /**\n   * @template T, X, M\n   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member\n   * @param {Task.TaskGroup<T, X, M>} group\n   */\n  static enqueue(member, group) {\n    member.group = group\n    group.stack.active.push(member)\n  }\n  /**\n   * @param {Task.Controller<T, X, M>} driver\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   * @param {Task.Stack<T, X, M>} [stack]\n   */\n  constructor(\n    driver,\n    active = [],\n    idle = new Set(),\n    stack = new Stack(active, idle)\n  ) {\n    this.driver = driver\n    this.parent = Group.of(driver)\n    this.stack = stack\n    this.id = ++ID\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Main<T, X, M>}\n */\nclass Main {\n  constructor() {\n    this.status = IDLE\n    this.stack = new Stack()\n    this.id = /** @type {0} */ (0)\n  }\n}\n\n/**\n * @template T, X, M\n */\nclass Stack {\n  /**\n   * @param {Task.Controller<T, X, M>[]} [active]\n   * @param {Set<Task.Controller<T, X, M>>} [idle]\n   */\n  constructor(active = [], idle = new Set()) {\n    this.active = active\n    this.idle = idle\n  }\n\n  /**\n   *\n   * @param {Task.Stack<unknown, unknown, unknown>} stack\n   * @returns\n   */\n  static size({ active, idle }) {\n    return active.length + idle.size\n  }\n}\n\n/**\n * Starts a main task.\n *\n * @param {Task.Task<void, never>} task\n */\nexport const main = task => enqueue(task[Symbol.iterator]())\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nconst enqueue = task => {\n  let group = Group.of(task)\n  group.stack.active.push(task)\n  group.stack.idle.delete(task)\n\n  // then walk up the group chain and unblock their driver tasks.\n  while (group.parent) {\n    const { idle, active } = group.parent.stack\n    if (idle.has(group.driver)) {\n      idle.delete(group.driver)\n      active.push(group.driver)\n    } else {\n      // if driver was not blocked it must have been unblocked by\n      // other task so stop there.\n      break\n    }\n\n    group = group.parent\n  }\n\n  if (MAIN.status === IDLE) {\n    MAIN.status = ACTIVE\n    while (true) {\n      try {\n        for (const _message of step(MAIN)) {\n        }\n        MAIN.status = IDLE\n        break\n      } catch (_error) {\n        // Top level task may crash and throw an error, but given this is a main\n        // group we do not want to interupt other unrelated tasks, which is why\n        // we discard the error and the task that caused it.\n        MAIN.stack.active.shift()\n      }\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Controller<T, X, M>} task\n */\nexport const resume = task => enqueue(task)\n\n/**\n * @template T, X, M\n * @param {Task.Group<T, X, M>} group\n */\n\nconst step = function* (group) {\n  const { active } = group.stack\n  let task = active[0]\n  group.stack.idle.delete(task)\n  while (task) {\n    /** @type {Task.TaskState<T, M>} */\n    let state = INIT\n    // Keep processing insturctions until task is done, it send suspend request\n    // or it's has been removed from the active queue.\n    //  Group changes require extra care so please make sure to understand\n    // the detail here. It occurs when spawned task(s) are joined into a group\n    // which will change the task driver, that is when `task === active[0]` will\n    // became false and need to to drop the task immediately otherwise race\n    // condition will occur due to task been  driven by multiple concurrent\n    // schedulers.\n    loop: while (!state.done && task === active[0]) {\n      const instruction = state.value\n      switch (instruction) {\n        // if task is suspended we add it to the idle list and break the loop\n        // to move to a next task.\n        case SUSPEND:\n          group.stack.idle.add(task)\n          break loop\n        // if task requested a context (which is usually to suspend itself)\n        // pass back a task reference and continue.\n        case CURRENT:\n          state = task.next(task)\n          break\n        default:\n          // otherwise task sent a message which we yield to the driver and\n          // continue\n          state = task.next(\n            yield /** @type {M & Task.Message<M>}*/ (instruction)\n          )\n          break\n      }\n    }\n\n    // If task is complete, or got suspended we move to a next task\n    active.shift()\n    task = active[0]\n    group.stack.idle.delete(task)\n  }\n}\n\n/**\n * Executes given task concurrently with a current task (task that spawned it).\n * Spawned task is detached from the task that spawned it and it can outlive it\n * and / or fail without affecting a task that spawned it. If you need to wait\n * on concurrent task completion consider using `fork` instead which can be\n * later `joined`. If you just want a to block on task execution you can just\n * `yield* work()` directly instead.\n *\n * @param {Task.Task<void, never, never>} task\n * @returns {Task.Task<void, never>}\n */\nexport function* spawn(task) {\n  main(task)\n}\n\n/**\n * Executes given task concurrently with current task (the task that initiated\n * fork). Froked task is detached from the task that created it and it can\n * outlive it and / or fail without affecting it. You do however get a handle\n * for the fork which could be used to `join` the task, in which case `joining`\n * task will block until fork finishes execution.\n *\n * This is also a primary interface for executing tasks from the outside of the\n * task context. Function returns `Fork` which implements `Promise` interface\n * so it could be awaited. Please note that calling `fork` does not really do\n * anything, it lazily starts execution when you either `await fork(work())`\n * from arbitray context or `yield* fork(work())` in anothe task context.\n *\n * @template T, X, M\n * @param {Task.Task<T, X, M>} task\n * @param {Task.ForkOptions} [options]\n * @returns {Task.Fork<T, X, M>}\n */\nexport const fork = (task, options) => new Fork(task, options)\n\n/**\n * Exits task succesfully with a given return value.\n *\n * @template T, M, X\n * @param  {Task.Controller<T, M, X>} handle\n * @param {T} value\n * @returns {Task.Task<void, never>}\n */\nexport const exit = (handle, value) => conclude(handle, { ok: true, value })\n\n/**\n * Terminates task execution execution. Only takes task that produces no\n * result, if your task has non `void` return type you should use `exit` instead.\n *\n * @template M, X\n * @param {Task.Controller<void, X, M>} handle\n */\nexport const terminate = handle =>\n  conclude(handle, { ok: true, value: undefined })\n\n/**\n * Aborts given task with an error. Task error type should match provided error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {X} [error]\n */\nexport const abort = (handle, error) => conclude(handle, { ok: false, error })\n\n/**\n * Aborts given task with an given error.\n *\n * @template T, M, X\n * @param {Task.Controller<T, X, M>} handle\n * @param {Task.Result<T, X>} result\n * @returns {Task.Task<void, never> & Task.Controller<void, never>}\n */\nfunction* conclude(handle, result) {\n  try {\n    const task = handle\n    const state = result.ok\n      ? task.return(result.value)\n      : task.throw(result.error)\n\n    if (!state.done) {\n      if (state.value === SUSPEND) {\n        const { idle } = Group.of(task).stack\n        idle.add(task)\n      } else {\n        enqueue(task)\n      }\n    }\n  } catch (error) {}\n}\n\n/**\n * Groups multiple forks togather and joins joins them with current task.\n *\n * @template T, X, M\n * @param {Task.Fork<T, X, M>[]} forks\n * @returns {Task.Task<void, X, M>}\n */\nexport function* group(forks) {\n  // Abort eraly if there'se no work todo.\n  if (forks.length === 0) return\n\n  const self = yield* current()\n  /** @type {Task.TaskGroup<T, X, M>} */\n  const group = new Group(self)\n  /** @type {Task.Failure<X>|null} */\n  let failure = null\n\n  for (const fork of forks) {\n    const { result } = fork\n    if (result) {\n      if (!result.ok && !failure) {\n        failure = result\n      }\n      continue\n    }\n    move(fork, group)\n  }\n\n  // Keep work looping until there is nom more work to be done\n  try {\n    if (failure) {\n      throw failure.error\n    }\n\n    while (true) {\n      yield* step(group)\n      if (Stack.size(group.stack) > 0) {\n        yield* suspend()\n      } else {\n        break\n      }\n    }\n  } catch (error) {\n    for (const task of group.stack.active) {\n      yield* abort(task, error)\n    }\n\n    for (const task of group.stack.idle) {\n      yield* abort(task, error)\n      enqueue(task)\n    }\n\n    throw error\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @param {Task.TaskGroup<T, X, M>} group\n */\nconst move = (fork, group) => {\n  const from = Group.of(fork)\n  if (from !== group) {\n    const { active, idle } = from.stack\n    const target = group.stack\n    fork.group = group\n    // If it is idle just move from one group to the other\n    // and update the group task thinks it belongs to.\n    if (idle.has(fork)) {\n      idle.delete(fork)\n      target.idle.add(fork)\n    } else {\n      const index = active.indexOf(fork)\n      // If task is in the job queue, we move it to a target job queue. Moving\n      // top task in the queue requires extra care so it does not end up\n      // processed by two groups which would lead to race. For that reason\n      // `step` loop checks for group changes on each turn.\n      if (index >= 0) {\n        active.splice(index, 1)\n        target.active.push(fork)\n      }\n      // otherwise task is complete\n    }\n  }\n}\n\n/**\n * @template T, X, M\n * @param {Task.Fork<T, X, M>} fork\n * @returns {Task.Task<T, X, M>}\n */\nexport function* join(fork) {\n  // If fork is still idle activate it.\n  if (fork.status === IDLE) {\n    yield* fork\n  }\n\n  if (!fork.result) {\n    yield* group([fork])\n  }\n\n  const result = /** @type {Task.Result<T, X>} */ (fork.result)\n  if (result.ok) {\n    return result.value\n  } else {\n    throw result.error\n  }\n}\n\n/**\n * @template T, X\n * @implements {Task.Future<T, X>}\n */\nclass Future {\n  /**\n   * @param {Task.StateHandler<T, X>} handler\n   */\n  constructor(handler) {\n    this.handler = handler\n    /**\n     * @abstract\n     * @type {Task.Result<T, X>|void}\n     */\n    this.result\n  }\n  /**\n   * @type {Promise<T>}\n   */\n  get promise() {\n    const { result } = this\n    const promise =\n      result == null\n        ? new Promise((succeed, fail) => {\n            this.handler.onsuccess = succeed\n            this.handler.onfailure = fail\n          })\n        : result.ok\n        ? Promise.resolve(result.value)\n        : Promise.reject(result.error)\n    Object.defineProperty(this, \"promise\", { value: promise })\n    return promise\n  }\n\n  /**\n   * @template U, [E=never]\n   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]\n   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]\n   * @returns {Promise<U|E>}\n   */\n  then(onresolve, onreject) {\n    return this.activate().promise.then(onresolve, onreject)\n  }\n  /**\n   * @template [U=never]\n   * @param {(error:X) => U} onreject\n   */\n  catch(onreject) {\n    return /** @type {Task.Future<T|U, never>} */ (\n      this.activate().promise.catch(onreject)\n    )\n  }\n  /**\n   * @param {() => void} onfinally\n   * @returns {Task.Future<T, X>}\n   */\n  finally(onfinally) {\n    return /** @type {Task.Future<T, X>} */ (\n      this.activate().promise.finally(onfinally)\n    )\n  }\n  /**\n   * @abstract\n   */\n  /* c8 ignore next 3 */\n  activate() {\n    return this\n  }\n}\n\n/**\n * @template T, X, M\n * @implements {Task.Fork<T, X, M>}\n * @implements {Task.Controller<T, X, M>}\n * @implements {Task.Task<Task.Fork<T, X, M>, never>}\n * @implements {Task.Future<T, X>}\n * @extends {Future<T, X>}\n */\nclass Fork extends Future {\n  /**\n   * @param {Task.Task<T, X, M>} task\n   * @param {Task.ForkOptions} [options]\n   * @param {Task.StateHandler<T, X>} [handler]\n   * @param {Task.TaskState<T, M>} [state]\n   */\n  constructor(task, options = BLANK, handler = {}, state = INIT) {\n    super(handler)\n    this.id = ++ID\n    this.name = options.name || \"\"\n    /** @type {Task.Task<T, X, M>} */\n    this.task = task\n    this.state = state\n    this.status = IDLE\n    /** @type {Task.Result<T, X>} */\n    this.result\n    this.handler = handler\n\n    /** @type {Task.Controller<T, X, M>} */\n    this.controller\n  }\n\n  *resume() {\n    resume(this)\n  }\n\n  /**\n   * @returns {Task.Task<T, X, M>}\n   */\n  join() {\n    return join(this)\n  }\n\n  /**\n   * @param {X} error\n   */\n  abort(error) {\n    return abort(this, error)\n  }\n  /**\n   * @param {T} value\n   */\n  exit(value) {\n    return exit(this, value)\n  }\n  get [Symbol.toStringTag]() {\n    return \"Fork\"\n  }\n\n  /**\n   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}\n   */\n  *[Symbol.iterator]() {\n    return this.activate()\n  }\n\n  activate() {\n    this.controller = this.task[Symbol.iterator]()\n    this.status = ACTIVE\n    enqueue(this)\n    return this\n  }\n\n  /**\n   * @private\n   * @param {any} error\n   * @returns {never}\n   */\n  panic(error) {\n    this.result = { ok: false, error }\n    this.status = FINISHED\n    const { handler } = this\n    if (handler.onfailure) {\n      handler.onfailure(error)\n    }\n\n    throw error\n  }\n\n  /**\n   * @private\n   * @param {Task.TaskState<T, M>} state\n   */\n  step(state) {\n    this.state = state\n    if (state.done) {\n      this.result = { ok: true, value: state.value }\n      this.status = FINISHED\n      const { handler } = this\n      if (handler.onsuccess) {\n        handler.onsuccess(state.value)\n      }\n    }\n\n    return state\n  }\n\n  /**\n   * @param {unknown} value\n   */\n  next(value) {\n    try {\n      return this.step(this.controller.next(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {T} value\n   */\n  return(value) {\n    try {\n      return this.step(this.controller.return(value))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n  /**\n   * @param {X} error\n   */\n  throw(error) {\n    try {\n      return this.step(this.controller.throw(error))\n    } catch (error) {\n      return this.panic(error)\n    }\n  }\n}\n\n/**\n * @template M\n * @param {Task.Effect<M>} init\n * @param {(message:M) => Task.Effect<M>} next\n * @returns {Task.Task<void, never, never>}\n */\nexport const loop = function* (init, next) {\n  /** @type {Task.Controller<void, never, M>} */\n  const controller = yield* current()\n  const group = new Group(controller)\n  Group.enqueue(init[Symbol.iterator](), group)\n\n  while (true) {\n    for (const message of step(group)) {\n      Group.enqueue(next(message)[Symbol.iterator](), group)\n    }\n\n    if (Stack.size(group.stack) > 0) {\n      yield* suspend()\n    } else {\n      break\n    }\n  }\n}\n\nlet ID = 0\n/** @type {Task.Status} */\nconst IDLE = \"idle\"\nconst ACTIVE = \"active\"\nconst FINISHED = \"finished\"\n/** @type {Task.TaskState<any, any>} */\nconst INIT = { done: false, value: CURRENT }\n\nconst BLANK = {}\n\n/** @type {Task.Effect<never>} */\nconst NONE = (function* none() {})()\n\n/** @type {Task.Main<any, any, any>} */\nconst MAIN = new Main()\n", "function Indexed() {}\n\nObject.defineProperties(Indexed, {\n  prototype: {\n    value: new Proxy(Object.prototype, {\n      /**\n       * @param {object} target\n       * @param {PropertyKey} property\n       * @param {{get(key:PropertyKey): any}} receiver\n       */\n      get(target, property, receiver) {\n        return typeof property === \"symbol\"\n          ? Reflect.get(target, property, receiver)\n          : receiver.get(property)\n      },\n    }),\n  },\n})\n\nexport { Indexed }\n", "import { Indexed } from \"./indexed.js\"\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView()\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (\n  segments,\n  byteOffset = 0,\n  byteLength = totalByteLength(segments)\n) => new BufferView(segments, byteOffset, byteLength)\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0\n  for (const segment of segments) {\n    byteLength += segment.byteLength\n  }\n  return byteLength\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (\n  buffer,\n  startOffset = 0,\n  endOffset = buffer.byteLength\n) => {\n  const segments = []\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty()\n  }\n\n  let byteLength = 0\n  let offset = 0\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n        break\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range =\n          start === offset ? segment : segment.subarray(start - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range =\n        end === nextOffset ? segment : segment.subarray(0, end - offset)\n      segments.push(range)\n      byteLength += range.byteLength\n      break\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment)\n      byteLength += segment.byteLength\n    }\n\n    offset = nextOffset\n  }\n\n  return new BufferView(segments, buffer.byteOffset + start, byteLength)\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part)\n    return new BufferView(\n      buffer.segments,\n      buffer.byteOffset,\n      buffer.byteLength + part.byteLength\n    )\n  } else {\n    return buffer\n  }\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset]\n      } else {\n        offset += segment.byteLength\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset\n  for (const segment of buffer.segments) {\n    target.set(segment, offset)\n    offset += segment.byteLength\n  }\n\n  return target\n}\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super()\n    /** @hide */\n    this.segments = segments\n    /** @readonly */\n    this.byteLength = byteLength\n    /** @readonly */\n    this.length = byteLength\n    /** @readonly */\n    this.byteOffset = byteOffset\n  }\n\n  [Symbol.iterator]() {\n    return iterate(this)\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */ (push(this, bytes))\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n)\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset)\n  }\n}\n", "/**\n * @param {string} reason\n * @returns {never}\n */\nexport const panic = reason => {\n  throw new Error(reason)\n}\n\n/**\n * @param {{ raw: readonly string[] | ArrayLike<string>}} template\n * @param {never} [subject]\n * @param {unknown[]} substitutions\n * @returns {never}\n */\nexport const unreachable = (template, subject, ...substitutions) =>\n  panic(String.raw(template, JSON.stringify(subject), ...substitutions))\n\nexport const EMPTY_BUFFER = new Uint8Array(0)\n/** @type {any[]} */\nexport const EMPTY = []\n", "import * as BufferQueue from \"./chunker/buffer.js\"\nimport * as Chunker from \"./chunker/api.js\"\nimport { EMPTY } from \"../writer/util.js\"\nexport * from \"./chunker/api.js\"\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty(),\n})\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) =>\n  bytes.byteLength > 0\n    ? split(state.config, state.buffer.push(bytes), false)\n    : { ...state, chunks: EMPTY }\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true)\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker\n  const chunks = []\n\n  let offset = 0\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size)\n      chunks.push(chunk)\n      offset += size\n    }\n  }\n\n  return { config, chunks, buffer: buffer.subarray(offset) }\n}\n", "import * as Layout from \"./api.js\"\nimport * as Queue from \"./queue/api.js\"\nexport * from \"./queue/api.js\"\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: [],\n})\n\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY,\n})\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue)\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {})\n  for (const node of newNodes) {\n    const { ready, has, wants } = collect(node.children, queue.links)\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{ id: node.id, links: ready }],\n      })\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length,\n          },\n        },\n      })\n    }\n  }\n\n  return queue\n}\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id]\n  const node = queue.nodes[nodeID]\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const { ready, has } = collect(node.children, {\n        ...queue.links,\n        [id]: link,\n      })\n\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: assign(undefined, has),\n        nodes: { [nodeID]: undefined },\n        linked: [{ id: nodeID, links: ready }],\n      })\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: { [id]: link },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1,\n          },\n        },\n      })\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: { [id]: link },\n    })\n  }\n}\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, { needs, nodes, links, linked }) => {\n  const result = queue.mutable ? queue : { ...queue }\n  const original = queue.mutable ? BLANK : undefined\n\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original)\n  }\n\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original)\n  }\n\n  if (links) {\n    result.links = patchDict(queue.links, links, original)\n  }\n\n  result.linked = linked\n    ? append(queue.linked || EMPTY, linked, EMPTY)\n    : queue.linked || []\n\n  return /** @type {Queue.Result} */ (result)\n}\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */ ({})\n  for (const key of keys) {\n    delta[key] = value\n  }\n\n  return delta\n}\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? { ...target } : target\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */ (entry)\n    if (value == null) {\n      delete result[id]\n    } else {\n      result[id] = value\n    }\n  }\n\n  return result\n}\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue)\n  }\n  return queue\n}\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue =>\n  Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items]\n  } else {\n    for (const item of items) {\n      target.push(item)\n    }\n    return target\n  }\n}\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = []\n  const wants = []\n  const ready = []\n  for (const child of children) {\n    const link = source[child]\n    if (link) {\n      has.push(child)\n      ready.push(link)\n    } else {\n      wants.push(child)\n    }\n  }\n\n  return { has, wants, ready }\n}\n\nconst EMPTY = /** @type {never[]} */ (Object.freeze([]))\n\nconst BLANK = /** @type {Record<never, never>} */ (Object.freeze({}))\n", "import * as Task from \"actor\"\nimport * as API from \"./api.js\"\nimport * as Layout from \"./layout/api.js\"\nimport * as UnixFS from \"../codec.js\"\nimport * as Chunker from \"./chunker.js\"\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\"\nimport * as Queue from \"./layout/queue.js\"\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes)\n    case \"link\":\n      return link(state, message.link)\n    /* c8 ignore next 2 */\n    case \"block\":\n      return { state, effect: Task.none() }\n    case \"close\":\n      return close(state)\n    case \"end\":\n      return { state, effect: Task.none() }\n    default:\n      return unreachable`File Writer got unknown message ${message}`\n  }\n}\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({ chunker: config.chunker }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable(),\n  }\n}\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const { chunks, ...chunker } = Chunker.write(state.chunker, bytes)\n\n    // Pass chunks to layout engine to produce nodes\n    const { nodes, leaves, layout } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n      }),\n    }\n  } else {\n    return panic(\"Unable to perform write on closed file\")\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, { id, link, block }) => {\n  let { linked, ...nodeQueue } = Queue.addLink(id, link, state.nodeQueue)\n\n  const tasks = encodeBranches(linked, state.config)\n\n  /** @type {State<Layout>} */\n  const newState =\n    state.status === \"closed\" && id === state.rootID\n      ? {\n          ...state,\n          status: \"linked\",\n          link,\n          nodeQueue,\n        }\n      : { ...state, nodeQueue }\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end =\n    state.status === \"closed\" && id === state.rootID && state.end\n      ? state.end.resume()\n      : Task.none()\n\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end,\n    }),\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const { chunks } = Chunker.close(state.chunker)\n    const { layout, ...write } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { root, ...close } = state.config.fileLayout.close(\n      layout,\n      state.metadata\n    )\n\n    const [nodes, leaves] = isLeafNode(root)\n      ? [\n          [...write.nodes, ...close.nodes],\n          [...write.leaves, ...close.leaves, root],\n        ]\n      : [\n          [...write.nodes, ...close.nodes, root],\n          [...write.leaves, ...close.leaves],\n        ]\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend())\n\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork),\n      }),\n    }\n  } else {\n    return { state, effect: Task.none() }\n  }\n}\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) =>\n  leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder))\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER)\n  const hash = yield* Task.wait(hasher.digest(bytes))\n  const cid = linker.createLink(encoder.code, hash)\n\n  const block = { cid, bytes }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength,\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) =>\n  nodes.map(node => encodeBranch(config, node))\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, { id, links }, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata,\n  })\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)))\n  const cid = config.linker.createLink(config.fileEncoder.code, hash)\n  const block = { bytes, cid }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links),\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready)\n  }\n  writer.write(block)\n}\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer =>\n  buffer instanceof Uint8Array\n    ? buffer\n    : buffer.copyTo(new Uint8Array(buffer.byteLength), 0)\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null\n", "import * as API from \"./api.js\"\n\nexport const name = \"fixed\"\n/**\n * @typedef {Object} FixedSize\n * @property {number} maxChunkSize\n */\n\n/** @type {FixedSize} */\nexport const context = {\n  maxChunkSize: 262144,\n}\n\nexport const type = \"Stateless\"\n\n/**\n * @param {number} maxChunkSize\n * @returns {API.StatelessChunker<FixedSize>}\n */\nexport const withMaxChunkSize = maxChunkSize => ({\n  type: \"Stateless\",\n  context: { maxChunkSize },\n  name,\n  cut,\n})\n\n/**\n * @param {FixedSize} maxChunkSize\n * @param {API.Chunk} buffer\n * @param {boolean} end\n * @returns {number[]}\n */\nexport const cut = ({ maxChunkSize }, { byteLength }, end) => {\n  // number of fixed size chunks that would fit\n  const n = (byteLength / maxChunkSize) | 0\n  const chunks = new Array(n).fill(maxChunkSize)\n  const lastChunkSize = end ? byteLength - n * maxChunkSize : 0\n  if (lastChunkSize > 0) {\n    chunks.push(lastChunkSize)\n  }\n  return chunks\n}\n", "import * as Layout from \"./api.js\"\nimport * as Chunker from \"./../chunker/api.js\"\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                 (root4)                                  (root6)\n *                                    |                                        |\n *            -------------------------------------------------                |\n *            |                       |                       |                |\n *         (root1)                 (root2)                 (root3)          (root5)\n *            |                       |                       |                |\n *    --------|--------       --------|--------       --------|--------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id\n    this.children = children\n    this.metadata = metadata\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({ width }),\n  write,\n  close,\n})\n\nexport const defaults = { width: 174 }\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({ width } = defaults) => ({\n  width,\n\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0,\n})\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return { layout, nodes: EMPTY, leaves: EMPTY }\n  } else {\n    let { lastID } = layout\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head\n      ? // If we had a head we have more then two chunks (we already checked\n        // chunks weren't empty) so we process head along with other chunks.\n        [null, (chunks.unshift(layout.head), chunks)]\n      : // If we have no head no leaves and got only one chunk we have to save it\n      // until we can decide what to do with it.\n      chunks.length === 1 && layout.leafIndex.length === 0\n      ? [chunks[0], EMPTY]\n      : // Otherwise we have no head but got enough chunks to know we'll have a\n        // node.\n        [null, chunks]\n\n    if (slices.length === 0) {\n      return { layout: { ...layout, head }, nodes: EMPTY, leaves: EMPTY }\n    } else {\n      const leafIndex = [...layout.leafIndex]\n      const leaves = []\n      for (const chunk of slices) {\n        const leaf = { id: ++lastID, content: chunk }\n        leaves.push(leaf)\n        leafIndex.push(leaf.id)\n      }\n\n      if (leafIndex.length > layout.width) {\n        return flush({ ...layout, leafIndex, head, lastID }, leaves)\n      } else {\n        return {\n          layout: { ...layout, head, leafIndex, lastID },\n          leaves,\n          nodes: EMPTY,\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let { lastID } = state\n  const nodeIndex = state.nodeIndex.map(row => [...row])\n  const leafIndex = [...state.leafIndex]\n  const { width } = state\n\n  // Move leaves into nodes\n  while (leafIndex.length > width || (leafIndex.length > 0 && close)) {\n    grow(nodeIndex, 1)\n    const node = new Node(++lastID, leafIndex.splice(0, width))\n    nodeIndex[0].push(node.id)\n    nodes.push(node)\n  }\n\n  let depth = 0\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth]\n    depth++\n\n    while (\n      row.length > width ||\n      (row.length > 0 && close && depth < nodeIndex.length)\n    ) {\n      const node = new Node(++lastID, row.splice(0, width))\n      grow(nodeIndex, depth + 1)\n      nodeIndex[depth].push(node.id)\n      nodes.push(node)\n    }\n  }\n\n  return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes }\n}\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout\n  if (layout.head) {\n    return {\n      root: { id: 1, content: layout.head, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: { id: 1, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const { nodes, layout } = flush(state, EMPTY, [], true)\n\n    const { nodeIndex } = layout\n    const height = nodeIndex.length - 1\n\n    const top = nodeIndex[height]\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1]\n      nodes.length = nodes.length - 1\n      return { root, nodes, leaves: EMPTY }\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata)\n      return { root, nodes, leaves: EMPTY }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([])\n  }\n  return index\n}\n\n/** @type {never[]} */\nconst EMPTY = []\n", "import * as API from \"./file/api.js\"\nimport * as UnixFS from \"./codec.js\"\nimport * as Writer from \"./file/writer.js\"\nimport * as Task from \"actor\"\nimport { panic } from \"./writer/util.js\"\nimport * as FixedSize from \"./file/chunker/fixed.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { CID } from \"multiformats/cid\"\nimport * as Balanced from \"./file/layout/balanced.js\"\n\nexport * from \"./file/api.js\"\n\n/**\n * @returns {API.EncoderSettings}\n */\nexport const defaults = () => ({\n  chunker: FixedSize,\n  fileChunkEncoder: UnixFSLeaf,\n  smallFileEncoder: UnixFSLeaf,\n  fileEncoder: UnixFS,\n  fileLayout: Balanced.withWidth(174),\n  hasher: sha256,\n  linker: { createLink: CID.createV1 },\n})\n\n/**\n * @template {unknown} Layout\n * @param {Partial<API.EncoderSettings<Layout>>} config\n * @returns {API.EncoderSettings<Layout>}\n */\nexport const configure = config => ({\n  ...defaults(),\n  ...config,\n})\n\nexport const UnixFSLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeFileChunk,\n}\n\nexport const UnixFSRawLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeRaw,\n}\n\n/**\n * @template Layout\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, metadata = {}, settings = defaults() }) =>\n  new FileWriterView(Writer.init(writer, metadata, configure(settings)))\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Uint8Array} bytes\n * @return {Promise<API.View<T>>}\n */\n\nexport const write = async (view, bytes) => {\n  await perform(view, Task.send({ type: \"write\", bytes }))\n  return view\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = false, closeWriter = false } = {}\n) => {\n  await perform(view, Task.send({ type: \"close\" }))\n  const { state } = view\n  if (state.status === \"linked\") {\n    if (closeWriter) {\n      await view.state.writer.close()\n    } else if (releaseLock) {\n      view.state.writer.releaseLock()\n    }\n    return state.link\n    /* c8 ignore next 5 */\n  } else {\n    panic(\n      `Expected writer to be in 'linked' state after close, but it is in \"${state.status}\" instead`\n    )\n  }\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Task.Effect<Writer.Message>} effect\n */\nconst perform = (view, effect) =>\n  Task.fork(\n    Task.loop(effect, message => {\n      const { state, effect } = Writer.update(message, view.state)\n      view.state = state\n      return effect\n    })\n  )\n\n/**\n * @template Layout\n * @implements {API.View<Layout>}\n */\nclass FileWriterView {\n  /**\n   * @param {Writer.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.config\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {Promise<API.View<Layout>>}\n   */\n  write(bytes) {\n    return write(this, bytes)\n  }\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.FileLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n", "import * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nexport * from \"./directory/api.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(),\n    closed: false,\n  })\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, { overwrite = false } = {}) => {\n  const writable = asWritable(view.state)\n  if (name.includes(\"/\")) {\n    throw new Error(\n      `Directory entry name \"${name}\" contains forbidden \"/\" character`\n    )\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`)\n  } else {\n    writable.entries.set(name, link)\n    return view\n  }\n}\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state)\n  writer.entries.delete(name)\n  return view\n}\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\n      `Can not change written directory, but you can .fork() and make changes to it`\n    )\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n  const entries = [...links(view)]\n  const node = UnixFS.createFlatDirectory(entries, metadata)\n  const bytes = UnixFS.encodeDirectory(node)\n  const digest = await settings.hasher.digest(bytes)\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest)\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({ cid, bytes })\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({ state }) {\n  for (const [name, { dagByteLength, cid }] of state.entries) {\n    yield /** @type {UnixFS.DirectoryEntryLink} */ ({\n      name,\n      dagByteLength,\n      cid,\n    })\n  }\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(state.entries.entries()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  links() {\n    return links(this)\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n", "import * as API from \"./api.js\"\n\nexport { API }\n\n/**\n * @param {API.Uint32} size\n */\nexport const empty = (size = 32) => {\n  // We could support < 32, but it seems impractical and would negatively affect\n  // performance as we would have to do extra bound checks.\n  if (size !== 32) {\n    throw new Error(`Uint32 BitField does not support size: ${size}`)\n  }\n\n  return 0\n}\n\n/**\n * @param  {API.Uint32[]} bits\n * @param {API.Uint32} [size]\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const bit of bits) {\n    bitfield = set(bitfield, bit)\n  }\n  return bitfield\n}\n\n/**\n * @param {API.Uint32} _bitField\n */\nexport const size = _bitField => 32\n\n/**\n * Reads out 5 bits at the given bit offset.\n *\n * @param {API.Uint32} bitField - Bitfield in Uint32 representation.\n * @param {API.Uint32} index - Index with-in `bitField` to read bits from.\n * @returns {API.Uint32}\n */\nconst mask = (bitField, index) => (bitField >>> index) & 0b11111\n\n/**\n * Creates mask that can be used to check a bit in nodes bitmap for the give\n * key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nconst offset = (bitField, index) => 1 << mask(bitField, index)\n\n/**\n * Maps numbers [0, 31] to powers of two. Creates mask that can be used\n * to check a bit in nodes bitmap for the give key (hash) at given depth.\n *\n * @param {API.Uint32} bitField - Key hash as 32 bit integer.\n * @param {API.Uint32} index - Index with-in the 32bit bitfield\n */\nexport const popcount = (bitField, index = 31) =>\n  bitCount(bitField & (offset(index, 0) - 1))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const set = (bitField, index) => bitField | (1 << index)\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const unset = (bitField, index) => bitField & (0xff ^ (1 << index))\n\n/**\n * @param {API.Uint32} bitField\n * @param {API.Uint32} index\n */\nexport const get = (bitField, index) => ((bitField >> index) & 0x1) !== 0\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n */\nexport const bitCount = bitField => {\n  const n1 = bitField - ((bitField >> 1) & 0x55555555)\n  const n2 = (n1 & 0x33333333) + ((n1 >> 2) & 0x33333333)\n  const n3 = ((n2 + (n2 >> 4)) & 0xf0f0f0f) * 0x1010101\n  return n3 >> 24\n}\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const and = (left, right) => left & right\n\n/**\n * @param {API.Uint32} left\n * @param {API.Uint32} right\n * @returns {API.Uint32}\n */\nexport const or = (left, right) => left | right\n\n/**\n * Counts the number of bits set in n\n * @param {API.Uint32} bitField\n * @returns {Uint8Array}\n */\nexport const toBytes = bitField =>\n  Uint8Array.of(\n    (bitField >> 24) & 0b1111_1111,\n    (bitField >> 16) & 0b1111_1111,\n    (bitField >> 8) & 0b1111_1111,\n    bitField & 0b1111_1111\n  )\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {API.Uint32}\n */\nexport const fromBytes = bytes => {\n  if (bytes.length !== 4) {\n    throw new Error(`Expected 4 bytes instead got ${bytes.length}`)\n  }\n  return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3]\n}\n", "export {}\n", "import * as API from \"./api.js\"\n// @ts-expect-error - has no types\nimport murmur from \"murmurhash3js-revisited\"\n\nconst utf8 = new TextEncoder()\n\n/**\n * @typedef {(bytes:Uint8Array) => API.Uint32} Hasher\n * @type {Hasher}\n */\nexport const hash32 = murmur.x64.hash126\n\n/**\n * @param {Partial<API.Options<API.Uint32>>} options\n * @returns {API.Path<API.Uint32>}\n */\n/* c8 ignore next 45 */\nexport const configure = ({ bitWidth = 5, hash = hash32 }) => {\n  const hashSize = 4\n  if (bitWidth > hashSize * 8) {\n    throw new RangeError(\n      `Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`\n    )\n  }\n\n  if (hashSize * 8 > 32) {\n    throw new RangeError(\n      `Can not use hashSize ${hashSize} as it can not be encoded in Uint32`\n    )\n  }\n\n  // Mask for reading `bitWidth` number of bits from the end.\n  const mask = 0xffffffff >>> (32 - bitWidth)\n\n  /**\n   * Determines bit position for the path entry at the given `depth`.\n   * ```js\n   * const key = hash(\"result\") // 0b00011010010110010101111100110010\n   * // Which is following path (in reverse as we read from the right)\n   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]\n   * at(key, 0) // 0b10010 -> 18\n   * at(key, 1) // 0b11001 -> 25\n   * at(key, 2) // 0b10111 -> 23\n   * at(key, 3) // 0b10010 -> 18\n   * at(key, 4) // 0b00101 -> 5\n   * at(key, 5) // 0b01101 -> 13\n   * at(key, 6) // 0b00000 -> 0\n   * ```\n   *\n   * @param {API.Uint32} path\n   * @param {number} depth\n   */\n  const at = (path, depth) => (path >>> (depth * bitWidth)) & mask\n\n  /**\n   * @param {string} key\n   * @returns {API.Uint32}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { at, from, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n", "import * as API from \"./api.js\"\nexport * from \"./api.js\"\nimport * as BitField from \"./bitfield/Uint32.js\"\nimport * as Path from \"./path/Uint32.js\"\nexport { API }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.BitmapIndexedNode<T, K, C>}\n */\nclass BitmapIndexedNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {ReturnType<C['BitField']['empty']>} datamap\n   * @param {ReturnType<C['BitField']['empty']>} nodemap\n   * @param {API.Children<T, K, C>} children\n   * @param {C} config\n   */\n  constructor(edit, datamap, nodemap, children, config) {\n    this.edit = edit\n    this.config = config\n    this.datamap = datamap\n    this.nodemap = nodemap\n    this.children = children\n  }\n\n  get nodeArity() {\n    return this.config.BitField.popcount(this.nodemap)\n  }\n  get dataArity() {\n    return this.config.BitField.popcount(this.datamap)\n  }\n\n  /**\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  empty() {\n    return create(this.config)\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n\n  lookup(depth, path, key, notFound) {\n    return lookup(this, depth, path, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.BitmapIndexedNode<T, K | R, C>}\n   */\n  associate(edit, depth, path, key, value, addedLeaf) {\n    return associate(this, edit, depth, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} depth\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  dissociate(edit, depth, path, key, removedLeaf) {\n    return dissociate(this, edit, depth, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {API.BitmapIndexedNode<T, K, C>}\n   */\n  fork(edit = null) {\n    return fork(this, edit)\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.HashCollisionNode<T, K, C>}\n */\nclass HashCollisionNode {\n  /**\n   * @param {API.Edit|null} edit\n   * @param {number} count\n   * @param {API.CollisionEntries<T, K>} children\n   * @param {C} config\n   */\n  /* c8 ignore next 12 */\n  constructor(edit, count, children, config) {\n    this.edit = edit\n    this.count = count\n    this.children = children\n    this.config = config\n  }\n  get nodeArity() {\n    return /** @type {0} */ (0)\n  }\n  get dataArity() {\n    return this.count\n  }\n\n  /**\n   * @template X\n   * @param {API.Uint32} _shift\n   * @param {unknown} _path\n   * @param {K} key\n   * @param {X} notFound\n   * @returns {T|X}\n   */\n  /* c8 ignore next 3 */\n  lookup(_shift, _path, key, notFound) {\n    return lookupCollision(this, key, notFound)\n  }\n\n  /**\n   * @template {string} R\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K|R} key\n   * @param {T} value\n   * @param {{value:boolean}} addedLeaf\n   * @returns {API.HashCollisionNode<T, K | R, C>}\n   */\n  /* c8 ignore next 3 */\n  associate(edit, _shift, path, key, value, addedLeaf) {\n    return associateCollision(this, edit, path, key, value, addedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @param {API.Uint32} _shift\n   * @param {ReturnType<C['Path']['from']>} path\n   * @param {K} key\n   * @param {{value:boolean}} removedLeaf\n   * @returns {API.Node<T, K, C>}\n   */\n  /* c8 ignore next 3 */\n  dissociate(edit, _shift, path, key, removedLeaf) {\n    return dissociateCollision(this, edit, path, key, removedLeaf)\n  }\n\n  /**\n   * @param {API.Edit|null} edit\n   * @returns {this}\n   */\n  /* c8 ignore next 3 */\n  fork(edit = null) {\n    return /** @type {this} */ (forkCollision(this, edit))\n  }\n\n  /**\n   * @returns {IterableIterator<[K, T]>}\n   */\n  /* c8 ignore next 3 */\n  entries() {\n    return entries(this)\n  }\n\n  /**\n   * @returns {IterableIterator<K>}\n   */\n  /* c8 ignore next 3 */\n  keys() {\n    return keys(this)\n  }\n\n  /**\n   * @returns {IterableIterator<T>}\n   */\n  /* c8 ignore next 3 */\n  values() {\n    return values(this)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template X\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {K} name\n * @param {X} notFound\n * @returns {T|X}\n */\n/* c8 ignore next 8 */\nexport const lookupCollision = (node, name, notFound) => {\n  const { children: entries, count } = node\n  // find where entry with this name belongs\n  const n = findHashCollisionNodeIndex(entries, count, name)\n  // if entry name at this index matches given name return the value otherwise\n  // return `notFound` as we have no such entry.\n  return entries[n] === name ? /** @type {T} */ (entries[n + 1]) : notFound\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @template {string} R\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} key\n * @param {K|R} name\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.HashCollisionNode<T, K | R, C>}\n */\n/* c8 ignore next 26 */\nexport const associateCollision = (node, edit, key, name, value, addedLeaf) => {\n  const { children, count } = node\n\n  const index = findHashCollisionNodeIndex(children, count, name)\n  // If entry at this index has a different name we fork the node and\n  // add a new entry.\n  if (children[index] !== name) {\n    const newNode = node.fork(edit)\n    addedLeaf.value = true\n    newNode.count += 1\n    newNode.children.splice(index, key, value)\n    return newNode\n  }\n  // If name is the same but value is not we fork the node and update\n  // the value\n  else if (children[index + 1] !== value) {\n    const newNode = node.fork(edit)\n    newNode.children[index + 1] = value\n    return newNode\n  }\n  // If we got this far entry with this exact name and value is already\n  // present making this a noop, so we return this node back.\n  else {\n    return node\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {ReturnType<C['Path']['from']>} hash\n * @param {K} name\n * @param {{value:boolean}} removedLeaf\n * @returns {API.Node<T, K, C>}\n */\n/* c8 ignore next 37 */\nexport const dissociateCollision = (node, edit, hash, name, removedLeaf) => {\n  const { children: entries, count, config } = node\n  const index = findHashCollisionNodeIndex(entries, count, name)\n  // If there is no entry with a the given name this is noop so we just\n  // return back this node.\n  if (entries[index] !== name) {\n    return node\n  } else {\n    removedLeaf.value = true\n    // If conflict contained only two entries removing one of them would\n    // leave us with no conflict which is why we create a new node with a\n    // an entry other than one that would correspond provided name\n    if (count === 2) {\n      const offset = index === 0 ? 2 : 0\n      return /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n        associate(\n          create(config),\n          edit,\n          0,\n          hash,\n          /** @type {K} */ (entries[offset]),\n          /** @type {T} */ (entries[offset + 1]),\n          removedLeaf\n        )\n      )\n    }\n    // otherwise we got this far we have more than two colliding entries in\n    // which case we simply remove one corresponding to given `name`.\n    //\n    else {\n      const newNode = node.fork(edit)\n      newNode.children.splice(index, 2)\n      newNode.count -= 1\n      return newNode\n    }\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.HashCollisionNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.HashCollisionNode<T, K, C>}\n */\n/* c8 ignore next 12 */\nexport const forkCollision = (node, edit = null) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    return new HashCollisionNode(\n      edit,\n      node.count,\n      /** @type {API.CollisionEntries<T, K>} */ (node.children.slice()),\n      node.config\n    )\n  }\n}\n\n/**\n * Finds the index inside collision entries where given `key` belongs, which is\n * index where `key <= entries[index]` is `true`. If no index satisfies this\n * constraint index will be `entries.length` indicating that key belongs in the\n * last position.\n *\n * @template T\n * @template {string} K\n * @param {API.CollisionEntries<T, K>} entries\n * @param {number} count\n * @param {K} key\n */\n/* c8 ignore next 8 */\nconst findHashCollisionNodeIndex = (entries, count, key) => {\n  let index = 0\n  // increase index until we find a index where key <= entries[index]\n  while (index < count && entries[index] > key) {\n    index += 2\n  }\n  return index\n}\n\nconst defaultConfig = { bitWidth: 32, BitField, Path }\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Edit|null} [edit]\n * @param {C} config\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const create = (config, edit = null) =>\n  new BitmapIndexedNode(\n    edit,\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    config.BitField.empty(Math.pow(2, config.bitWidth)),\n    /** @type {API.Children<T, K, C>} */ ([]),\n    config\n  )\n\n/**\n * @template T, U\n * @template {string} K\n * @param {API.BitmapIndexedNode<T, K>} node\n * @param {K} key\n * @param {U} notFound\n */\nexport const get = (node, key, notFound) =>\n  lookup(node, 0, node.config.Path.from(key), key, notFound)\n\n/**\n * @template T, U\n * @template {string} K\n * @template Bits, BitMap\n * @param {API.BitmapIndexedNode<T, K, API.Config<Bits, BitMap>>} node\n * @param {API.Uint32} depth\n * @param {Bits} path\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const lookup = (node, depth, path, key, notFound) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key matches actual key in the map we found the the value\n    // otherwise we did not.\n    if (keyAt(node, index) === key) {\n      return valueAt(node, index)\n    } else {\n      return notFound\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    // Resolve node and continue lookup within it.\n    const child = resolveNode(node, offset)\n    return child.lookup(depth + 1, path, key, notFound)\n  }\n  // If we have neither node nor key-pair for this hash segment\n  // we return notFound.\n  else {\n    return notFound\n  }\n}\n\n/**\n * @template T, U\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {R} key\n * @param {T} value\n * @param {{ value: boolean }} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K|R, C>}\n */\nexport const set = (node, edit, key, value, addedLeaf) =>\n  associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf)\n\n/**\n * @template T\n * @template {string} K\n * @template {string} R\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K|R} key\n * @param {T} value\n * @param {{value:boolean}} addedLeaf\n * @returns {API.BitmapIndexedNode<T, K | R, C>}\n */\nexport const associate = (node, edit, depth, path, key, value, addedLeaf) => {\n  const { datamap, nodemap, config } = node\n  const { Path, BitField } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have some key, value under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    const found = keyAt(node, index)\n    // If we have entry with given name and value is the same return node\n    // as is, otherwise fork node and set the value.\n    if (key === found) {\n      return valueAt(node, index) === value\n        ? node\n        : forkAndSet(node, edit, index, value)\n    }\n    // Otherwise we need to create a branch to contain current key, value and\n    // one been passed.\n    else {\n      const branch = mergeTwoLeaves(\n        config,\n        edit,\n        depth + 1,\n        Path.from(found),\n        found,\n        valueAt(node, index),\n        path,\n        key,\n        value\n      )\n      addedLeaf.value = true\n\n      return migrateLeafToBranch(node, edit, offset, branch)\n    }\n  }\n  // If bit is set in the node bitmap we have a branch under the current\n  // hash slice.\n  else if (BitField.get(nodemap, offset)) {\n    const child = resolveNode(node, offset)\n    const newChild = child.associate(\n      edit,\n      depth + 1,\n      path,\n      key,\n      value,\n      addedLeaf\n    )\n\n    if (child === newChild) {\n      return node\n    } else {\n      return copyAndSetChild(node, edit, offset, newChild)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment. We copy\n  // current children and add new key-value pair\n  else {\n    const index = BitField.popcount(datamap, offset)\n    addedLeaf.value = true\n\n    /** @type {API.BitmapIndexedNode<T, K|R, C>} */\n    const newNode = node.fork(edit)\n\n    // Capture new entry in the data bitmap\n    newNode.datamap = BitField.set(datamap, offset)\n    newNode.children.splice(keyPosition(index), 0, key, value)\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {K} key\n * @param {{ value: boolean }} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nconst remove = (node, edit, key, removedLeaf) =>\n  dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf)\n\nexport { remove as delete }\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {API.Uint32} depth\n * @param {ReturnType<C['Path']['from']>} path\n * @param {K} key\n * @param {{value:boolean}} removedLeaf\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const dissociate = (source, edit, depth, path, key, removedLeaf) => {\n  const { datamap, nodemap, config } = source\n  const { BitField, Path } = config\n  const offset = Path.at(path, depth)\n  // If bit is set in the data bitmap we have an entry under the\n  // matching hash segment.\n  if (BitField.get(datamap, offset)) {\n    const index = BitField.popcount(datamap, offset)\n    // If key at a given index matches given `name` we fork a node and remove\n    // the entry\n    if (key === keyAt(source, index)) {\n      removedLeaf.value = true\n      const node = fork(source, edit)\n      // Update the bitmap\n      node.datamap = BitField.unset(source.datamap, offset)\n      // remove the child\n      node.children.splice(keyPosition(index), 2)\n      return node\n    }\n    // otherwise we don't have such entry so we return node back as is.\n    else {\n      return source\n    }\n  }\n  // If bit is set in the node bitmapt we have a node under the\n  // matching hash segment.\n  else if (BitField.get(nodemap, offset)) {\n    const node = resolveNode(source, offset)\n    const child = node.dissociate(edit, depth + 1, path, key, removedLeaf)\n    // if child has a single element we need to canonicalize\n    if (hasSingleLeaf(child)) {\n      // if source has a single child, we collapse and return the child\n      // otherwise we inline the child.\n      return hasSingleNode(source)\n        ? child\n        : inlineChild(source, edit, offset, child)\n    } else if (node === child) {\n      return source\n    } else {\n      return copyAndSetChild(source, edit, offset, child)\n    }\n  }\n  // If we have neither node nor a key-value for this hash segment this is a\n  // noop.\n  else {\n    return source\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<[K, T]>}\n */\nexport const entries = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      const value = children[offset]\n      yield /** @type {[K, T]} */ ([key, value])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K, C>} */ (\n      children[offset]\n    )\n    yield* node.entries()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const fork = (node, edit) => {\n  if (canEdit(node.edit, edit)) {\n    return node\n  } else {\n    const newNode = new BitmapIndexedNode(\n      edit,\n      node.datamap,\n      node.nodemap,\n      node.children.slice(),\n      node.config\n    )\n    return newNode\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<K>}\n */\nexport const keys = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      yield /** @type {K} */ (key)\n      offset += 2\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.keys()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {IterableIterator<T>}\n */\nexport const values = function* ({ children }) {\n  let offset = 0\n  const count = children.length\n  while (offset < count) {\n    const key = children[offset]\n    if (typeof key === \"string\") {\n      offset += 1\n      yield /** @type {T} */ (children[offset])\n      offset += 1\n    } else {\n      break\n    }\n  }\n\n  while (offset < count) {\n    const node = /** @type {API.BitmapIndexedNode<T, K>} */ (children[offset])\n    yield* node.values()\n    offset += 1\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {T} value\n */\nexport const forkAndSet = (node, edit, offset, value) => {\n  const newNode = node.fork(edit)\n  newNode.children[valuePosition(offset)] = value\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const inlineChild = (source, edit, offset, child) => {\n  const { datamap, nodemap, config } = source\n  const { BitField } = config\n  const node = fork(source, edit)\n\n  // remove the node that we are inlining\n  node.children.splice(nodePosition(source, offset), 1)\n  // add key-value pair where it wolud fall\n  node.children.splice(\n    keyPosition(BitField.popcount(datamap, offset)),\n    0,\n    child.children[0],\n    child.children[1]\n  )\n\n  node.datamap = BitField.set(datamap, offset)\n  node.nodemap = BitField.unset(nodemap, offset)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} child\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const copyAndSetChild = (node, edit, offset, child) => {\n  const newNode = fork(node, edit)\n  newNode.children[nodePosition(node, offset)] = child\n  return newNode\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} source\n * @param {API.Edit|null} edit\n * @param {number} offset\n * @param {API.Node<T, K, C>} branch\n * @returns {API.BitmapIndexedNode<T, K, C>}\n */\nexport const migrateLeafToBranch = (source, edit, offset, branch) => {\n  const { nodemap, datamap, config } = source\n  const { BitField } = config\n  const index = BitField.popcount(datamap, offset)\n  // Previous id corresponds to the key position\n  const oldId = keyPosition(index)\n  const newId = nodePosition(source, offset)\n\n  const node = fork(source, edit)\n\n  // remove an old leaf\n  node.datamap = BitField.unset(datamap, offset)\n  node.children.splice(oldId, 2)\n\n  // add a new branch\n  node.nodemap = BitField.set(nodemap, offset)\n  node.children.splice(newId - 1, 0, branch)\n\n  return node\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {C} config\n * @param {API.Edit|null} edit\n * @param {number} depth\n * @param {ReturnType<C['Path']['from']>} oldPath\n * @param {K} oldKey\n * @param {T} oldValue\n * @param {ReturnType<C['Path']['from']>} newPath\n * @param {K} newKey\n * @param {T} newValue\n * @returns {API.Node<T, K, C>}\n */\nexport const mergeTwoLeaves = (\n  config,\n  edit,\n  depth,\n  oldPath,\n  oldKey,\n  oldValue,\n  newPath,\n  newKey,\n  newValue\n) => {\n  const { BitField, Path } = config\n  // If we have reached end of the path we can no longer create another\n  // `BitmapIndexedNode`, instead we create a node containing (hash) colliding\n  // entries\n  /* c8 ignore next 7 */\n  if (Path.size < depth) {\n    return new HashCollisionNode(\n      edit,\n      2,\n      [oldKey, oldValue, newKey, newValue],\n      config\n    )\n  } else {\n    const oldOffset = Path.at(oldPath, depth)\n    const newOffset = Path.at(newPath, depth)\n    // If offsets still match create another intermediery node and merge these\n    // two nodes at next depth level.\n    if (oldOffset === newOffset) {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        BitField.from([oldOffset], Math.pow(2, config.bitWidth)),\n        [\n          mergeTwoLeaves(\n            config,\n            edit,\n            depth + 1,\n            oldPath,\n            oldKey,\n            oldValue,\n            newPath,\n            newKey,\n            newValue\n          ),\n        ],\n        config\n      )\n    }\n    // otherwise create new node with both key-value pairs as it's children\n    else {\n      return new BitmapIndexedNode(\n        edit,\n        BitField.from([oldOffset, newOffset], Math.pow(2, config.bitWidth)),\n        BitField.empty(Math.pow(2, config.bitWidth)),\n        /** @type {API.Children<T, K, C>} */\n        (\n          // We insert child with a lower index first so that we can derive it's\n          // index on access via popcount\n          oldOffset < newOffset\n            ? [oldKey, oldValue, newKey, newValue]\n            : [newKey, newValue, oldKey, oldValue]\n        ),\n        config\n      )\n    }\n  }\n}\n\n/**\n * @template {string} K\n * @param {API.BitmapIndexedNode<unknown, K>} node\n * @param {number} index\n */\nexport const keyAt = ({ children }, index) =>\n  /** @type {K} */ (children[keyPosition(index)])\n\n/**\n * @param {number} index\n */\nexport const keyPosition = index => index * 2\n\n/**\n * @template T\n * @param {API.BitmapIndexedNode<T>} node\n * @param {number} index\n */\nexport const valueAt = ({ children }, index) =>\n  /** @type {T} */ (children[valuePosition(index)])\n\n/**\n * @param {number} index\n */\nexport const valuePosition = index => index * 2 + 1\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n * @returns {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>}\n */\nexport const resolveNode = (node, offset) =>\n  /** @type {API.BitmapIndexedNode<T, K, C>|API.HashCollisionNode<T, K, C>} */ (\n    node.children[nodePosition(node, offset)]\n  )\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @param {number} offset\n */\nconst nodePosition = ({ children, nodemap, config }, offset) =>\n  children.length - 1 - config.BitField.popcount(nodemap, offset)\n\n/**\n * @param {API.Edit|null} owner\n * @param {API.Edit|null} editor\n */\nconst canEdit = (owner, editor) => owner != null && owner === editor\n\n/**\n * Returns `true` if node has a single entry. It also refines type to\n * `BitmapIndexedNode` because `HashCollisionNode` is normalized to\n * `BitmapIndexedNode` when it contains only a single entry.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.Node<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleLeaf = node => node.nodeArity === 0 && node.dataArity === 1\n\n/**\n * Returns `true` if node has a single childe node and 0 child leaves.\n *\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @param {API.BitmapIndexedNode<T, K, C>} node\n * @returns {node is API.BitmapIndexedNode<T, K, C>}\n */\nconst hasSingleNode = ({ config: { BitField }, datamap, nodemap }) =>\n  BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1\n", "import { bytes } from 'multiformats'\nimport { from } from 'multiformats/hashes/hasher'\n// @ts-expect-error no types\nimport mur from 'murmurhash3js-revisited'\n\n/**\n * @param {number} number\n * @returns {Uint8Array}\n */\nfunction fromNumberTo32BitBuf (number) {\n  const bytes = new Array(4)\n  for (let i = 0; i < 4; i++) {\n    bytes[i] = number & 0xff\n    number = number >> 8\n  }\n  return new Uint8Array(bytes)\n}\n\nexport const murmur332 = from({\n  name: 'murmur3-32',\n  code: 0x23,\n  encode: (input) => fromNumberTo32BitBuf(mur.x86.hash32(input))\n})\n\nexport const murmur3128 = from({\n  name: 'murmur3-128',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input))\n})\n\n// A special-use 0x22 that truncates 64 bits, specifically for use in the UnixFS HAMT\nexport const murmur364 = from({\n  name: 'murmur3-x64-64',\n  code: 0x22,\n  encode: (input) => bytes.fromHex(mur.x64.hash128(input)).subarray(0, 8)\n})\n", "import * as API from \"./api.js\"\nconst utf8 = new TextEncoder()\nimport { murmur364 } from \"@multiformats/murmur3\"\n\n/**\n * @param {Uint8Array} bytes\n */\n/* c8 ignore next 2 */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\n/* c8 ignore next 25 */\nexport const configure = ({ bitWidth = 8, hash = hash64 } = {}) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => {\n    const offset = depth * bitWidth\n    if (offset > hashSize) {\n      throw new RangeError(`Out of bounds`)\n    }\n\n    return toInt(path, offset, bitWidth)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Uint8Array}\n   */\n  const from = key => hash(utf8.encode(key))\n\n  return { from, at, size: Math.ceil((hashSize * 8) / bitWidth) }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset - bit offset\n * @param {number} count - number of bits to consume\n */\nexport const toInt = (bytes, offset, count) => {\n  let byteOffset = (offset / 8) | 0\n  let bitOffset = offset % 8\n  let desired = count\n  let bits = 0\n  while (desired > 0 && byteOffset < bytes.byteLength) {\n    const byte = bytes[byteOffset]\n    const available = 8 - bitOffset\n\n    const taking = available < desired ? available : desired\n    const bitsLeft = 8 - bitOffset - taking\n    // mask to turn of bits before bitOffset\n    const mask = 0xff >> bitOffset\n    // turn off offset bits and shift to drop remaining bit on the right\n    const value = (mask & byte) >> bitsLeft\n    bits = (bits << taking) + value\n\n    desired -= taking\n    byteOffset++\n    bitOffset = 0\n  }\n\n  return bits\n}\n", "import { bitCount, popcount as popcount32 } from \"./Uint32.js\"\nimport * as API from \"./api.js\"\n\n/**\n * @param {number} size\n */\nexport const empty = (size = 256) => {\n  if (size % 8 !== 0) {\n    throw new Error(`Must be multiple of 8`)\n  }\n\n  return new Uint8Array(size / 8)\n}\n\n/**\n * Creates bitfield with specific bits set.\n *\n * @param {number[]} bits\n * @param {number} [size]\n * @returns {Uint8Array}\n */\nexport const from = (bits, size) => {\n  let bitfield = empty(size)\n  for (const index of bits) {\n    const { byte, byteOffset, bitOffset } = at(bitfield, index)\n    bitfield[byteOffset] = byte | (1 << bitOffset)\n  }\n  return bitfield\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const size = bitfield => bitfield.byteLength * 8\n\n/**\n * Compute offset for the given index\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nconst at = (bitfield, index) => {\n  const byteOffset = bitfield.byteLength - 1 - ((index / 8) | 0)\n  const bitOffset = index % 8\n  const byte = bitfield[byteOffset]\n\n  return { byte, byteOffset, bitOffset }\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bytes\n * @param {number} index\n * @param {number} byte\n * @returns {Uint8Array}\n */\nconst setByte = (bytes, index, byte) => {\n  if (bytes[index] !== byte) {\n    const result = bytes.slice(0)\n    result[index] = byte\n    return result\n  }\n  return bytes\n}\n\n/**\n * Set a particular bit.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const set = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte | (1 << bitOffset))\n}\n\n/**\n * Unsets a particular bit.\n\n * @param {Uint8Array} bitfield\n * @param {number} index\n * @returns {Uint8Array}\n */\nexport const unset = (bitfield, index) => {\n  const { byte, byteOffset, bitOffset } = at(bitfield, index)\n  return setByte(bitfield, byteOffset, byte & (0xff ^ (1 << bitOffset)))\n}\n\n/**\n * Returns `true` if bit at given index is set.\n *\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const get = (bitfield, index) => {\n  var { byte, bitOffset } = at(bitfield, index)\n  return ((byte >> bitOffset) & 0x1) !== 0\n}\n\n/**\n * @param {Uint8Array} bitfield\n */\nexport const toBytes = bitfield => bitfield\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const fromBytes = bytes => bytes\n\n/**\n * @param {Uint8Array} bitfield\n * @param {number} index\n */\nexport const popcount = (bitfield, index = bitfield.byteLength * 8) => {\n  const { byteOffset, bitOffset, byte } = at(bitfield, index)\n\n  let count = popcount32(byte, bitOffset)\n  let offset = bitfield.byteLength - 1\n  while (offset > byteOffset) {\n    const byte = bitfield[offset]\n    count += bitCount(byte)\n    offset--\n  }\n\n  return count\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const or = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] |= right[offset]\n    offset++\n  }\n  return result\n}\n\n/**\n * @param {Uint8Array} left\n * @param {Uint8Array} right\n */\nexport const and = (left, right) => {\n  const result = left.slice()\n  let offset = 0\n  while (offset < left.length) {\n    result[offset] &= right[offset]\n    offset++\n  }\n  return result\n}\n\nexport { API }\n", "export * from \"./api.js\"\nimport * as Node from \"./node.js\"\nimport { create as createBitmapIndexedNode } from \"./node.js\"\nimport * as API from \"./api.js\"\nimport * as Uint32Path from \"./path/Uint32.js\"\nimport * as Uint8ArrayPath from \"./path/Uint8Array.js\"\nimport * as Uint32BitField from \"./bitfield/Uint32.js\"\nimport * as Uint8ArrayBitField from \"./bitfield/Uint8Array.js\"\n\nconst NOT_FOUND = new RangeError(\"Not Found\")\n\n/**\n * A `bitWidth` determines the number of bits of the hash to use for index\n * calculation at each level of the tree. In first layer will distribute\n * children by the first `bitWidth` bits of the key hash. In the next layer\n * next `bitWidth` number of bits of the key hash are used to determine\n * placement of it's children and so on. Each node in the tree will hold\n * `2 ** bitWidth` number of elements.\n *\n * For example when we insert an entry named `result` it will generate a\n * folowing hash (with murmur3 32) `442064690` which in binary would be\n *\n * ```\n * 11010010110010101111100110010\n * ```\n *\n * Which will correspond to a following key path\n *\n * ```\n * 11010/01011/00101/01111/10011/0010\n * ```\n *\n * Whis in decimals would be\n *\n * ```ts\n * 26/11/5/15/19/2'\n * ```\n *\n * If we then insert `fish` it would produce following path\n *\n * ```ts\n * 26/3/4/18/28/19/1\n * ```\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const empty = options => {\n  const config = configure(options)\n  return new PersistentHashMap(0, createBitmapIndexedNode(config, null), config)\n}\n\n/**\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Partial<C>} config\n * @returns {C}\n */\nconst configure = ({\n  bitWidth = 5,\n  /* c8 ignore next 4 */\n  BitField = bitWidth === 5 ? Uint32BitField : Uint8ArrayBitField,\n  Path = bitWidth === 5\n    ? Uint32Path.configure({ bitWidth })\n    : Uint8ArrayPath.configure({ bitWidth }),\n} = {}) => /** @type {C} */ ({ bitWidth, BitField, Path })\n\n/**\n * Creates HashMap from the provided entries.\n *\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {API.Config} [C=API.Config<API.Uint32>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} [options]\n * @returns {API.PersistentHashMap<V, K, C>}\n */\nexport const from = (entries, options) => {\n  const node = /** @type {API.HashMapBuilder<V, K, C>} */ (builder(options))\n  for (const [key, value] of entries) {\n    node.set(key, value)\n  }\n\n  return node.build()\n}\n\n/**\n * @template T\n * @template {string} K\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n */\nexport const has = (hamt, key) =>\n  Node.get(hamt.root, key, NOT_FOUND) !== NOT_FOUND\n\n/**\n * @template T\n * @template {string} K\n * @template [U=undefined]\n * @param {API.HAMT<T, K>} hamt\n * @param {K} key\n * @param {U} notFound\n * @returns {T|U}\n */\nexport const get = (hamt, key, notFound = /** @type {U} */ (undefined)) =>\n  Node.get(hamt.root, key, notFound)\n\n/**\n * @template {string} K\n * @template T\n * @template {API.Config} C\n * @param {Partial<C>} [options]\n * @returns {API.HashMapBuilder<T, K, C>}\n */\nexport const builder = options => {\n  const edit = {}\n  const config = configure(options)\n  return new HashMapBuilder(\n    edit,\n    0,\n    createBitmapIndexedNode(config, edit),\n    config\n  )\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n * @implements {API.PersistentHashMap<T, K, C>}\n */\nclass PersistentHashMap {\n  /**\n   *\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(count = 0, root, config) {\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    return this.count\n  }\n\n  clone() {\n    return new PersistentHashMap(this.count, this.root, this.config)\n  }\n\n  /**\n   * @returns {API.PersistentHashMap<T, K, C>}\n   */\n  empty() {\n    return new PersistentHashMap(\n      0,\n      createBitmapIndexedNode(this.config, null),\n      this.config\n    )\n  }\n  /**\n   * @param {K} key\n   * @returns {boolean}\n   */\n  has(key) {\n    return has(this, key)\n  }\n  /**\n   * @param {K} key\n   * @returns {T|undefined}\n   */\n  get(key) {\n    return Node.get(this.root, key, undefined)\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {PersistentHashMap<T, K|R, C>}\n   */\n  set(key, value) {\n    const addedLeaf = { value: false }\n    const root = Node.set(this.root, null, key, value, addedLeaf)\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(\n        addedLeaf.value ? this.count + 1 : this.count,\n        root,\n        this.config\n      )\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    const root = Node.delete(this.root, null, key, { value: false })\n\n    if (root === this.root) {\n      return this\n    } else {\n      return new PersistentHashMap(this.count - 1, root, this.config)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  get bitField() {\n    return this.config.BitField.or(this.root.datamap, this.root.nodemap)\n  }\n\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  entries() {\n    return this.root.entries()\n  }\n  keys() {\n    return this.root.keys()\n  }\n  values() {\n    return this.root.values()\n  }\n\n  /**\n   * @returns {API.HashMapBuilder<T, K, C>}\n   */\n\n  createBuilder() {\n    return new HashMapBuilder({}, this.count, this.root, this.config)\n  }\n}\n\n/**\n * @template T\n * @template {string} K\n * @template {API.Config} C\n */\nclass HashMapBuilder {\n  /**\n   * @param {API.Edit} edit\n   * @param {number} count\n   * @param {API.BitmapIndexedNode<T, K, C>} root\n   * @param {C} config\n   */\n  constructor(edit, count, root, config) {\n    /**\n     * @type {API.Edit|null}\n     * @private\n     */\n    this.edit = edit\n    /**\n     * @private\n     */\n    this.count = count\n    this.root = root\n    this.config = config\n  }\n\n  get size() {\n    if (this.edit) {\n      return this.count\n    } else {\n      throw new Error(`.size was accessed on the finalized builder`)\n    }\n  }\n  /**\n   * @template {string} R\n   * @param {R} key\n   * @param {T} value\n   * @returns {HashMapBuilder<T, K|R, C>}\n   */\n  set(key, value) {\n    if (this.edit) {\n      const addedLeaf = { value: false }\n      const root = Node.set(this.root, this.edit, key, value, addedLeaf)\n\n      if (this.root !== root) {\n        this.root = /** @type {API.BitmapIndexedNode<T, K, C>} */ (root)\n      }\n\n      if (addedLeaf.value) {\n        this.count += 1\n      }\n\n      return this\n    } else {\n      throw new Error(`.set was called on the finalized builder`)\n    }\n  }\n  /**\n   * @param {K} key\n   */\n  delete(key) {\n    if (this.edit) {\n      if (this.count === 0) {\n        return this\n      }\n      const removedLeaf = { value: false }\n      const root = Node.delete(this.root, this.edit, key, removedLeaf)\n\n      if (root !== this.root) {\n        this.root = root\n      }\n      if (removedLeaf.value) {\n        this.count -= 1\n      }\n      return this\n    } else {\n      throw new Error(`.delete was called on the finalized builder`)\n    }\n  }\n\n  build() {\n    if (this.edit) {\n      this.edit = null\n      return new PersistentHashMap(this.count, this.root, this.config)\n    } else {\n      throw new Error(`.build was called on the finalized builder`)\n    }\n  }\n}\n", "import * as API from \"./api.js\"\nimport { toInt } from \"./Uint8Array.js\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nconst utf8 = new TextEncoder()\n\n/**\n * @param {Uint8Array} bytes\n */\nexport const hash64 = bytes =>\n  /** @type {Uint8Array} */ (murmur364.encode(bytes))\n\n/**\n * @param {Partial<API.Options<Uint8Array>>} options\n * @returns {API.Path<Uint8Array>}\n */\nexport const configure = ({ bitWidth = 8, hash = hash64 }) => {\n  const hashSize = hash(new Uint8Array()).byteLength\n  const options = { bitWidth, hash, hashSize }\n\n  /**\n   * @param {Uint8Array} path\n   * @param {number} depth\n   * @returns {API.Uint32}\n   */\n  const at = (path, depth) => read(path, depth, options)\n\n  /**\n   * @param {string} key\n   */\n  const from = key => utf8.encode(key)\n\n  return { at, from, size: Infinity }\n}\n\n/**\n * @param {Uint8Array} key\n * @param {number} depth\n * @param {object} options\n * @param {number} [options.bitWidth]\n * @param {number} options.hashSize\n * @param {(input:Uint8Array) => Uint8Array} options.hash\n */\nexport const read = (key, depth = 0, { bitWidth = 8, hash, hashSize }) => {\n  // key digest consists of infinite number of hash frames that are computed\n  // from key + frame n which looks like\n  // [hash(key), hash([key, 1]), hash([key, n])]\n  // You can think of the hash as concatination of all frames. Here we calculate\n  // frame bit size from hash size as we going to use that several times.\n  const frameBitSize = hashSize * 8\n\n  // We start with 0 digest and required `bitCount` corresponding to `bitWith`.\n  // In the loop we'll going to consume `bitCount` hash bits.\n  let digest = 0\n  let bitCount = bitWidth\n  // Calculate absolute bit offset within the key digest.\n  let bitOffset = bitWidth * depth\n  while (bitCount > 0) {\n    // We derive frame number based on current bit offset.\n    const frameOffset = (bitOffset / frameBitSize) >> 0\n    // Then we compute that hash frame\n    const frame =\n      frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset))\n\n    // compute bit offset within the current frame\n    const offset =\n      frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset\n    // calculate number of bits remaining in this frame\n    const maxBits = frameBitSize - offset\n    // we will consume all required bits from frame if enough are available\n    // otherwise we consume whatever's available and continue rest in the next\n    // cycle(s).\n    const count = maxBits < bitCount ? maxBits : bitCount\n    digest = (digest << count) + toInt(frame, offset, count)\n    bitCount -= count\n    bitOffset += count\n  }\n\n  return digest\n}\n\n/**\n * @param {Uint8Array} source\n * @param {number} byte\n */\nconst appendByte = (source, byte) => {\n  const bytes = new Uint8Array(source.byteLength + 1).fill(\n    byte,\n    source.byteLength\n  )\n  bytes.set(source)\n  return bytes\n}\n", "import * as HAMT from \"./lib.js\"\nimport * as Node from \"./node.js\"\nimport * as Path from \"./path/InfiniteUint8Array.js\"\n\nexport * from \"./api.js\"\n\nexport { Path }\n\nexport const bitWidth = 8\nexport const config = {\n  bitWidth,\n  Path: Path.configure({ bitWidth }),\n}\n\n/**\n * @param {HAMT.PersistentHashMap} hamt\n */\nexport const tableSize = hamt => Math.pow(2, hamt.config.bitWidth)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.PersistentHashMap<T, K, C>}\n */\nexport const empty = (options = /** @type {C} */ (config)) =>\n  HAMT.empty(options)\n\n/**\n * @template [T=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Partial<C>} options\n * @returns {HAMT.HashMapBuilder<T, K, C>}\n */\nexport const builder = (options = /** @type {C} */ (config)) =>\n  HAMT.builder(options)\n\n/**\n * @template [V=unknown]\n * @template {string} [K=string]\n * @template {HAMT.Config} [C=HAMT.Config<Uint8Array>]\n * @param {Iterable<[K, V]>} entries\n * @param {Partial<C>} options\n */\nexport const from = (entries, options = /** @type {C} */ (config)) =>\n  HAMT.from(entries, options)\n\n/**\n * @template T\n * @template {string} K\n * @template Bits, Bitmap\n * @param {HAMT.BitmapIndexedNode<T, K, HAMT.Config<Bits, Bitmap>>} hamt\n */\nexport const bitField = ({ datamap, nodemap, config: { BitField } }) =>\n  withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)))\n\n/**\n * @param {Uint8Array} bytes\n */\nconst withoutLeadingZeros = bytes => {\n  let offset = 0\n  while (offset < bytes.byteLength) {\n    if (bytes[offset] !== 0) {\n      return bytes.subarray(offset)\n    }\n    offset += 1\n  }\n  return bytes.subarray(offset)\n}\n\n/**\n * Maps HAMT node into IPFS UnixFS compatible format.\n *\n * @template T\n * @template {string} K\n * @template {HAMT.Config} C\n * @param {HAMT.BitmapIndexedNode<T, K, C>} root\n * @returns {IterableIterator<{prefix:string, key:K, value:T, node?:void}|{prefix:string, node:HAMT.BitmapIndexedNode<T, K, C>}>}\n */\nexport const iterate = function* (root) {\n  const { config, datamap, nodemap } = root\n  const { BitField: bitfield } = config\n  const size = bitfield.size(datamap)\n  let bitOffset = 0\n  let dataCount = 0\n  while (bitOffset < size) {\n    const prefix = bitOffset.toString(16).toUpperCase().padStart(2, \"0\")\n    if (bitfield.get(datamap, bitOffset)) {\n      const key = Node.keyAt(root, dataCount)\n      yield {\n        prefix,\n        key,\n        value: Node.valueAt(root, dataCount),\n      }\n      dataCount++\n    } else if (bitfield.get(nodemap, bitOffset)) {\n      yield {\n        prefix,\n        // UnixFS never contains hash collision nodes because it uses\n        // inifinite hashes\n        node: /** @type {HAMT.BitmapIndexedNode<T, K, C>} */ (\n          Node.resolveNode(root, bitOffset)\n        ),\n      }\n    }\n    bitOffset++\n  }\n}\n", "import { bytes as binary, CID } from './index.js'\nimport type * as API from './interface.js'\n\nfunction readonly ({ enumerable = true, configurable = false } = {}): { enumerable: boolean, configurable: boolean, writable: false } {\n  return { enumerable, configurable, writable: false }\n}\n\nfunction * linksWithin (path: [string | number, string], value: any): Iterable<[string, CID]> {\n  if (value != null && typeof value === 'object') {\n    if (Array.isArray(value)) {\n      for (const [index, element] of value.entries()) {\n        const elementPath = [...path, index]\n        const cid = CID.asCID(element)\n        if (cid != null) {\n          yield [elementPath.join('/'), cid]\n        } else if (typeof element === 'object') {\n          yield * links(element, elementPath)\n        }\n      }\n    } else {\n      const cid = CID.asCID(value)\n      if (cid != null) {\n        yield [path.join('/'), cid]\n      } else {\n        yield * links(value, path)\n      }\n    }\n  }\n}\n\nfunction * links <T> (source: T, base: Array<string | number>): Iterable<[string, CID]> {\n  if (source == null || source instanceof Uint8Array) {\n    return\n  }\n  const cid = CID.asCID(source)\n  if (cid != null) {\n    yield [base.join('/'), cid]\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key] as [string | number, string]\n    yield * linksWithin(path, value)\n  }\n}\n\nfunction * treeWithin (path: [string | number, string], value: any): Iterable<string> {\n  if (Array.isArray(value)) {\n    for (const [index, element] of value.entries()) {\n      const elementPath = [...path, index]\n      yield elementPath.join('/')\n      if (typeof element === 'object' && (CID.asCID(element) == null)) {\n        yield * tree(element, elementPath)\n      }\n    }\n  } else {\n    yield * tree(value, path)\n  }\n}\n\nfunction * tree <T> (source: T, base: Array<string | number>): Iterable<string> {\n  if (source == null || typeof source !== 'object') {\n    return\n  }\n  for (const [key, value] of Object.entries(source)) {\n    const path = [...base, key] as [string | number, string]\n    yield path.join('/')\n    if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && (CID.asCID(value) == null)) {\n      yield * treeWithin(path, value)\n    }\n  }\n}\n\nfunction get <T> (source: T, path: string[]): API.BlockCursorView<unknown> {\n  let node = source as Record<string, any>\n  for (const [index, key] of path.entries()) {\n    node = node[key]\n    if (node == null) {\n      throw new Error(`Object has no property at ${path.slice(0, index + 1).map(part => `[${JSON.stringify(part)}]`).join('')}`)\n    }\n    const cid = CID.asCID(node)\n    if (cid != null) {\n      return { value: cid, remaining: path.slice(index + 1).join('/') }\n    }\n  }\n  return { value: node }\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template C - multicodec code corresponding to codec used to encode the block\n * @template A - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport class Block<T, C extends number, A extends number, V extends API.Version> implements API.BlockView<T, C, A, V> {\n  readonly cid: CID<T, C, A, V>\n  readonly bytes: API.ByteView<T>\n  readonly value: T\n  readonly asBlock: this\n\n  constructor ({ cid, bytes, value }: { cid: CID<T, C, A, V>, bytes: API.ByteView<T>, value: T }) {\n    if (cid == null || bytes == null || typeof value === 'undefined') { throw new Error('Missing required argument') }\n\n    this.cid = cid\n    this.bytes = bytes\n    this.value = value\n    this.asBlock = this\n\n    // Mark all the properties immutable\n    Object.defineProperties(this, {\n      cid: readonly(),\n      bytes: readonly(),\n      value: readonly(),\n      asBlock: readonly()\n    })\n  }\n\n  links (): Iterable<[string, CID<unknown, number, number, API.Version>]> {\n    return links(this.value, [])\n  }\n\n  tree (): Iterable<string> {\n    return tree(this.value, [])\n  }\n\n  get (path = '/'): API.BlockCursorView<unknown> {\n    return get(this.value, path.split('/').filter(Boolean))\n  }\n}\n\ninterface EncodeInput <T, Code extends number, Alg extends number> {\n  value: T\n  codec: API.BlockEncoder<Code, T>\n  hasher: API.MultihashHasher<Alg>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n */\nexport async function encode <T, Code extends number, Alg extends number> ({ value, codec, hasher }: EncodeInput<T, Code, Alg>): Promise<API.BlockView<T, Code, Alg>> {\n  if (typeof value === 'undefined') { throw new Error('Missing required argument \"value\"') }\n  if (codec == null || hasher == null) { throw new Error('Missing required argument: codec or hasher') }\n\n  const bytes = codec.encode(value)\n  const hash = await hasher.digest(bytes)\n\n  const cid = CID.create(\n    1,\n    codec.code,\n    hash\n  ) as CID<T, Code, Alg, 1>\n\n  return new Block({ value, bytes, cid })\n}\n\ninterface DecodeInput <T, Code extends number, Alg extends number> {\n  bytes: API.ByteView<T>\n  codec: API.BlockDecoder<Code, T>\n  hasher: API.MultihashHasher<Alg>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n */\nexport async function decode <T, Code extends number, Alg extends number> ({ bytes, codec, hasher }: DecodeInput<T, Code, Alg>): Promise<API.BlockView<T, Code, Alg>> {\n  if (bytes == null) { throw new Error('Missing required argument \"bytes\"') }\n  if (codec == null || hasher == null) { throw new Error('Missing required argument: codec or hasher') }\n\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n\n  const cid = CID.create(1, codec.code, hash) as CID<T, Code, Alg, 1>\n\n  return new Block({ value, bytes, cid })\n}\n\ntype CreateUnsafeInput <T, Code extends number, Alg extends number, V extends API.Version> = {\n  cid: API.Link<T, Code, Alg, V>\n  value: T\n  codec?: API.BlockDecoder<Code, T>\n  bytes: API.ByteView<T>\n} | {\n  cid: API.Link<T, Code, Alg, V>\n  value?: undefined\n  codec: API.BlockDecoder<Code, T>\n  bytes: API.ByteView<T>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport function createUnsafe <T, Code extends number, Alg extends number, V extends API.Version> ({ bytes, cid, value: maybeValue, codec }: CreateUnsafeInput<T, Code, Alg, V>): API.BlockView<T, Code, Alg, V> {\n  const value = maybeValue !== undefined\n    ? maybeValue\n    : (codec?.decode(bytes))\n\n  if (value === undefined) { throw new Error('Missing required argument, must either provide \"value\" or \"codec\"') }\n\n  return new Block({\n    cid: cid as CID<T, Code, Alg, V>,\n    bytes,\n    value\n  })\n}\n\ninterface CreateInput <T, Code extends number, Alg extends number, V extends API.Version> {\n  bytes: API.ByteView<T>\n  cid: API.Link<T, Code, Alg, V>\n  hasher: API.MultihashHasher<Alg>\n  codec: API.BlockDecoder<Code, T>\n}\n\n/**\n * @template T - Logical type of the data encoded in the block\n * @template Code - multicodec code corresponding to codec used to encode the block\n * @template Alg - multicodec code corresponding to the hashing algorithm used in CID creation.\n * @template V - CID version\n */\nexport async function create <T, Code extends number, Alg extends number, V extends API.Version> ({ bytes, cid, hasher, codec }: CreateInput<T, Code, Alg, V>): Promise<API.BlockView<T, Code, Alg, V>> {\n  if (bytes == null) { throw new Error('Missing required argument \"bytes\"') }\n  if (hasher == null) { throw new Error('Missing required argument \"hasher\"') }\n  const value = codec.decode(bytes)\n  const hash = await hasher.digest(bytes)\n  if (!binary.equals(cid.multihash.bytes, hash.bytes)) {\n    throw new Error('CID hash does not match bytes')\n  }\n\n  return createUnsafe({\n    bytes,\n    cid,\n    value,\n    codec\n  })\n}\n", "\nimport * as PermaMap from \"@perma/map\"\nimport * as UnixFSPermaMap from \"@perma/map/unixfs\"\nimport * as PB from \"@ipld/dag-pb\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nimport { Block } from 'multiformats/block'\nimport * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nimport { set, remove } from \"./directory.js\"\n\nexport * from \"./directory/api.js\"\nexport { set, remove } from \"./directory.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(),\n    closed: false,\n  })\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\"Can not change written HAMT directory, but you can .fork() and make changes to it\")\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n\n  const { entries } = view.state\n  /* c8 ignore next 3 */\n  if (!(entries instanceof HashMap)) {\n    throw new Error(`not a HAMT: ${entries}`)\n  }\n\n  const hamt = entries.builder.build()\n  const blocks = iterateBlocks(hamt, hamt.root, settings)\n\n  /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n  let root = null\n  for await (const block of blocks) {\n    root = block\n    // we make sure that writer has some capacity for this write. If it\n    // does not we await.\n    if ((writer.desiredSize || 0) <= 0) {\n      await writer.ready\n    }\n    // once writer has some capacity we write a block, however we do not\n    // await completion as we don't care when it's taken off the stream.\n    writer.write(block)\n  }\n  /* c8 ignore next */\n  if (root == null) throw new Error(\"no root block yielded\")\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid: root.cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt\n * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nconst iterateBlocks = async function* (hamt, node, settings) {\n  /** @type {UnixFS.DirectoryEntryLink[]} */\n  const entries = []\n  for (const ent of UnixFSPermaMap.iterate(node)) {\n    if ('key' in ent) {\n      entries.push(/** @type {UnixFS.DirectoryEntryLink} */ ({\n        name: `${ent.prefix ?? ''}${ent.key ?? ''}`,\n        dagByteLength: ent.value.dagByteLength,\n        cid: ent.value.cid,\n      }))\n    } else {\n      /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n      let root = null\n      for await (const block of iterateBlocks(hamt, ent.node, settings)) {\n        yield block\n        root = block\n      }\n      /* c8 ignore next */\n      if (root == null) throw new Error(\"no root block yielded\")\n\n      entries.push(/** @type {UnixFS.ShardedDirectoryLink} */ ({\n        name: ent.prefix,\n        dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n        cid: root.cid\n      }))\n    }\n  }\n\n  const shard = UnixFS.createDirectoryShard(\n    entries,\n    UnixFSPermaMap.bitField(node),\n    UnixFSPermaMap.tableSize(hamt),\n    murmur364.code\n  )\n  yield await encodeHAMTShardBlock(shard, settings)\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFS.DirectoryShard} shard\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nasync function encodeHAMTShardBlock (shard, settings) {\n  const bytes = UnixFS.encodeHAMTShard(shard)\n  const hash = await settings.hasher.digest(bytes)\n  const cid = settings.linker.createLink(PB.code, hash)\n  // @ts-ignore Link is not CID\n  return new Block({ cid, bytes, value: shard })\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(UnixFSPermaMap.from(state.entries.entries()).createBuilder()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass HAMTDirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n\n/**\n * @implements {Map<string, API.EntryLink>}\n */\nclass HashMap extends Map {\n  /**\n   * @param {UnixFSPermaMap.HashMapBuilder} [builder]\n   */\n  constructor (builder = UnixFSPermaMap.builder()) {\n    super()\n    /** @type {UnixFSPermaMap.HashMapBuilder} */\n    this.builder = builder\n  }\n\n  clear() {\n    this.builder = UnixFSPermaMap.builder()\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete(key) {\n    const { root } = this.builder\n    this.builder.delete(key)\n    return this.builder.root !== root\n  }\n\n  /**\n   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg = this) {\n    for (const [k, v] of this.builder.root.entries()) {\n      callbackfn.call(thisArg, v, k, this)\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  get(key) {\n    return PermaMap.get(this.builder, key)\n  }\n\n  /**\n   * @param {string} key\n   */\n  has(key) {\n    return PermaMap.has(this.builder, key)\n  }\n\n  /**\n   * @param {string} key \n   * @param {API.EntryLink} value \n   */\n  set(key, value) {\n    this.builder.set(key, value)\n    return this\n  }\n\n  get size () {\n    return this.builder.size\n  }\n\n  [Symbol.iterator]() {\n    return this.builder.root.entries()\n  }\n\n  entries() {\n    return this.builder.root.entries()\n  }\n\n  keys() {\n    return this.builder.root.keys()\n  }\n\n  values() {\n    return this.builder.root.values()\n  }\n}\n", "import * as API from \"./api.js\"\nimport * as File from \"./file.js\"\nimport * as Directory from \"./directory.js\"\n\nexport * from \"./api.js\"\n\nexport { encode, decode, NodeType, code } from \"./codec.js\"\nexport {\n  create as createFileWriter,\n  close as closeFile,\n  write,\n  configure,\n  defaults,\n  UnixFSLeaf,\n  UnixFSRawLeaf,\n} from \"./file.js\"\nexport {\n  create as createDirectoryWriter,\n  close as closeDirectory,\n  fork as forkDirectory,\n  set,\n  remove,\n} from \"./directory.js\"\nexport {\n  create as createShardedDirectoryWriter,\n  close as closeShardedDirectory,\n  fork as forkShardedDirectory,\n} from \"./sharded-directory.js\"\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const createWriter = ({ writable, settings = File.defaults() }) =>\n  new FileSystemWriter({\n    writer: writable.getWriter(),\n    settings,\n  })\n\n/**\n * @template {{writer:API.BlockWriter}} View\n * @param {View} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = true, closeWriter = true } = {}\n) => {\n  if (closeWriter) {\n    await view.writer.close()\n  } else if (releaseLock) {\n    view.writer.releaseLock()\n  }\n\n  return view\n}\n\n/**\n * @template [Layout=unknown]\n * @implemets {API.View<Layout>}\n */\nclass FileSystemWriter {\n  /**\n   * @param {object} options\n   * @param {API.BlockWriter} options.writer\n   * @param {Partial<API.EncoderSettings<Layout>>} options.settings\n   */\n  constructor({ writer, settings }) {\n    this.writer = writer\n    this.settings = File.configure(settings)\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createFileWriter({ settings = this.settings, metadata } = {}) {\n    return File.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createDirectoryWriter({ settings = this.settings, metadata } = {}) {\n    return Directory.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n\n// BlockSizeLimit specifies the maximum size an imported block can have.\n// @see https://github.com/ipfs/go-unixfs/blob/68c015a6f317ed5e21a4870f7c423a4b38b90a96/importer/helpers/helpers.go#L7-L8\nexport const BLOCK_SIZE_LIMIT = 1048576 // 1 MB\nexport const defaultCapacity = BLOCK_SIZE_LIMIT * 100\n\n/**\n * Creates `QueuingStrategy` that can fit blocks with total size up to given\n * byteLength.\n *\n * @param {number} byteLength\n * @returns {Required<QueuingStrategy<API.Block>>}\n */\nexport const withCapacity = (byteLength = defaultCapacity) => ({\n  highWaterMark: byteLength,\n  size: block => block.bytes.length,\n})\n", "import * as UnixFS from '@ipld/unixfs';\nimport * as raw from 'multiformats/codecs/raw';\nimport { withMaxChunkSize } from '@ipld/unixfs/file/chunker/fixed';\nimport { withWidth } from '@ipld/unixfs/file/layout/balanced';\nconst SHARD_THRESHOLD = 1000; // shard directory after > 1,000 items\nconst queuingStrategy = UnixFS.withCapacity();\nconst defaultSettings = UnixFS.configure({\n    fileChunkEncoder: raw,\n    smallFileEncoder: raw,\n    chunker: withMaxChunkSize(1024 * 1024),\n    fileLayout: withWidth(1024),\n});\n/**\n * @param {import('./types.js').BlobLike} blob\n * @param {import('./types.js').UnixFSEncoderSettingsOptions} [options]\n * @returns {Promise<import('./types.js').UnixFSEncodeResult>}\n */\nexport async function encodeFile(blob, options) {\n    const readable = createFileEncoderStream(blob, options);\n    const blocks = await collect(readable);\n    // @ts-expect-error There is always a root block\n    return { cid: blocks.at(-1).cid, blocks };\n}\n/**\n * @param {import('./types.js').BlobLike} blob\n * @param {import('./types.js').UnixFSEncoderSettingsOptions} [options]\n * @returns {ReadableStream<import('@ipld/unixfs').Block>}\n */\nexport function createFileEncoderStream(blob, options) {\n    /** @type {TransformStream<import('@ipld/unixfs').Block, import('@ipld/unixfs').Block>} */\n    const { readable, writable } = new TransformStream({}, queuingStrategy);\n    const settings = options?.settings ?? defaultSettings;\n    const unixfsWriter = UnixFS.createWriter({ writable, settings });\n    const fileBuilder = new UnixFSFileBuilder('', blob);\n    void (async () => {\n        await fileBuilder.finalize(unixfsWriter);\n        await unixfsWriter.close();\n    })();\n    return readable;\n}\nclass UnixFSFileBuilder {\n    #file;\n    /**\n     * @param {string} name\n     * @param {import('./types.js').BlobLike} file\n     */\n    constructor(name, file) {\n        this.name = name;\n        this.#file = file;\n    }\n    /** @param {import('@ipld/unixfs').View} writer */\n    async finalize(writer) {\n        const unixfsFileWriter = UnixFS.createFileWriter(writer);\n        await this.#file.stream().pipeTo(new WritableStream({\n            async write(chunk) {\n                await unixfsFileWriter.write(chunk);\n            },\n        }));\n        return await unixfsFileWriter.close();\n    }\n}\nclass UnixFSDirectoryBuilder {\n    #options;\n    /** @type {Map<string, UnixFSFileBuilder | UnixFSDirectoryBuilder>} */\n    entries = new Map();\n    /**\n     * @param {string} name\n     * @param {import('./types.js').UnixFSDirectoryEncoderOptions} [options]\n     */\n    constructor(name, options) {\n        this.name = name;\n        this.#options = options;\n    }\n    /** @param {import('@ipld/unixfs').View} writer */\n    async finalize(writer) {\n        const dirWriter = this.entries.size <= SHARD_THRESHOLD\n            ? UnixFS.createDirectoryWriter(writer)\n            : UnixFS.createShardedDirectoryWriter(writer);\n        for (const [name, entry] of this.entries) {\n            const link = await entry.finalize(writer);\n            if (this.#options?.onDirectoryEntryLink) {\n                // @ts-expect-error\n                this.#options.onDirectoryEntryLink({ name: entry.name, ...link });\n            }\n            dirWriter.set(name, link);\n        }\n        return await dirWriter.close();\n    }\n}\n/**\n * @param {Iterable<import('./types.js').FileLike>} files\n * @param {import('./types.js').UnixFSEncoderSettingsOptions & import('./types.js').UnixFSDirectoryEncoderOptions} [options]\n * @returns {Promise<import('./types.js').UnixFSEncodeResult>}\n */\nexport async function encodeDirectory(files, options) {\n    const readable = createDirectoryEncoderStream(files, options);\n    const blocks = await collect(readable);\n    // @ts-expect-error There is always a root block\n    return { cid: blocks.at(-1).cid, blocks };\n}\n/**\n * @param {Iterable<import('./types.js').FileLike>} files\n * @param {import('./types.js').UnixFSEncoderSettingsOptions & import('./types.js').UnixFSDirectoryEncoderOptions} [options]\n * @returns {ReadableStream<import('@ipld/unixfs').Block>}\n */\nexport function createDirectoryEncoderStream(files, options) {\n    const rootDir = new UnixFSDirectoryBuilder('', options);\n    for (const file of files) {\n        const path = file.name.split('/');\n        if (path[0] === '' || path[0] === '.') {\n            path.shift();\n        }\n        let dir = rootDir;\n        for (const [i, name] of path.entries()) {\n            if (i === path.length - 1) {\n                dir.entries.set(name, new UnixFSFileBuilder(path.join('/'), file));\n                break;\n            }\n            let dirBuilder = dir.entries.get(name);\n            if (dirBuilder == null) {\n                const dirName = dir === rootDir ? name : `${dir.name}/${name}`;\n                dirBuilder = new UnixFSDirectoryBuilder(dirName, options);\n                dir.entries.set(name, dirBuilder);\n            }\n            if (!(dirBuilder instanceof UnixFSDirectoryBuilder)) {\n                throw new Error(`\"${file.name}\" cannot be a file and a directory`);\n            }\n            dir = dirBuilder;\n        }\n    }\n    /** @type {TransformStream<import('@ipld/unixfs').Block, import('@ipld/unixfs').Block>} */\n    const { readable, writable } = new TransformStream({}, queuingStrategy);\n    const settings = options?.settings ?? defaultSettings;\n    const unixfsWriter = UnixFS.createWriter({ writable, settings });\n    void (async () => {\n        const link = await rootDir.finalize(unixfsWriter);\n        if (options?.onDirectoryEntryLink) {\n            options.onDirectoryEntryLink({ name: '', ...link });\n        }\n        await unixfsWriter.close();\n    })();\n    return readable;\n}\n/**\n * @template T\n * @param {ReadableStream<T>} collectable\n * @returns {Promise<T[]>}\n */\nasync function collect(collectable) {\n    /** @type {T[]} */\n    const chunks = [];\n    await collectable.pipeTo(new WritableStream({\n        write(chunk) {\n            chunks.push(chunk);\n        },\n    }));\n    return chunks;\n}\n//# sourceMappingURL=unixfs.js.map", "import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockHeader} BlockHeader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesReader} BytesReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n * @typedef {import('./coding.js').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding.js').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      return out\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n *\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = /** @type {Uint8Array<ArrayBufferLike>[]} */([currentChunk.subarray(offset)])\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n", "import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').RootsReader} RootsReader\n * @typedef {import('./coding.js').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor (version, roots, iterable) {\n    this._version = version\n    this._roots = roots\n    this._iterable = iterable\n    this._decoded = false\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    return this._iterable[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    const iterable = this._iterable[Symbol.asyncIterator]()\n    return {\n      async next () {\n        const next = await iterable.next()\n        if (next.done) {\n          return next\n        }\n        return { done: false, value: next.value.cid }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array')\n  }\n  return decodeIterator(bytesReader(bytes))\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable (asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable')\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable))\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n  return { version, roots, iterator: decoder.blocks() }\n}\n", "import { encode as dagCborEncode } from '@ipld/dag-cbor'\nimport varint from 'varint'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n * @typedef {import('./coding.js').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: CAR_V1_VERSION, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n    },\n\n    /**\n     * @returns {number}\n     */\n    version () {\n      return CAR_V1_VERSION\n    }\n  }\n}\n\nexport { createEncoder }\n", "/**\n * @template {any} T\n * @typedef {import('./coding.js').IteratorChannel<T>} IteratorChannel\n */\n\nfunction noop () {}\n\n/**\n * @template {any} T\n * @returns {IteratorChannel<T>}\n */\nexport function create () {\n  /** @type {T[]} */\n  const chunkQueue = []\n  /** @type {Promise<void> | null} */\n  let drainer = null\n  let drainerResolver = noop\n  let ended = false\n  /** @type {Promise<IteratorResult<T>> | null} */\n  let outWait = null\n  let outWaitResolver = noop\n\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise((resolve) => {\n        drainerResolver = () => {\n          drainer = null\n          drainerResolver = noop\n          resolve()\n        }\n      })\n    }\n    return drainer\n  }\n\n  /**\n   * @returns {IteratorChannel<T>}\n   */\n  const writer = {\n    /**\n     * @param {T} chunk\n     * @returns {Promise<void>}\n     */\n    write (chunk) {\n      chunkQueue.push(chunk)\n      const drainer = makeDrainer()\n      outWaitResolver()\n      return drainer\n    },\n\n    async end () {\n      ended = true\n      const drainer = makeDrainer()\n      outWaitResolver()\n      await drainer\n    }\n  }\n\n  /** @type {AsyncIterator<T>} */\n  const iterator = {\n    /** @returns {Promise<IteratorResult<T>>} */\n    async next () {\n      const chunk = chunkQueue.shift()\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver()\n        }\n        return { done: false, value: chunk }\n      }\n\n      if (ended) {\n        drainerResolver()\n        return { done: true, value: undefined }\n      }\n\n      if (!outWait) {\n        outWait = new Promise((resolve) => {\n          outWaitResolver = () => {\n            outWait = null\n            outWaitResolver = noop\n            return resolve(iterator.next())\n          }\n        })\n      }\n\n      return outWait\n    }\n  }\n\n  return { writer, iterator }\n}\n", "import { CID } from 'multiformats/cid'\nimport { bytesReader, readHeader } from './decoder.js'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockWriter} BlockWriter\n * @typedef {import('./api.js').WriterChannel} WriterChannel\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n * @typedef {import('./coding.js').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n  }\n\n  /**\n   * Returns the version number of the CAR file being written\n   *\n   * @returns {number}\n   */\n  version () {\n    return this._encoder.version()\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n", "import { CarBlockIterator, CarWriter } from '@ipld/car';\nimport * as dagCBOR from '@ipld/dag-cbor';\nimport varint from 'varint';\n/**\n * @typedef {import('@ipld/unixfs').Block} Block\n */\nexport const code = 0x0202;\n/** Byte length of a CBOR encoded CAR header with zero roots. */\nconst NO_ROOTS_HEADER_LENGTH = 18;\n/** @param {import('./types.js').AnyLink} [root] */\nexport function headerEncodingLength(root) {\n    if (!root)\n        return NO_ROOTS_HEADER_LENGTH;\n    const headerLength = dagCBOR.encode({ version: 1, roots: [root] }).length;\n    const varintLength = varint.encodingLength(headerLength);\n    return varintLength + headerLength;\n}\n/** @param {Block} block */\nexport function blockHeaderEncodingLength(block) {\n    const payloadLength = block.cid.bytes.length + block.bytes.length;\n    const varintLength = varint.encodingLength(payloadLength);\n    return varintLength + block.cid.bytes.length;\n}\n/** @param {Block} block */\nexport function blockEncodingLength(block) {\n    return blockHeaderEncodingLength(block) + block.bytes.length;\n}\n/**\n * @param {Iterable<Block> | AsyncIterable<Block>} blocks\n * @param {import('./types.js').AnyLink} [root]\n * @returns {Promise<import('./types.js').CARFile>}\n */\nexport async function encode(blocks, root) {\n    // @ts-expect-error\n    const { writer, out } = CarWriter.create(root);\n    /** @type {Error?} */\n    let error;\n    void (async () => {\n        try {\n            for await (const block of blocks) {\n                await writer.put(block);\n            }\n        }\n        catch ( /** @type {any} */err) {\n            error = err;\n        }\n        finally {\n            await writer.close();\n        }\n    })();\n    const chunks = [];\n    for await (const chunk of out)\n        chunks.push(chunk);\n    // @ts-expect-error\n    if (error != null)\n        throw error;\n    const roots = root != null ? [root] : [];\n    return Object.assign(new Blob(chunks), { version: 1, roots });\n}\n/** @param {import('./types.js').BlobLike} car */\nexport async function decode(car) {\n    const stream = new BlockStream(car);\n    const blocks = /** @type {Block[]} */ ([]);\n    await stream.pipeTo(new WritableStream({\n        write: (block) => {\n            blocks.push(block);\n        },\n    }));\n    const roots = await stream.getRoots();\n    return { blocks, roots };\n}\n/** @extends {ReadableStream<Block>} */\nexport class BlockStream extends ReadableStream {\n    /** @param {import('./types.js').BlobLike} car */\n    constructor(car) {\n        /** @type {Promise<CarBlockIterator>?} */\n        let blocksPromise = null;\n        const getBlocksIterable = () => {\n            if (blocksPromise)\n                return blocksPromise;\n            blocksPromise = CarBlockIterator.fromIterable(toIterable(car.stream()));\n            return blocksPromise;\n        };\n        /** @type {AsyncIterator<Block>?} */\n        let iterator = null;\n        super({\n            async start() {\n                const blocks = await getBlocksIterable();\n                iterator = /** @type {AsyncIterator<Block>} */ (blocks[Symbol.asyncIterator]());\n            },\n            async pull(controller) {\n                /* c8 ignore next */\n                if (!iterator)\n                    throw new Error('missing blocks iterator');\n                const { value, done } = await iterator.next();\n                if (done)\n                    return controller.close();\n                controller.enqueue(value);\n            },\n        });\n        /** @returns {Promise<import('./types.js').AnyLink[]>} */\n        this.getRoots = async () => {\n            const blocks = await getBlocksIterable();\n            return await blocks.getRoots();\n        };\n    }\n}\n/* c8 ignore start */\n/**\n * {@link ReadableStream} is an async iterable in newer environments, but it's\n * not standard yet. This function normalizes a {@link ReadableStream} to a\n * definite async iterable.\n *\n * @template T\n * @param {ReadableStream<T> | AsyncIterable<T>} stream\n * @returns {AsyncIterable<T>} An async iterable of the contents of the\n *                             {@link stream} (possibly {@link stream} itself).\n */\nfunction toIterable(stream) {\n    return Symbol.asyncIterator in stream\n        ? stream\n        : (async function* () {\n            const reader = stream.getReader();\n            try {\n                while (true) {\n                    const { done, value } = await reader.read();\n                    if (done)\n                        return;\n                    yield value;\n                }\n            }\n            finally {\n                reader.releaseLock();\n            }\n        })();\n}\n/* c8 ignore end */\n//# sourceMappingURL=car.js.map", "/** @import { Block } from '@ipld/unixfs' */\n/** @extends {TransformStream<Block, Block>} */\nexport class BlockDeduplicationStream extends TransformStream {\n    constructor() {\n        /** @type {Set<string>} */\n        const seen = new Set();\n        super({\n            transform(block, controller) {\n                const key = block.cid.toString();\n                if (seen.has(key))\n                    return;\n                seen.add(key);\n                controller.enqueue(block);\n            },\n            flush() {\n                seen.clear();\n            },\n        });\n    }\n}\n/**\n * @param {Iterable<Block>} blocks\n * @returns {IterableIterator<Block>}\n */\nexport const dedupe = function* (blocks) {\n    /** @type {Set<string>} */\n    const seen = new Set();\n    for (const b of blocks) {\n        const key = b.cid.toString();\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield b;\n    }\n};\n//# sourceMappingURL=deduplication.js.map", "import * as API from './api.js';\nimport { CAR, ok, error, Schema, Failure } from '@ucanto/core';\nimport { compare } from 'uint8arrays';\nimport * as dagCBOR from '@ipld/dag-cbor';\nimport * as Digest from 'multiformats/hashes/digest';\nimport * as Link from 'multiformats/link';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { DigestMap } from './digest-map.js';\nexport const version = 'index/sharded/dag@0.1';\nexport const ShardedDAGIndexSchema = Schema.variant({\n    [version]: Schema.struct({\n        /** DAG root. */\n        content: Schema.link(),\n        /** Shards the DAG can be found in. */\n        shards: Schema.array(Schema.link()),\n    }),\n});\nexport const MultihashSchema = Schema.bytes();\nexport const BlobIndexSchema = Schema.tuple([\n    MultihashSchema,\n    Schema.array(\n    /** multihash bytes, offset, length. */\n    Schema.tuple([\n        MultihashSchema,\n        Schema.tuple([Schema.number(), Schema.number()]),\n    ])),\n]);\n/**\n * @param {Uint8Array} archive\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const extract = (archive) => {\n    const { roots, blocks } = CAR.decode(archive);\n    if (!roots.length) {\n        return error(new UnknownFormat('missing root block'));\n    }\n    const { code } = roots[0].cid;\n    if (code !== dagCBOR.code) {\n        return error(new UnknownFormat(`unexpected root CID codec: 0x${code.toString(16)}`));\n    }\n    return view({ root: roots[0], blocks });\n};\n/**\n * @param {object} source\n * @param {API.IPLDBlock} source.root\n * @param {Map<string, API.IPLDBlock>} source.blocks\n * @returns {API.Result<API.ShardedDAGIndexView, API.DecodeFailure|API.UnknownFormat>}\n */\nexport const view = ({ root, blocks }) => {\n    const [version, dagIndexData] = ShardedDAGIndexSchema.match(dagCBOR.decode(root.bytes));\n    switch (version) {\n        case version: {\n            const dagIndex = create(dagIndexData.content);\n            for (const shardLink of dagIndexData.shards) {\n                const shard = blocks.get(shardLink.toString());\n                if (!shard) {\n                    return error(new DecodeFailure(`missing shard block: ${shardLink}`));\n                }\n                const blobIndexData = BlobIndexSchema.from(dagCBOR.decode(shard.bytes));\n                const blobIndex = new DigestMap();\n                for (const [digest, [offset, length]] of blobIndexData[1]) {\n                    blobIndex.set(Digest.decode(digest), [offset, length]);\n                }\n                dagIndex.shards.set(Digest.decode(blobIndexData[0]), blobIndex);\n            }\n            return ok(dagIndex);\n        }\n        default:\n            return error(new UnknownFormat(`unknown index version: ${version}`));\n    }\n};\n/** @implements {API.ShardedDAGIndexView} */\nclass ShardedDAGIndex {\n    #content;\n    #shards;\n    /** @param {API.UnknownLink} content */\n    constructor(content) {\n        this.#content = content;\n        /** @type {DigestMap<API.ShardDigest, API.Position>} */\n        this.#shards = new DigestMap();\n    }\n    get content() {\n        return this.#content;\n    }\n    get shards() {\n        return this.#shards;\n    }\n    /**\n     * @param {API.ShardDigest} shard\n     * @param {API.SliceDigest} slice\n     * @param {API.Position} pos\n     */\n    setSlice(shard, slice, pos) {\n        let index = this.#shards.get(shard);\n        if (!index) {\n            index = new DigestMap();\n            this.#shards.set(shard, index);\n        }\n        index.set(slice, pos);\n    }\n    archive() {\n        return archive(this);\n    }\n}\nexport class UnknownFormat extends Failure {\n    #reason;\n    /** @param {string} [reason] */\n    constructor(reason) {\n        super();\n        this.name = /** @type {const} */ ('UnknownFormat');\n        this.#reason = reason;\n    }\n    describe() {\n        return this.#reason ?? 'unknown format';\n    }\n}\nexport class DecodeFailure extends Failure {\n    #reason;\n    /** @param {string} [reason] */\n    constructor(reason) {\n        super();\n        this.name = /** @type {const} */ ('DecodeFailure');\n        this.#reason = reason;\n    }\n    describe() {\n        return this.#reason ?? 'failed to decode';\n    }\n}\n/**\n * @param {API.UnknownLink} content\n * @returns {API.ShardedDAGIndexView}\n */\nexport const create = (content) => new ShardedDAGIndex(content);\n/**\n * @param {API.ShardedDAGIndex} model\n * @returns {Promise<API.Result<Uint8Array, API.EncodeFailure>>}\n */\nexport const archive = async (model) => {\n    const roots = [];\n    const blocks = new Map();\n    try {\n        const shards = [...model.shards.entries()].sort((a, b) => compare(a[0].digest, b[0].digest));\n        const index = {\n            content: model.content,\n            shards: /** @type {API.Link[]} */ ([]),\n        };\n        for (const s of shards) {\n            const slices = [...s[1].entries()]\n                .sort((a, b) => compare(a[0].digest, b[0].digest))\n                .map((e) => [e[0].bytes, e[1]]);\n            const bytes = dagCBOR.encode([s[0].bytes, slices]);\n            const digest = await sha256.digest(bytes);\n            const cid = Link.create(dagCBOR.code, digest);\n            blocks.set(cid.toString(), { cid, bytes });\n            index.shards.push(cid);\n        }\n        const bytes = dagCBOR.encode({ [version]: index });\n        const digest = await sha256.digest(bytes);\n        const cid = Link.create(dagCBOR.code, digest);\n        roots.push({ cid, bytes });\n    }\n    catch ( /** @type {any} */err) {\n        return error(\n        /** @type {API.EncodeFailure} */ ({\n            name: 'EncodeFailure',\n            message: `encoding DAG: ${err.message}`,\n            stack: err.stack,\n        }));\n    }\n    try {\n        return ok(CAR.encode({ roots, blocks }));\n    }\n    catch ( /** @type {any} */err) {\n        return error(\n        /** @type {API.EncodeFailure} */ ({\n            name: 'EncodeFailure',\n            message: `encoding CAR: ${err.message}`,\n            stack: err.stack,\n        }));\n    }\n};\n//# sourceMappingURL=sharded-dag-index.js.map", "import * as API from './api.js';\nimport { base58btc } from 'multiformats/bases/base58';\n/** @type {WeakMap<Uint8Array, string>} */\nconst cache = new WeakMap();\n/** @param {API.MultihashDigest} digest */\nconst toBase58String = (digest) => {\n    let str = cache.get(digest.bytes);\n    if (!str) {\n        str = base58btc.encode(digest.bytes);\n        cache.set(digest.bytes, str);\n    }\n    return str;\n};\n/**\n * @template {API.MultihashDigest} Key\n * @template Value\n * @implements {Map<Key, Value>}\n */\nexport class DigestMap {\n    /** @type {Map<string, [Key, Value]>} */\n    #data;\n    /**\n     * @param {Array<[Key, Value]>} [entries]\n     */\n    constructor(entries) {\n        this.#data = new Map();\n        for (const [k, v] of entries ?? []) {\n            this.set(k, v);\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return 'DigestMap';\n    }\n    clear() {\n        this.#data.clear();\n    }\n    /**\n     * @param {Key} key\n     * @returns {boolean}\n     */\n    delete(key) {\n        const mhstr = toBase58String(key);\n        return this.#data.delete(mhstr);\n    }\n    /**\n     * @param {(value: Value, key: Key, map: Map<Key, Value>) => void} callbackfn\n     * @param {any} [thisArg]\n     */\n    forEach(callbackfn, thisArg) {\n        for (const [k, v] of this.#data.values()) {\n            callbackfn.call(thisArg, v, k, this);\n        }\n    }\n    /**\n     * @param {Key} key\n     * @returns {Value|undefined}\n     */\n    get(key) {\n        const data = this.#data.get(toBase58String(key));\n        if (data)\n            return data[1];\n    }\n    /**\n     * @param {Key} key\n     * @returns {boolean}\n     */\n    has(key) {\n        return this.#data.has(toBase58String(key));\n    }\n    /**\n     * @param {Key} key\n     * @param {Value} value\n     */\n    set(key, value) {\n        this.#data.set(toBase58String(key), [key, value]);\n        return this;\n    }\n    /** @returns {number} */\n    get size() {\n        return this.#data.size;\n    }\n    /** @returns */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /** @returns {IterableIterator<[Key, Value]>} */\n    *entries() {\n        yield* this.#data.values();\n    }\n    /** @returns {IterableIterator<Key>} */\n    *keys() {\n        for (const [k] of this.#data.values()) {\n            yield k;\n        }\n    }\n    /** @returns {IterableIterator<Value>} */\n    *values() {\n        for (const [, v] of this.#data.values()) {\n            yield v;\n        }\n    }\n}\n//# sourceMappingURL=digest-map.js.map", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "const MSB = 0x80\nconst REST = 0x7F\nconst MSBALL = ~REST\nconst INT = Math.pow(2, 31)\n\n/**\n * @param {number} num\n */\nexport const encode = num => {\n  /** @type {number[]} */\n  const out = []\n  let offset = 0\n\n  while (num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB\n    num /= 128\n  }\n  while (num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB\n    num >>>= 7\n  }\n  out[offset] = num | 0\n\n  return out\n}\n\n/**\n * @param {import('uint8arraylist').Uint8ArrayList} buf\n * @param {number} [offset]\n */\nexport const decode = (buf, offset) => {\n  let res = 0\n  offset = offset || 0\n  let shift = 0\n  let counter = offset\n  let b\n  const l = buf.length\n\n  do {\n    if (counter >= l || shift > 49) throw new RangeError('Could not decode varint')\n    b = buf.get(counter++)\n    res += shift < 28\n      ? (b & REST) << shift\n      : (b & REST) * Math.pow(2, shift)\n    shift += 7\n  } while (b >= MSB)\n\n  return [res, counter - offset]\n}\n", "/* eslint-env browser */\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { decode as decodeDagCBOR } from '@ipld/dag-cbor'\nimport { decode as decodeDigest } from 'multiformats/hashes/digest'\nimport { create as createLink, createLegacy as createLegacyLink } from 'multiformats/link'\nimport { decode as decodeVarint } from './varint.js'\n\nconst State = {\n  ReadHeaderLength: 0,\n  ReadHeader: 1,\n  ReadBlockLength: 2,\n  ReadBlock: 3\n}\n\nconst CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\n/** @extends {TransformStream<Uint8Array, import('./api.js').Block & import('./api.js').Position>} */\nexport class CARReaderStream extends TransformStream {\n  /** @type {Promise<import('./api.js').CARHeader>} */\n  #headerPromise\n\n  /**\n   * @param {QueuingStrategy<Uint8Array>} [writableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]\n   * An object that optionally defines a queuing strategy for the stream.\n   * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow\n   * `getHeader` to be called before the stream is consumed.\n   */\n  constructor (writableStrategy, readableStrategy) {\n    const buffer = new Uint8ArrayList()\n    let offset = 0\n    let prevOffset = offset\n    let wanted = 8\n    let state = State.ReadHeaderLength\n\n    /** @type {(value: import('./api.js').CARHeader) => void} */\n    let resolveHeader\n    const headerPromise = new Promise(resolve => { resolveHeader = resolve })\n\n    super({\n      transform (chunk, controller) {\n        buffer.append(chunk)\n        while (true) {\n          if (buffer.length < wanted) break\n          if (state === State.ReadHeaderLength) {\n            const [length, bytes] = decodeVarint(buffer)\n            buffer.consume(bytes)\n            prevOffset = offset\n            offset += bytes\n            state = State.ReadHeader\n            wanted = length\n          } else if (state === State.ReadHeader) {\n            const header = decodeDagCBOR(buffer.slice(0, wanted))\n            resolveHeader && resolveHeader(header)\n            buffer.consume(wanted)\n            prevOffset = offset\n            offset += wanted\n            state = State.ReadBlockLength\n            wanted = 8\n          } else if (state === State.ReadBlockLength) {\n            const [length, bytes] = decodeVarint(buffer)\n            buffer.consume(bytes)\n            prevOffset = offset\n            offset += bytes\n            state = State.ReadBlock\n            wanted = length\n          } else if (state === State.ReadBlock) {\n            const _offset = prevOffset\n            const length = offset - prevOffset + wanted\n\n            prevOffset = offset\n            /** @type {import('multiformats').UnknownLink} */\n            let cid\n            if (buffer.get(0) === CIDV0_BYTES.SHA2_256 && buffer.get(1) === CIDV0_BYTES.LENGTH) {\n              const bytes = buffer.subarray(0, 34)\n              const multihash = decodeDigest(bytes)\n              // @ts-expect-error\n              cid = createLegacyLink(multihash)\n              buffer.consume(34)\n              offset += 34\n            } else {\n              const [version, versionBytes] = decodeVarint(buffer)\n              if (version !== 1) throw new Error(`unexpected CID version (${version})`)\n              buffer.consume(versionBytes)\n              offset += versionBytes\n\n              const [codec, codecBytes] = decodeVarint(buffer)\n              buffer.consume(codecBytes)\n              offset += codecBytes\n\n              const multihashBytes = getMultihashLength(buffer)\n              const multihash = decodeDigest(buffer.subarray(0, multihashBytes))\n              cid = createLink(codec, multihash)\n              buffer.consume(multihashBytes)\n              offset += multihashBytes\n            }\n\n            const blockBytes = wanted - (offset - prevOffset)\n            const bytes = buffer.subarray(0, blockBytes)\n            controller.enqueue({ cid, bytes, offset: _offset, length, blockOffset: offset, blockLength: blockBytes })\n\n            buffer.consume(blockBytes)\n            prevOffset = offset\n            offset += blockBytes\n            state = State.ReadBlockLength\n            wanted = 8\n          }\n        }\n      },\n      flush (controller) {\n        if (state !== State.ReadBlockLength) {\n          controller.error(new Error('unexpected end of data'))\n        }\n      }\n    }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({ highWaterMark: 1 }))\n\n    this.#headerPromise = headerPromise\n  }\n\n  /**\n   * Get the decoded CAR header.\n   */\n  getHeader () {\n    return this.#headerPromise\n  }\n}\n\n/** @param {Uint8ArrayList} bytes */\nconst getMultihashLength = bytes => {\n  const [, codeBytes] = decodeVarint(bytes)\n  const [length, lengthBytes] = decodeVarint(bytes, codeBytes)\n  return codeBytes + lengthBytes + length\n}\n", "/* eslint-env browser */\nimport { encode as encodeCBOR } from '@ipld/dag-cbor'\nimport { encode as encodeVarint } from './varint.js'\n\n/**\n * @param {import('multiformats').UnknownLink[]} roots\n * @returns {Uint8Array}\n */\nexport const encodeHeader = roots => {\n  const headerBytes = encodeCBOR({ version: 1, roots })\n  const varintBytes = encodeVarint(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {import('./api.js').Block} block\n * @returns {Uint8Array}\n */\nexport const encodeBlock = block => {\n  const varintBytes = encodeVarint(block.cid.bytes.length + block.bytes.length)\n  const bytes = new Uint8Array(varintBytes.length + block.cid.bytes.length + block.bytes.length)\n  bytes.set(varintBytes)\n  bytes.set(block.cid.bytes, varintBytes.length)\n  bytes.set(block.bytes, varintBytes.length + block.cid.bytes.length)\n  return bytes\n}\n\n/** @extends {TransformStream<import('./api.js').Block, Uint8Array>} */\nexport class CARWriterStream extends TransformStream {\n  /**\n   * @param {import('multiformats').UnknownLink[]} [roots]\n   * @param {QueuingStrategy<import('./api.js').Block>} [writableStrategy]\n   * @param {QueuingStrategy<Uint8Array>} [readableStrategy]\n   */\n  constructor (roots = [], writableStrategy, readableStrategy) {\n    super({\n      start: controller => controller.enqueue(encodeHeader(roots)),\n      transform: (block, controller) => controller.enqueue(encodeBlock(block))\n    }, writableStrategy, readableStrategy)\n  }\n}\n", "import { CARReaderStream } from 'carstream';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as API from './api.js';\nimport { create } from './sharded-dag-index.js';\n/**\n * Create a sharded DAG index by indexing blocks in the passed CAR shards.\n *\n * @param {API.UnknownLink} content\n * @param {Uint8Array[]} shards\n * @returns {Promise<API.ShardedDAGIndexView>}\n */\nexport const fromShardArchives = async (content, shards) => {\n    const index = create(content);\n    for (const s of shards) {\n        const digest = await sha256.digest(s);\n        await new ReadableStream({\n            pull: (c) => {\n                c.enqueue(s);\n                c.close();\n            },\n        })\n            .pipeThrough(new CARReaderStream())\n            .pipeTo(new WritableStream({\n            write({ cid, blockOffset, blockLength }) {\n                index.setSlice(digest, cid.multihash, [blockOffset, blockLength]);\n            },\n        }));\n    }\n    return index;\n};\n/**\n * Indexes a sharded DAG\n *\n * @param {import('multiformats').Link} root\n * @param {import('@storacha/capabilities/types').CARLink[]} shards\n * @param {Array<Map<API.SliceDigest, API.Position>>} shardIndexes\n */\nexport async function indexShardedDAG(root, shards, shardIndexes) {\n    const index = create(root);\n    for (const [i, shard] of shards.entries()) {\n        const slices = shardIndexes[i];\n        index.shards.set(shard.multihash, slices);\n    }\n    return await index.archive();\n}\n//# sourceMappingURL=util.js.map", "import { DigestMap } from '@storacha/blob-index';\nimport { blockEncodingLength, blockHeaderEncodingLength, encode, headerEncodingLength, } from './car.js';\n/**\n * @typedef {import('./types.js').FileLike} FileLike\n */\n// https://observablehq.com/@gozala/w3up-shard-size\nexport const SHARD_SIZE = 133_169_152;\n/**\n * Shard a set of blocks into a set of CAR files. By default the last block\n * received is assumed to be the DAG root and becomes the CAR root CID for the\n * last CAR output. Set the `rootCID` option to override.\n *\n * @extends {TransformStream<import('@ipld/unixfs').Block, import('./types.js').IndexedCARFile>}\n */\nexport class ShardingStream extends TransformStream {\n    /**\n     * @param {import('./types.js').ShardingOptions} [options]\n     */\n    constructor(options = {}) {\n        const shardSize = options.shardSize ?? SHARD_SIZE;\n        const maxBlockLength = shardSize - headerEncodingLength();\n        /** @type {import('@ipld/unixfs').Block[]} */\n        let blocks = [];\n        /** @type {import('@ipld/unixfs').Block[] | null} */\n        let readyBlocks = null;\n        /** @type {Map<import('./types.js').SliceDigest, import('./types.js').Position>} */\n        let slices = new DigestMap();\n        /** @type {Map<import('./types.js').SliceDigest, import('./types.js').Position> | null} */\n        let readySlices = null;\n        let currentLength = 0;\n        super({\n            async transform(block, controller) {\n                if (readyBlocks != null && readySlices != null) {\n                    controller.enqueue(await encodeCAR(readyBlocks, readySlices));\n                    readyBlocks = null;\n                    readySlices = null;\n                }\n                const blockHeaderLength = blockHeaderEncodingLength(block);\n                const blockLength = blockHeaderLength + block.bytes.length;\n                if (blockLength > maxBlockLength) {\n                    throw new Error(`block will cause CAR to exceed shard size: ${block.cid}`);\n                }\n                if (blocks.length && currentLength + blockLength > maxBlockLength) {\n                    readyBlocks = blocks;\n                    readySlices = slices;\n                    blocks = [];\n                    slices = new DigestMap();\n                    currentLength = 0;\n                }\n                blocks.push(block);\n                slices.set(block.cid.multihash, [\n                    headerEncodingLength() + currentLength + blockHeaderLength,\n                    block.bytes.length,\n                ]);\n                currentLength += blockLength;\n            },\n            async flush(controller) {\n                if (readyBlocks != null && readySlices != null) {\n                    controller.enqueue(await encodeCAR(readyBlocks, readySlices));\n                }\n                const rootBlock = blocks.at(-1);\n                if (rootBlock == null)\n                    return;\n                const rootCID = options.rootCID ?? rootBlock.cid;\n                const headerLength = headerEncodingLength(rootCID);\n                // if adding CAR root overflows the shard limit we move overflowing\n                // blocks into another CAR.\n                if (headerLength + currentLength > shardSize) {\n                    const overage = headerLength + currentLength - shardSize;\n                    const overflowBlocks = [];\n                    let overflowCurrentLength = 0;\n                    while (overflowCurrentLength < overage) {\n                        const block = blocks[blocks.length - 1];\n                        blocks.pop();\n                        slices.delete(block.cid.multihash);\n                        overflowBlocks.unshift(block);\n                        overflowCurrentLength += blockEncodingLength(block);\n                        // need at least 1 block in original shard\n                        if (blocks.length < 1)\n                            throw new Error(`block will cause CAR to exceed shard size: ${block.cid}`);\n                    }\n                    controller.enqueue(await encodeCAR(blocks, slices));\n                    // Finally, re-calc block positions from blocks we moved out of the\n                    // CAR that was too big.\n                    overflowCurrentLength = 0;\n                    /** @type {Map<import('./types.js').SliceDigest, import('./types.js').Position>} */\n                    const overflowSlices = new DigestMap();\n                    for (const block of overflowBlocks) {\n                        const overflowBlockHeaderLength = blockHeaderEncodingLength(block);\n                        overflowSlices.set(block.cid.multihash, [\n                            headerLength + overflowCurrentLength + overflowBlockHeaderLength,\n                            block.bytes.length,\n                        ]);\n                        overflowCurrentLength +=\n                            overflowBlockHeaderLength + block.bytes.length;\n                    }\n                    controller.enqueue(await encodeCAR(overflowBlocks, overflowSlices, rootCID));\n                }\n                else {\n                    // adjust offsets for longer header in final shard\n                    const diff = headerLength - headerEncodingLength();\n                    for (const slice of slices.values()) {\n                        slice[0] += diff;\n                    }\n                    controller.enqueue(await encodeCAR(blocks, slices, rootCID));\n                }\n            },\n        });\n    }\n}\n/**\n * Default comparator for FileLikes. Sorts by file name in ascending order.\n *\n * @param {FileLike} a\n * @param {FileLike} b\n * @param {(file: FileLike) => string} getComparedValue - given a file being sorted, return the value by which its order should be determined, if it is different than the file object itself (e.g. file.name)\n */\nexport const defaultFileComparator = (a, b, getComparedValue = (file) => file.name) => {\n    return ascending(a, b, getComparedValue);\n};\n/**\n * a comparator for sorting in ascending order. Use with Sorted or Array#sort.\n *\n * @template T\n * @param {T} a\n * @param {T} b\n * @param {(i: T) => any} getComparedValue - given an item being sorted, return the value by which it should be sorted, if it is different than the item\n */\nfunction ascending(a, b, getComparedValue) {\n    const ask = getComparedValue(a);\n    const bsk = getComparedValue(b);\n    if (ask === bsk)\n        return 0;\n    else if (ask < bsk)\n        return -1;\n    return 1;\n}\n/**\n * @param {Iterable<import('@ipld/unixfs').Block>} blocks\n * @param {Map<import('./types.js').SliceDigest, import('./types.js').Position>} slices\n * @param {import('./types.js').AnyLink} [root]\n * @returns {Promise<import('./types.js').IndexedCARFile>}\n */\nconst encodeCAR = async (blocks, slices, root) => Object.assign(await encode(blocks, root), { slices });\n//# sourceMappingURL=sharding.js.map", "import * as PieceHasher from '@web3-storage/data-segment/multihash';\nimport { Storefront } from '@storacha/filecoin-client';\nimport * as Link from 'multiformats/link';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport * as Blob from './blob/index.js';\nimport * as BlobAdd from './blob/add.js';\nimport * as Index from './index/index.js';\nimport * as IndexAdd from './index/add.js';\nimport * as Upload from './upload/index.js';\nimport * as UploadAdd from './upload/add.js';\nimport * as UnixFS from './unixfs.js';\nimport * as CAR from './car.js';\nimport { BlockDeduplicationStream, dedupe } from './deduplication.js';\nimport { ShardingStream, defaultFileComparator, SHARD_SIZE, } from './sharding.js';\nimport { ShardedDAGIndex, indexShardedDAG } from '@storacha/blob-index';\nexport { Blob, Index, Upload, UnixFS, CAR };\nexport * from './sharding.js';\nexport { receiptsEndpoint } from './service.js';\nexport * as Receipt from './receipts.js';\n/** @param {Uint8Array} bytes */\nconst isSubArray = (bytes) => bytes.byteOffset !== 0 || bytes.buffer.byteLength !== bytes.byteLength;\n/**\n * Uploads a file to the service and returns the root data CID for the\n * generated DAG.\n *\n * Required delegated capability proofs: `blob/add`, `index/add`,\n * `filecoin/offer`, `upload/add`\n *\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`, or a\n * function that generates this object.\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add`, `index/add`, `filecoin/offer` and\n * `upload/add` delegated capability.\n * @param {import('./types.js').BlobLike} file File data.\n * @param {import('./types.js').UploadFileOptions} [options]\n */\nexport async function uploadFile(conf, file, options = {}) {\n    const shardSize = options.shardSize ?? SHARD_SIZE;\n    if (file.size != null && file.size < shardSize) {\n        const { blocks, cid } = await UnixFS.encodeFile(file, options);\n        return await uploadBlocks(conf, blocks, { rootCID: cid, ...options });\n    }\n    return await uploadBlockStream(conf, UnixFS.createFileEncoderStream(file, options), options);\n}\n/**\n * Uploads a directory of files to the service and returns the root data CID\n * for the generated DAG. All files are added to a container directory, with\n * paths in file names preserved.\n *\n * Required delegated capability proofs: `blob/add`, `index/add`,\n * `filecoin/offer`, `upload/add`\n *\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`, or a\n * function that generates this object\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add`, `index/add`, `filecoin/offer` and\n * `upload/add` delegated capability.\n * @param {import('./types.js').FileLike[]} files  Files that should be in the directory.\n * To ensure determinism in the IPLD encoding, files are automatically sorted by `file.name`.\n * To retain the order of the files as passed in the array, set `customOrder` option to `true`.\n * @param {import('./types.js').UploadDirectoryOptions} [options]\n */\nexport async function uploadDirectory(conf, files, options = {}) {\n    const { customOrder = false } = options;\n    const entries = customOrder ? files : [...files].sort(defaultFileComparator);\n    let size = 0;\n    let isKnownSize = true;\n    for (const entry of entries) {\n        if (entry.size == null) {\n            isKnownSize = false;\n            break;\n        }\n        size += entry.size;\n    }\n    const shardSize = options.shardSize ?? SHARD_SIZE;\n    if (isKnownSize && size < shardSize) {\n        const { blocks, cid } = await UnixFS.encodeDirectory(entries, options);\n        return await uploadBlocks(conf, blocks, { rootCID: cid, ...options });\n    }\n    return await uploadBlockStream(conf, UnixFS.createDirectoryEncoderStream(entries, options), options);\n}\n/**\n * Uploads a CAR file to the service.\n *\n * The difference between this function and `Store.add` is that the CAR file is\n * automatically sharded and an \"upload\" is registered, linking the individual\n * shards (see `Upload.add`).\n *\n * Use the `onShardStored` callback to obtain the CIDs of the CAR file shards.\n *\n * Required delegated capability proofs: `blob/add`, `index/add`,\n * `filecoin/offer`, `upload/add`\n *\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf Configuration\n * for the UCAN invocation. An object with `issuer`, `with` and `proofs`, or a\n * function that generates this object\n *\n * The `issuer` is the signing authority that is issuing the UCAN\n * invocation(s). It is typically the user _agent_.\n *\n * The `with` is the resource the invocation applies to. It is typically the\n * DID of a space.\n *\n * The `proofs` are a set of capability delegations that prove the issuer\n * has the capability to perform the action.\n *\n * The issuer needs the `blob/add`, `index/add`, `filecoin/offer` and `upload/add` delegated capability.\n * @param {import('./types.js').BlobLike} car CAR file.\n * @param {import('./types.js').UploadOptions} [options]\n */\nexport async function uploadCAR(conf, car, options = {}) {\n    const shardSize = options.shardSize ?? SHARD_SIZE;\n    if (car.size != null && car.size < shardSize) {\n        const { blocks, roots } = await CAR.decode(car);\n        return await uploadBlocks(conf, blocks, { rootCID: roots[0], ...options });\n    }\n    const blocks = new CAR.BlockStream(car);\n    options.rootCID = options.rootCID ?? (await blocks.getRoots())[0];\n    return await uploadBlockStream(conf, blocks, options);\n}\n/**\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf\n * @param {ReadableStream<import('@ipld/unixfs').Block>} blocks\n * @param {import('./types.js').UploadOptions} [options]\n * @returns {Promise<import('./types.js').AnyLink>}\n */\nexport async function uploadBlockStream(conf, blocks, { pieceHasher = PieceHasher, ...options } = {}) {\n    /** @type {import('./types.js').InvocationConfigurator} */\n    const configure = typeof conf === 'function' ? conf : () => conf;\n    /** @type {Array<Map<import('./types.js').SliceDigest, import('./types.js').Position>>} */\n    const shardIndexes = [];\n    /** @type {import('./types.js').CARLink[]} */\n    const shards = [];\n    /** @type {import('./types.js').AnyLink?} */\n    let root = null;\n    if (options.dedupe == null || options.dedupe === true) {\n        blocks = blocks.pipeThrough(new BlockDeduplicationStream());\n    }\n    await blocks\n        .pipeThrough(new ShardingStream(options))\n        .pipeThrough(\n    /** @type {TransformStream<import('./types.js').IndexedCARFile, import('./types.js').CARMetadata>} */\n    (new TransformStream({\n        async transform(car, controller) {\n            const bytes = new Uint8Array(await car.arrayBuffer());\n            const digest = await sha256.digest(bytes);\n            const conf = await configure([\n                {\n                    can: BlobAdd.ability,\n                    nb: BlobAdd.input(digest, bytes.length),\n                },\n            ]);\n            // Invoke blob/add and write bytes to write target\n            await Blob.add(conf, digest, bytes, options);\n            const cid = Link.create(CAR.code, digest);\n            let piece;\n            if (pieceHasher) {\n                const multihashDigest = await pieceHasher.digest(bytes);\n                /** @type {import('@storacha/capabilities/types').PieceLink} */\n                piece = Link.create(raw.code, multihashDigest);\n                const content = Link.create(raw.code, digest);\n                // Invoke filecoin/offer for data\n                const result = await Storefront.filecoinOffer({\n                    issuer: conf.issuer,\n                    audience: conf.audience,\n                    // Resource of invocation is the issuer did for being self issued\n                    with: conf.issuer.did(),\n                    proofs: conf.proofs,\n                }, content, piece, options);\n                if (result.out.error) {\n                    throw new Error('failed to offer piece for aggregation into filecoin deal', { cause: result.out.error });\n                }\n            }\n            const { version, roots, size, slices } = car;\n            controller.enqueue({ version, roots, size, cid, piece, slices });\n        },\n    })))\n        .pipeTo(new WritableStream({\n        write(meta) {\n            root = root || meta.roots[0];\n            shards.push(meta.cid);\n            // Make copies of digests that are views on bigger byte arrays. This\n            // prevents memory leak where the bytes for the rest of the CAR cannot\n            // be released because the digest is a view over just a small portion\n            // of the chunk.\n            for (const [s, p] of meta.slices) {\n                if (isSubArray(s.bytes)) {\n                    meta.slices.set(Digest.decode(s.bytes.slice()), p);\n                }\n            }\n            // add the CAR shard itself to the slices\n            meta.slices.set(meta.cid.multihash, [0, meta.size]);\n            shardIndexes.push(meta.slices);\n            if (options.onShardStored)\n                options.onShardStored(meta);\n        },\n    }));\n    /* c8 ignore next */\n    if (!root)\n        throw new Error('missing root CID');\n    const indexBytes = await indexShardedDAG(root, shards, shardIndexes);\n    /* c8 ignore next 3 */\n    if (!indexBytes.ok) {\n        throw new Error('failed to archive DAG index', { cause: indexBytes.error });\n    }\n    const indexDigest = await sha256.digest(indexBytes.ok);\n    const indexLink = Link.create(CAR.code, indexDigest);\n    const [blobAddConf, indexAddConf, uploadAddConf] = await Promise.all([\n        configure([\n            {\n                can: BlobAdd.ability,\n                nb: BlobAdd.input(indexDigest, indexBytes.ok.length),\n            },\n        ]),\n        configure([\n            {\n                can: IndexAdd.ability,\n                nb: IndexAdd.input(indexLink),\n            },\n        ]),\n        configure([\n            {\n                can: UploadAdd.ability,\n                nb: UploadAdd.input(root, shards),\n            },\n        ]),\n    ]);\n    // Store the index in the space\n    await Blob.add(blobAddConf, indexDigest, indexBytes.ok, options);\n    // Register the index with the service\n    await Index.add(indexAddConf, indexLink, options);\n    // Register an upload with the service\n    await Upload.add(uploadAddConf, root, shards, options);\n    return root;\n}\n/**\n * @param {import('./types.js').InvocationConfig|import('./types.js').InvocationConfigurator} conf\n * @param {Iterable<import('@ipld/unixfs').Block>} blocks\n * @param {import('./types.js').UploadOptions} [options]\n * @returns {Promise<import('./types.js').AnyLink>}\n */\nexport async function uploadBlocks(conf, blocks, { pieceHasher = PieceHasher, ...options } = {}) {\n    /** @type {import('./types.js').InvocationConfigurator} */\n    const configure = typeof conf === 'function' ? conf : () => conf;\n    if (options.dedupe == null || options.dedupe === true) {\n        blocks = dedupe(blocks);\n    }\n    /** @type {import('./types.js').IndexedCARFile} */\n    let car;\n    const blockStream = new ReadableStream({\n        pull(controller) {\n            for (const b of blocks) {\n                controller.enqueue(b);\n            }\n            controller.close();\n        },\n    });\n    // encode indexed CAR\n    await blockStream\n        .pipeThrough(new ShardingStream({ ...options, shardSize: Infinity }))\n        .pipeTo(new WritableStream({\n        write: (c) => {\n            car = c;\n        },\n    }));\n    /* c8 ignore next 2 */\n    // @ts-expect-error no used before defined\n    if (!car)\n        throw new Error('missing CAR output');\n    const root = car.roots[0];\n    const bytes = new Uint8Array(await car.arrayBuffer());\n    const digest = await sha256.digest(bytes);\n    const [shardLink, indexLink] = await Promise.all([\n        (async () => {\n            const conf = await configure([\n                {\n                    can: BlobAdd.ability,\n                    nb: BlobAdd.input(digest, bytes.length),\n                },\n            ]);\n            // Invoke blob/add and write bytes to write target\n            await Blob.add(conf, digest, bytes, options);\n            const cid = Link.create(CAR.code, digest);\n            let piece;\n            if (pieceHasher) {\n                const multihashDigest = await pieceHasher.digest(bytes);\n                /** @type {import('@storacha/capabilities/types').PieceLink} */\n                piece = Link.create(raw.code, multihashDigest);\n                // Invoke filecoin/offer for data\n                const result = await Storefront.filecoinOffer({\n                    issuer: conf.issuer,\n                    audience: conf.audience,\n                    // Resource of invocation is the issuer did for being self issued\n                    with: conf.issuer.did(),\n                    proofs: conf.proofs,\n                }, Link.create(raw.code, digest), piece, options);\n                if (result.out.error) {\n                    throw new Error('failed to offer piece for aggregation into filecoin deal', { cause: result.out.error });\n                }\n            }\n            const { version, roots, size, slices } = car;\n            options.onShardStored?.({ version, roots, size, piece, cid, slices });\n            return cid;\n        })(),\n        (async () => {\n            const index = ShardedDAGIndex.create(root);\n            for (const [slice, pos] of car.slices) {\n                index.setSlice(digest, slice, pos);\n            }\n            // add the CAR shard itself to the slices\n            index.setSlice(digest, digest, [0, car.size]);\n            const indexBytes = await index.archive();\n            /* c8 ignore next 5 */\n            if (!indexBytes.ok) {\n                throw new Error('failed to archive DAG index', {\n                    cause: indexBytes.error,\n                });\n            }\n            const indexDigest = await sha256.digest(indexBytes.ok);\n            const indexLink = Link.create(CAR.code, indexDigest);\n            const conf = await configure([\n                {\n                    can: BlobAdd.ability,\n                    nb: BlobAdd.input(indexDigest, indexBytes.ok.length),\n                },\n            ]);\n            // Store the index in the space\n            await Blob.add(conf, indexDigest, indexBytes.ok, options);\n            return indexLink;\n        })(),\n    ]);\n    await Promise.all([\n        (async () => {\n            const conf = await configure([\n                {\n                    can: IndexAdd.ability,\n                    nb: IndexAdd.input(indexLink),\n                },\n            ]);\n            // Register the index with the service\n            await Index.add(conf, indexLink, options);\n        })(),\n        (async () => {\n            const conf = await configure([\n                {\n                    can: UploadAdd.ability,\n                    nb: UploadAdd.input(root, [shardLink]),\n                },\n            ]);\n            // Register an upload with the service\n            await Upload.add(conf, root, [shardLink], options);\n        })(),\n    ]);\n    return root;\n}\n//# sourceMappingURL=index.js.map", "/* globals WorkerGlobalScope, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope */\n\nexport const isBrowser = globalThis.window?.document !== undefined;\n\nexport const isNode = globalThis.process?.versions?.node !== undefined;\n\nexport const isBun = globalThis.process?.versions?.bun !== undefined;\n\nexport const isDeno = globalThis.Deno?.version?.deno !== undefined;\n\nexport const isElectron = globalThis.process?.versions?.electron !== undefined;\n\nexport const isJsDom = globalThis.navigator?.userAgent?.includes('jsdom') === true;\n\nexport const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && globalThis instanceof WorkerGlobalScope;\n\nexport const isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== 'undefined' && globalThis instanceof DedicatedWorkerGlobalScope;\n\nexport const isSharedWorker = typeof SharedWorkerGlobalScope !== 'undefined' && globalThis instanceof SharedWorkerGlobalScope;\n\nexport const isServiceWorker = typeof ServiceWorkerGlobalScope !== 'undefined' && globalThis instanceof ServiceWorkerGlobalScope;\n\n// Note: I'm intentionally not DRYing up the other variables to keep them \"lazy\".\nconst platform = globalThis.navigator?.userAgentData?.platform;\n\nexport const isMacOs = platform === 'macOS'\n\t|| globalThis.navigator?.platform === 'MacIntel' // Even on Apple silicon Macs.\n\t|| globalThis.navigator?.userAgent?.includes(' Mac ') === true\n\t|| globalThis.process?.platform === 'darwin';\n\nexport const isWindows = platform === 'Windows'\n\t|| globalThis.navigator?.platform === 'Win32'\n\t|| globalThis.process?.platform === 'win32';\n\nexport const isLinux = platform === 'Linux'\n\t|| globalThis.navigator?.platform?.startsWith('Linux') === true\n\t|| globalThis.navigator?.userAgent?.includes(' Linux ') === true\n\t|| globalThis.process?.platform === 'linux';\n\nexport const isIos = platform === 'iOS'\n\t|| (globalThis.navigator?.platform === 'MacIntel' && globalThis.navigator?.maxTouchPoints > 1)\n\t|| /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);\n\nexport const isAndroid = platform === 'Android'\n\t|| globalThis.navigator?.platform === 'Android'\n\t|| globalThis.navigator?.userAgent?.includes(' Android ') === true\n\t|| globalThis.process?.platform === 'android';\n", "import { isBrowser, isNode, isBun, isDeno, isElectron } from 'environment';\nimport * as client from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport * as DID from '@ipld/dag-ucan/did';\nimport { receiptsEndpoint } from '@storacha/upload-client';\nexport const accessServiceURL = new URL('https://up.storacha.network');\nexport const accessServicePrincipal = DID.parse('did:web:up.storacha.network');\n/* c8 ignore start */\nconst envName = isBrowser\n    ? 'Browser'\n    : isNode\n        ? 'Node'\n        : isBun\n            ? 'Bun'\n            : isDeno\n                ? 'Deno'\n                : isElectron\n                    ? 'Electron'\n                    : 'Unknown';\nexport const defaultHeaders = {\n    'X-Client': `Storacha/1 (js; ${envName})`,\n};\n/* c8 ignore end */\n/**\n * @param {object} [options]\n * @param {Record<string, string>} [options.headers]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const accessServiceConnection = (options = {}) => client.connect({\n    id: options.id ?? accessServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: options.url ?? accessServiceURL,\n        method: 'POST',\n        headers: { ...defaultHeaders, ...options.headers },\n    }),\n});\nexport const uploadServiceURL = new URL('https://up.storacha.network');\nexport const uploadServicePrincipal = DID.parse('did:web:up.storacha.network');\n/**\n * @param {object} [options]\n * @param {Record<string, string>} [options.headers]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const uploadServiceConnection = (options = {}) => client.connect({\n    id: options.id ?? uploadServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: options.url ?? uploadServiceURL,\n        method: 'POST',\n        headers: { ...defaultHeaders, ...options.headers },\n    }),\n});\nexport const filecoinServiceURL = new URL('https://up.storacha.network');\nexport const filecoinServicePrincipal = DID.parse('did:web:up.storacha.network');\n/**\n * @param {object} [options]\n * @param {Record<string, string>} [options.headers]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const filecoinServiceConnection = (options = {}) => client.connect({\n    id: options.id ?? filecoinServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: options.url ?? filecoinServiceURL,\n        method: 'POST',\n        headers: { ...defaultHeaders, ...options.headers },\n    }),\n});\n// Note: we use a UCAN service domain that is different to the public access\n// domain so that if public access is blocked it does not effect authorization\n// invocations.\nexport const gatewayServiceURL = new URL('https://gateway.storacha.network');\nexport const gatewayServicePrincipal = DID.parse('did:web:w3s.link');\n/**\n * Create a connection to a gateway service.\n *\n * @param {object} [options]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const gatewayServiceConnection = ({ id, url } = {}) => client.connect({\n    id: id ?? gatewayServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: url ?? gatewayServiceURL,\n        method: 'POST',\n    }),\n});\n/** @type {() => import('./types.js').ServiceConf} */\nexport const serviceConf = () => ({\n    access: accessServiceConnection(),\n    upload: uploadServiceConnection(),\n    filecoin: filecoinServiceConnection(),\n    gateway: gatewayServiceConnection(),\n});\nexport { receiptsEndpoint };\n//# sourceMappingURL=service.js.map", "import { Agent } from '@storacha/access/agent';\nimport { serviceConf, receiptsEndpoint } from './service.js';\nexport class Base {\n    /**\n     * @type {Agent}\n     * @protected\n     */\n    _agent;\n    /**\n     * @type {import('./types.js').ServiceConf}\n     * @protected\n     */\n    _serviceConf;\n    /**\n     * @param {import('@storacha/access').AgentData} agentData\n     * @param {object} [options]\n     * @param {import('./types.js').ServiceConf} [options.serviceConf]\n     * @param {URL} [options.receiptsEndpoint]\n     */\n    constructor(agentData, options = {}) {\n        this._serviceConf = options.serviceConf ?? serviceConf();\n        this._agent = new Agent(agentData, {\n            servicePrincipal: this._serviceConf.access.id,\n            // @ts-expect-error I know but it will be HTTP for the forseeable.\n            url: this._serviceConf.access.channel.url,\n            connection: this._serviceConf.access,\n        });\n        this._receiptsEndpoint = options.receiptsEndpoint ?? receiptsEndpoint;\n    }\n    /**\n     * The current user agent (this device).\n     *\n     * @type {Agent}\n     */\n    get agent() {\n        return this._agent;\n    }\n    /**\n     * @protected\n     * @param {import('./types.js').Ability[]} abilities\n     */\n    async _invocationConfig(abilities) {\n        const resource = this._agent.currentSpace();\n        if (!resource) {\n            throw new Error('missing current space: use createSpace() or setCurrentSpace()');\n        }\n        const issuer = this._agent.issuer;\n        const proofs = await this._agent.proofs(abilities.map((can) => ({ can, with: resource })));\n        const audience = this._serviceConf.upload.id;\n        return { issuer, with: resource, proofs, audience };\n    }\n}\n//# sourceMappingURL=base.js.map", "import * as API from './types.js';\nimport * as Access from './capability/access.js';\nimport * as Plan from './capability/plan.js';\nimport * as Subscription from './capability/subscription.js';\nimport { Delegation, importAuthorization } from '@storacha/access/agent';\nimport { add as provision, AccountDID } from '@storacha/access/provider';\nimport { fromEmail, toEmail } from '@storacha/did-mailto';\nimport * as UCAN from '@storacha/capabilities/ucan';\nexport { fromEmail };\n/**\n * @typedef {import('@storacha/did-mailto').EmailAddress} EmailAddress\n */\n/**\n * List all accounts that agent has stored access to. Returns a dictionary\n * of accounts keyed by their `did:mailto` identifier.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} query\n * @param {API.DID<'mailto'>} [query.account]\n */\nexport const list = ({ agent }, { account } = {}) => {\n    const query = /** @type {API.CapabilityQuery} */ ({\n        with: account ?? /did:mailto:.*/,\n        can: '*',\n    });\n    const proofs = agent.proofs([query]);\n    /** @type {Record<API.DidMailto, Account>} */\n    const accounts = {};\n    /** @type {Record<string, API.Delegation>} */\n    const attestations = {};\n    for (const proof of proofs) {\n        const access = Delegation.allows(proof);\n        for (const [resource, abilities] of Object.entries(access)) {\n            if (AccountDID.is(resource) && abilities['*']) {\n                const id = /** @type {API.DidMailto} */ (resource);\n                const account = accounts[id] ||\n                    (accounts[id] = new Account({ id, agent, proofs: [] }));\n                account.addProof(proof);\n            }\n            for (const settings of /** @type {{proof?:API.Link}[]} */ (abilities['ucan/attest'] || [])) {\n                const id = settings.proof;\n                if (id) {\n                    attestations[`${id}`] = proof;\n                }\n            }\n        }\n    }\n    for (const account of Object.values(accounts)) {\n        for (const proof of account.proofs) {\n            const attestation = attestations[`${proof.cid}`];\n            if (attestation) {\n                account.addProof(attestation);\n            }\n        }\n    }\n    return accounts;\n};\n/**\n * Attempts to obtains an account access by performing an authentication with\n * the did:mailto account corresponding to given email. Process involves out\n * of bound email verification, so this function returns a promise that will\n * resolve to an account only after access has been granted by the email owner\n * by clicking on the link in the email. If the link is not clicked within the\n * authorization session time bounds (currently 15 minutes), the promise will\n * resolve to an error.\n *\n * @param {{agent: API.Agent}} client\n * @param {EmailAddress} email\n * @param {object} [options]\n * @param {AbortSignal} [options.signal]\n * @param {API.AppName} [options.appName]\n * @param {API.SSORequestParams} [options.sso] - SSO authentication (all fields required if provided)\n * @returns {Promise<API.Result<Account, Error>>}\n */\nexport const login = async ({ agent }, email, options = {}) => {\n    const account = fromEmail(email);\n    // If we already have a session for this account we\n    // skip the authentication process, otherwise we will\n    // end up adding more UCAN proofs and attestations to\n    // the store which we then will be sending when using\n    // this account.\n    // Note: This is not a robust solution as there may be\n    // reasons to re-authenticate e.g. previous session is\n    // no longer valid because it was revoked. But dropping\n    // revoked UCANs from store is something we should do\n    // anyway.\n    const session = list({ agent }, { account })[account];\n    if (session) {\n        return { ok: session };\n    }\n    const result = await Access.request({ agent }, {\n        account,\n        access: Access.accountAccess,\n        appName: options.appName,\n        sso: options.sso,\n    });\n    const { ok: access, error } = result;\n    /* c8 ignore next 2 - don't know how to test this */\n    if (error) {\n        return { error };\n    }\n    else {\n        const { ok, error } = await access.claim({ signal: options.signal });\n        /* c8 ignore next 2 - don't know how to test this */\n        if (error) {\n            return { error };\n        }\n        else {\n            return { ok: new Account({ id: account, proofs: ok.proofs, agent }) };\n        }\n    }\n};\n/* c8 ignore start */\n/**\n * Attempts to obtain account access for an out of band authentication process.\n * e.g. OAuth.\n *\n * Authentication is typically performed out of band by an OAuth provider. In\n * the OAuth callback, a delegation for the requested capabilities is issued\n * _from_ the email reported by the OAuth provider _to_ the agent. The service\n * also issues an attestation for this delegation.\n *\n * These capabilities are then claimed (using `access/claim`) and the account\n * email is derived from the delegation to the agent.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} input\n * @param {API.Link} input.request Link to the `access/authorize` invocation.\n * @param {API.UTCUnixTimestamp} input.expiration Seconds in UTC.\n * @param {AbortSignal} [input.signal]\n * @param {string} [input.receiptsEndpoint]\n * @returns {Promise<API.Result<Account, Error>>}\n */\nexport const externalLogin = async ({ agent }, { request, expiration, ...options }) => {\n    const access = Access.createPendingAccessRequest({ agent }, { request, expiration });\n    const { ok, error } = await access.claim({ signal: options.signal });\n    /* c8 ignore next 2 - don't know how to test this */\n    if (error) {\n        return { error };\n    }\n    let attestedProof;\n    for (const p of ok.proofs) {\n        if (isUCANAttest(p)) {\n            attestedProof = p.capabilities[0].nb.proof;\n            break;\n        }\n    }\n    if (!attestedProof) {\n        return { error: new Error('missing attestation') };\n    }\n    let account;\n    for (const p of ok.proofs) {\n        if (p.cid.toString() === attestedProof.toString()) {\n            try {\n                account = Access.DIDMailto.fromString(p.issuer.did());\n            }\n            catch (err) {\n                return { error: new Error('invalid account DID', { cause: err }) };\n            }\n            break;\n        }\n    }\n    if (!account) {\n        return { error: new Error('missing attested delegation') };\n    }\n    return { ok: new Account({ id: account, proofs: ok.proofs, agent }) };\n};\n/* c8 ignore end */\n/**\n * @param {API.Delegation} d\n * @returns {d is API.Delegation<[API.UCANAttest]>}\n */\nconst isUCANAttest = (d) => d.capabilities[0].can === UCAN.attest.can;\n/**\n * @typedef {object} Model\n * @property {API.DidMailto} id\n * @property {API.Agent} agent\n * @property {API.Delegation[]} proofs\n */\nexport class Account {\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.model = model;\n        this.plan = new AccountPlan(model);\n    }\n    get agent() {\n        return this.model.agent;\n    }\n    get proofs() {\n        return this.model.proofs;\n    }\n    did() {\n        return this.model.id;\n    }\n    toEmail() {\n        return toEmail(this.did());\n    }\n    /**\n     * @param {API.Delegation} proof\n     */\n    addProof(proof) {\n        this.proofs.push(proof);\n    }\n    toJSON() {\n        return {\n            id: this.did(),\n            proofs: this.proofs\n                // we sort proofs to get a deterministic JSON representation.\n                .sort((a, b) => a.cid.toString().localeCompare(b.cid.toString()))\n                .map((proof) => proof.toJSON()),\n        };\n    }\n    /**\n     * Provisions given `space` with this account.\n     *\n     * @param {API.SpaceDID} space\n     * @param {object} input\n     * @param {API.ProviderDID} [input.provider]\n     * @param {API.Agent} [input.agent]\n     */\n    provision(space, input = {}) {\n        return provision(this.agent, {\n            ...input,\n            account: this.did(),\n            consumer: space,\n            proofs: this.proofs,\n        });\n    }\n    /**\n     * Saves account in the agent store so it can be accessed across sessions.\n     *\n     * @param {object} input\n     * @param {API.Agent} [input.agent]\n     */\n    async save({ agent = this.agent } = {}) {\n        return await importAuthorization(agent, this);\n    }\n}\nexport class AccountPlan {\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Gets information about the plan associated with this account.\n     *\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async get(options) {\n        return await Plan.get(this.model, {\n            ...options,\n            account: this.model.id,\n            proofs: this.model.proofs,\n        });\n    }\n    /**\n     * Sets the plan associated with this account.\n     *\n     * @param {import('@ucanto/interface').DID} productDID\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async set(productDID, options) {\n        return await Plan.set(this.model, {\n            ...options,\n            account: this.model.id,\n            product: productDID,\n            proofs: this.model.proofs,\n        });\n    }\n    /**\n     * Waits for a payment plan to be selected.\n     * This method continuously checks the account's payment plan status\n     * at a specified interval until a valid plan is selected, or when the timeout is reached,\n     * or when the abort signal is aborted.\n     *\n     * @param {object} [options]\n     * @param {number} [options.interval] - The polling interval in milliseconds (default is 1000ms).\n     * @param {number} [options.timeout] - The maximum time to wait in milliseconds before throwing a timeout error (default is 15 minutes).\n     * @param {AbortSignal} [options.signal] - An optional AbortSignal to cancel the waiting process.\n     * @returns {Promise<import('@storacha/access').PlanGetSuccess>} - Resolves once a payment plan is selected within the timeout.\n     * @throws {Error} - Throws an error if there is an issue retrieving the payment plan or if the timeout is exceeded.\n     */\n    async wait(options) {\n        const startTime = Date.now();\n        const interval = options?.interval || 1000; // 1 second\n        const timeout = options?.timeout || 60 * 15 * 1000; // 15 minutes\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const res = await this.get();\n            if (res.ok)\n                return res.ok;\n            if (res.error) {\n                if (res.error.name === 'PlanNotFound') {\n                    continue;\n                }\n                throw new Error(`Error retrieving payment plan: ${JSON.stringify(res.error)}`);\n            }\n            if (Date.now() - startTime > timeout) {\n                throw new Error('Timeout: Payment plan selection took too long.');\n            }\n            if (options?.signal?.aborted) {\n                throw new Error('Aborted: Payment plan selection was aborted.');\n            }\n            console.log('Waiting for payment plan to be selected...');\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n    }\n    /**\n     *\n     * @param {import('@storacha/access').AccountDID} accountDID\n     * @param {string} returnURL\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async createAdminSession(accountDID, returnURL, options) {\n        return await Plan.createAdminSession(this.model, {\n            ...options,\n            account: accountDID,\n            returnURL,\n        });\n    }\n    /**\n     *\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async subscriptions(options) {\n        return await Subscription.list(this.model, {\n            ...options,\n            account: this.model.id,\n            proofs: this.model.proofs,\n        });\n    }\n}\n//# sourceMappingURL=account.js.map", "export * from '@ucanto/interface';\nexport * from '@storacha/did-mailto';\nexport { AppName } from '@storacha/access/types';\nexport { Client } from './client.js';\n//# sourceMappingURL=types.js.map", "export * from '@ucanto/core/result';\nimport * as API from '@ucanto/interface';\n/**\n * Returns contained `ok` if result is and throws `error` if result is not ok.\n *\n * @template T\n * @param {API.Result<T, {}>} result\n * @returns {T}\n */\nexport const unwrap = ({ ok, error }) => {\n    if (error) {\n        throw error;\n    }\n    else {\n        return /** @type {T} */ (ok);\n    }\n};\n/**\n * Also expose as `Result.try` which is arguably more clear.\n */\nexport { unwrap as try };\n//# sourceMappingURL=result.js.map", "import { Base } from '../base.js';\nimport * as Agent from '@storacha/access/agent';\nimport * as DIDMailto from '@storacha/did-mailto';\nimport * as Result from '../result.js';\nimport * as API from '../types.js';\nexport { DIDMailto };\n/**\n * Client for interacting with the `access/*` capabilities.\n */\nexport class AccessClient extends Base {\n    /* c8 ignore start - testing websocket code is hard */\n    /**\n     * Authorize the current agent to use capabilities granted to the passed\n     * email account.\n     *\n     * @deprecated Use `request` instead.\n     *\n     * @param {`${string}@${string}`} email\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @param {Iterable<{ can: API.Ability }>} [options.capabilities]\n     */\n    async authorize(email, options) {\n        const account = DIDMailto.fromEmail(email);\n        const authorization = Result.unwrap(await request(this, { account }));\n        const access = Result.unwrap(await authorization.claim(options));\n        await Result.unwrap(await access.save());\n        return access.proofs;\n    }\n    /* c8 ignore stop */\n    /**\n     * Claim delegations granted to the account associated with this agent.\n     *\n     * @param {object} [input]\n     * @param {API.DID} [input.audience]\n     */\n    async claim(input) {\n        const access = Result.unwrap(await claim(this, input));\n        await Result.unwrap(await access.save());\n        return access.proofs;\n    }\n    /**\n     * Requests specified `access` level from the account from the given account.\n     *\n     * @param {object} input\n     * @param {API.AccountDID} input.account\n     * @param {API.Access} [input.access]\n     * @param {AbortSignal} [input.signal]\n     */\n    async request(input) {\n        return await request(this, input);\n    }\n    /**\n     * Shares access with delegates.\n     *\n     * @param {object} input\n     * @param {API.Delegation[]} input.delegations\n     * @param {API.SpaceDID} [input.space]\n     * @param {API.Delegation[]} [input.proofs]\n     */\n    async delegate(input) {\n        return await delegate(this, input);\n    }\n}\n/**\n * @param {{agent: API.Agent}} client\n * @param {object} [input]\n * @param {API.DID} [input.audience]\n */\nexport const claim = async ({ agent }, input) => Agent.Access.claim(agent, input);\n/**\n * Requests specified `access` level from specified `account`. It will invoke\n * `access/authorize` capability and keep polling `access/claim` capability\n * until access is granted or request is aborted.\n *\n * @param {{agent: API.Agent}} agent\n * @param {object} input\n * @param {API.AccountDID} input.account\n * @param {API.Access} [input.access]\n * @param {API.DID} [input.audience]\n * @param {Agent.AppName} [input.appName]\n * @param {API.SSORequestParams} [input.sso] - SSO authentication request (all fields required if provided)\n */\nexport const request = async ({ agent }, input) => Agent.Access.request(agent, input);\n/**\n * Creates a new `PendingAccessRequest` object that can be used to poll for the\n * requested delegation through `access/claim` capability.\n *\n * @param {{agent: API.Agent}} agent\n * @param {object} input\n * @param {API.Link} input.request - Link to the `access/authorize` invocation.\n * @param {API.UTCUnixTimestamp} input.expiration - Seconds in UTC.\n * @param {API.DID} [input.audience] - Principal requesting an access.\n * @param {API.ProviderDID} [input.provider] - Provider handling request.\n */\n/* c8 ignore next 2 */\nexport const createPendingAccessRequest = ({ agent }, input) => Agent.Access.createPendingAccessRequest(agent, input);\n/**\n *\n * @param {{agent: API.Agent}} agent\n * @param {object} input\n * @param {API.Delegation[]} input.delegations\n * @param {API.SpaceDID} [input.space]\n * @param {API.Delegation[]} [input.proofs]\n */\nexport const delegate = async ({ agent }, input) => Agent.Access.delegate(agent, input);\nexport const { spaceAccess, accountAccess } = Agent.Access;\n//# sourceMappingURL=access.js.map", "import { Base } from '../base.js';\nimport * as API from '../types.js';\nimport * as Plan from '@storacha/capabilities/plan';\nexport class PlanClient extends Base {\n    /**\n     * Required delegated capabilities:\n     * - `plan/get`\n     *\n     * @param {import('@storacha/access').AccountDID} account\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async get(account, options) {\n        const out = await get({ agent: this.agent }, { ...options, account });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.get.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n    /**\n     * Required delegated capabilities:\n     * - `plan/set`\n     *\n     * @param {API.AccountDID} account\n     * @param {API.DID} product\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async set(account, product, options) {\n        const out = await set({ agent: this.agent }, { ...options, account, product });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.set.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n    /**\n     *\n     * @param {API.AccountDID} account\n     * @param {string} returnURL\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async createAdminSession(account, returnURL, options) {\n        const out = await createAdminSession({ agent: this.agent }, { ...options, account, returnURL });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.createAdminSession.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Gets the plan currently associated with the account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const get = async ({ agent }, { account, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(Plan.get, {\n        with: account,\n        proofs,\n        nonce,\n    });\n    return receipt.out;\n};\n/**\n * Sets the plan currently associated with the account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.DID} options.product\n * @param {API.AccountDID} options.account\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const set = async ({ agent }, { account, product, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(Plan.set, {\n        with: account,\n        nb: { product },\n        nonce,\n        proofs,\n    });\n    return receipt.out;\n};\n/**\n * Creates an admin session for the given account.\n *\n * Returns a URL that a user can resolve to enter the\n * admin billing portal for this account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {string} options.returnURL\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const createAdminSession = async ({ agent }, { account, returnURL, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(Plan.createAdminSession, {\n        with: account,\n        proofs,\n        nonce,\n        nb: {\n            returnURL,\n        },\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=plan.js.map", "import { Subscription as SubscriptionCapabilities } from '@storacha/capabilities';\nimport * as API from '../types.js';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `subscription/*` capabilities.\n */\nexport class SubscriptionClient extends Base {\n    /**\n     * List subscriptions for the passed account.\n     *\n     * Required delegated capabilities:\n     * - `subscription/list`\n     *\n     * @param {import('@storacha/access').AccountDID} account\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    /* c8 ignore next */\n    async list(account, options) {\n        const out = await list({ agent: this.agent }, { ...options, account });\n        /* c8 ignore next 8 */\n        if (!out.ok) {\n            throw new Error(`failed ${SubscriptionCapabilities.list.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Gets subscriptions associated with the account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const list = async ({ agent }, { account, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(SubscriptionCapabilities.list, {\n        with: account,\n        proofs,\n        nb: undefined,\n        nonce,\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=subscription.js.map", "import { Usage as UsageCapabilities } from '@storacha/capabilities';\nimport * as API from '../types.js';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `usage/*` capabilities.\n */\nexport class UsageClient extends Base {\n    /**\n     * Get a usage report for the passed space in the given time period.\n     *\n     * Required delegated capabilities:\n     * - `usage/report`\n     *\n     * @param {import('../types.js').SpaceDID} space\n     * @param {{ from: Date, to: Date }} period\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async report(space, period, options) {\n        const out = await report({ agent: this.agent }, { ...options, space, period });\n        /* c8 ignore next 7 */\n        if (!out.ok) {\n            throw new Error(`failed ${UsageCapabilities.report.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Get a usage report for the period.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.SpaceDID} options.space\n * @param {{ from: Date, to: Date }} options.period\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n * @returns {Promise<API.Result<API.UsageReportSuccess, API.UsageReportFailure>>}\n */\nexport const report = async ({ agent }, { space, period, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(UsageCapabilities.report, {\n        with: space,\n        proofs,\n        nonce,\n        nb: {\n            period: {\n                from: Math.floor(period.from.getTime() / 1000),\n                to: Math.ceil(period.to.getTime() / 1000),\n            },\n        },\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=usage.js.map", "export * from '@storacha/access/space';\nimport * as Usage from './capability/usage.js';\nimport * as API from './types.js';\n/**\n * @typedef {object} Model\n * @property {API.SpaceDID} id\n * @property {{name?:string, access?:import('@storacha/access').SpaceAccessType}} [meta]\n * @property {API.Agent} agent\n */\nexport class Space {\n    #model;\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.#model = model;\n        this.usage = new StorageUsage(model);\n    }\n    /**\n     * The given space name.\n     */\n    get name() {\n        /* c8 ignore next */\n        return String(this.#model.meta?.name ?? '');\n    }\n    get access() {\n        return this.#model.meta?.access ?? { type: 'public' };\n    }\n    /**\n     * The DID of the space.\n     */\n    did() {\n        return this.#model.id;\n    }\n    /**\n     * User defined space metadata.\n     */\n    meta() {\n        return this.#model.meta;\n    }\n}\nexport class StorageUsage {\n    #model;\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.#model = model;\n    }\n    /**\n     * Get the current usage in bytes.\n     */\n    async get() {\n        const { agent } = this.#model;\n        const space = this.#model.id;\n        const now = new Date();\n        const period = {\n            // we may not have done a snapshot for this month _yet_, so get report\n            // from last month -> now\n            from: startOfLastMonth(now),\n            to: now,\n        };\n        const result = await Usage.report({ agent }, { space, period });\n        /* c8 ignore next */\n        if (result.error)\n            return result;\n        const provider = /** @type {API.ProviderDID} */ (agent.connection.id.did());\n        const report = result.ok[provider];\n        return {\n            /* c8 ignore next */\n            ok: report?.size.final == null ? undefined : BigInt(report.size.final),\n        };\n    }\n}\n/** @param {string|number|Date} now */\nconst startOfMonth = (now) => {\n    const d = new Date(now);\n    d.setUTCDate(1);\n    d.setUTCHours(0);\n    d.setUTCMinutes(0);\n    d.setUTCSeconds(0);\n    d.setUTCMilliseconds(0);\n    return d;\n};\n/** @param {string|number|Date} now */\nconst startOfLastMonth = (now) => {\n    const d = startOfMonth(now);\n    d.setUTCMonth(d.getUTCMonth() - 1);\n    return d;\n};\n//# sourceMappingURL=space.js.map", "import { Delegation } from '@ucanto/core/delegation';\nexport * from '@ucanto/core/delegation';\n/* c8 ignore start */\n/**\n * @template {import('./types.js').Capabilities} C\n * @extends {Delegation<C>}\n */\nexport class AgentDelegation extends Delegation {\n    /* c8 ignore stop */\n    /** @type {Record<string, any>} */\n    #meta;\n    /**\n     * @param {import('./types.js').UCANBlock<C>} root\n     * @param {Map<string, import('./types.js').Block>} [blocks]\n     * @param {Record<string, any>} [meta]\n     */\n    constructor(root, blocks, meta = {}) {\n        super(root, blocks);\n        this.#meta = meta;\n    }\n    /**\n     * User defined delegation metadata.\n     */\n    meta() {\n        return this.#meta;\n    }\n}\n//# sourceMappingURL=delegation.js.map", "import { Blob } from '@storacha/upload-client';\nimport { SpaceBlob as BlobCapabilities } from '@storacha/capabilities';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { Base } from '../base.js';\n/** @import { AssertLocation } from '@web3-storage/content-claims/capability/api' */\n/**\n * Client for interacting with the `blob/*` capabilities.\n */\nexport class BlobClient extends Base {\n    /**\n     * Store a Blob to the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/add`\n     *\n     * @param {Blob} blob - blob data.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async add(blob, options = {}) {\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        const conf = await this._invocationConfig([BlobCapabilities.add.can]);\n        const bytes = new Uint8Array(await blob.arrayBuffer());\n        const digest = await sha256.digest(bytes);\n        return { digest, ...(await Blob.add(conf, digest, bytes, options)) };\n    }\n    /**\n     * List blobs stored to the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/list`\n     *\n     * @param {import('../types.js').ListRequestOptions} [options]\n     */\n    async list(options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.list.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.list(conf, options);\n    }\n    /**\n     * Remove a stored blob by multihash digest.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/remove`\n     *\n     * @param {import('multiformats').MultihashDigest} digest - digest of blob to remove.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async remove(digest, options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.remove.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.remove(conf, digest, options);\n    }\n    /**\n     * Gets a stored blob by multihash digest.\n     *\n     * @param {import('multiformats').MultihashDigest} digest - digest of blob to get.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async get(digest, options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.get.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.get(conf, digest, options);\n    }\n    /**\n     * Replicate a blob to the specified number of nodes.\n     *\n     * @param {object} blob - details of the blob to replicate\n     * @param {import('multiformats').MultihashDigest} blob.digest - hash of the blob\n     * @param {number} blob.size - size of the blob in bytes\n     * @param {import('../types.js').Delegation<[AssertLocation]>} site - location commitment specifying where the blob can be obtained.\n     * @param {number} replicas - total number of replicas to provision.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async replicate(blob, site, replicas, options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.replicate.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.replicate(conf, blob, site, replicas, options);\n    }\n}\n//# sourceMappingURL=blob.js.map", "import { Index } from '@storacha/upload-client';\nimport { SpaceIndex as IndexCapabilities } from '@storacha/capabilities';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `index/*` capabilities.\n */\nexport class IndexClient extends Base {\n    /**\n     * Register an \"index\" to the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/index/add`\n     *\n     * @param {import('../types.js').CARLink} index - CID of the CAR file that contains the index data.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async add(index, options = {}) {\n        const conf = await this._invocationConfig([IndexCapabilities.add.can]);\n        options.connection = this._serviceConf.upload;\n        return Index.add(conf, index, options);\n    }\n}\n//# sourceMappingURL=index.js.map", "import { Upload } from '@storacha/upload-client';\nimport { Upload as UploadCapabilities } from '@storacha/capabilities';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `upload/*` capabilities.\n */\nexport class UploadClient extends Base {\n    /**\n     * Register an \"upload\" to the resource.\n     *\n     * Required delegated capabilities:\n     * - `upload/add`\n     *\n     * @param {import('../types.js').UnknownLink} root - Root data CID for the DAG that was stored.\n     * @param {import('../types.js').CARLink[]} shards - CIDs of CAR files that contain the DAG.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async add(root, shards, options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.add.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.add(conf, root, shards, options);\n    }\n    /**\n     * Get details of an \"upload\".\n     *\n     * Required delegated capabilities:\n     * - `upload/get`\n     *\n     * @param {import('../types.js').UnknownLink} root - Root data CID for the DAG that was stored.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async get(root, options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.get.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.get(conf, root, options);\n    }\n    /**\n     * List uploads registered to the resource.\n     *\n     * Required delegated capabilities:\n     * - `upload/list`\n     *\n     * @param {import('../types.js').ListRequestOptions} [options]\n     */\n    async list(options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.list.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.list(conf, options);\n    }\n    /**\n     * Remove an upload by root data CID.\n     *\n     * Required delegated capabilities:\n     * - `upload/remove`\n     *\n     * @param {import('../types.js').UnknownLink} root - Root data CID to remove.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async remove(root, options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.remove.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.remove(conf, root, options);\n    }\n}\n//# sourceMappingURL=upload.js.map", "import { Base } from '../base.js';\nimport { Space as SpaceCapabilities } from '@storacha/capabilities';\nimport * as API from '../types.js';\n/**\n * Client for interacting with the `space/*` capabilities.\n */\nexport class SpaceClient extends Base {\n    /**\n     * Get information about a space.\n     *\n     * Required delegated capabilities:\n     * - `space/info`\n     *\n     * @param {import('../types.js').DID} space - DID of the space to retrieve info about.\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async info(space, options) {\n        return await this._agent.getSpaceInfo(space, options);\n    }\n    /**\n     * Record egress data for a served resource.\n     * It will execute the capability invocation to find the customer and then record the egress data for the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/content/serve/egress/record`\n     *\n     * @param {object} egressData\n     * @param {import('../types.js').SpaceDID} egressData.space\n     * @param {API.UnknownLink} egressData.resource\n     * @param {number} egressData.bytes\n     * @param {string} egressData.servedAt\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     * @param {API.Delegation[]} [options.proofs]\n     * @returns {Promise<API.EgressRecordSuccess>}\n     */\n    async egressRecord(egressData, options) {\n        const out = await egressRecord({ agent: this.agent }, { ...egressData }, { ...options });\n        if (!out.ok) {\n            throw new Error(`failed ${SpaceCapabilities.egressRecord.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return /** @type {API.EgressRecordSuccess} */ (out.ok);\n    }\n}\n/**\n * Record egress data for a resource from a given space.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} egressData\n * @param {API.SpaceDID} egressData.space\n * @param {API.UnknownLink} egressData.resource\n * @param {number} egressData.bytes\n * @param {string} egressData.servedAt\n * @param {object} options\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const egressRecord = async ({ agent }, { space, resource, bytes, servedAt }, { nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(SpaceCapabilities.egressRecord, {\n        with: space,\n        proofs,\n        nonce,\n        nb: {\n            resource,\n            bytes,\n            servedAt: Math.floor(new Date(servedAt).getTime() / 1000),\n        },\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=space.js.map", "import { AccountUsage as AccountUsageCapabilites } from '@storacha/capabilities';\nimport * as API from '../../types.js';\nimport { Base } from '../../base.js';\n/**\n * Client for interacting with the `usage/*` capabilities.\n */\nexport class AccountUsageClient extends Base {\n    /**\n     * Get a usage report for the passed space in the given time period.\n     *\n     * Required delegated capabilities:\n     * - `usage/report`\n     *\n     * @param {API.AccountDID} account\n     * @param {object} [options]\n     * @param {{ from: Date, to: Date }} [options.period]\n     * @param {import('../../types.js').SpaceDID[]} [options.spaces]\n     * @param {string} [options.nonce]\n     */\n    async get(account, options) {\n        const out = await get({ agent: this.agent }, { ...options, account });\n        /* c8 ignore next 7 */\n        if (!out.ok) {\n            throw new Error(`failed ${AccountUsageCapabilites.get.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Get a usage report for the period.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {API.SpaceDID[]} [options.spaces]\n * @param {{ from: Date, to: Date }} [options.period]\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n * @returns {Promise<API.Result<API.AccountUsageGetSuccess, API.AccountUsageGetFailure>>}\n */\nexport const get = async ({ agent }, { account, spaces, period, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(AccountUsageCapabilites.get, {\n        with: account,\n        proofs,\n        nonce,\n        nb: {\n            spaces,\n            period: period\n                ? {\n                    from: Math.floor(period.from.getTime() / 1000),\n                    to: Math.ceil(period.to.getTime() / 1000),\n                }\n                : undefined,\n        },\n    });\n    return /** @type {API.Result<API.AccountUsageGetSuccess, API.AccountUsageGetFailure>} */ (receipt.out);\n};\n//# sourceMappingURL=usage.js.map", "import { Storefront } from '@storacha/filecoin-client';\nimport { Filecoin as FilecoinCapabilities } from '@storacha/capabilities';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `filecoin/*` capabilities.\n */\nexport class FilecoinClient extends Base {\n    /**\n     * Offer a Filecoin \"piece\" to the resource.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     *\n     * @param {import('multiformats').UnknownLink} content\n     * @param {import('@storacha/capabilities/types').PieceLink} piece\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async offer(content, piece, options) {\n        const conf = await this._invocationConfig([FilecoinCapabilities.offer.can]);\n        return Storefront.filecoinOffer(conf, content, piece, {\n            ...options,\n            connection: this._serviceConf.filecoin,\n        });\n    }\n    /**\n     * Request info about a content piece in Filecoin deals\n     *\n     * Required delegated capabilities:\n     * - `filecoin/info`\n     *\n     * @param {import('@storacha/capabilities/types').PieceLink} piece\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async info(piece, options) {\n        const conf = await this._invocationConfig([FilecoinCapabilities.info.can]);\n        return Storefront.filecoinInfo(conf, piece, {\n            ...options,\n            connection: this._serviceConf.filecoin,\n        });\n    }\n}\n//# sourceMappingURL=filecoin.js.map", "import * as API from '@storacha/access/types';\nimport { sha256, delegate, Delegation } from '@ucanto/core';\nimport { ed25519 } from '@ucanto/principal';\nimport * as Result from './result.js';\nimport { GrantedAccess } from '@storacha/access/access';\nimport { Base } from './base.js';\nexport class CouponAPI extends Base {\n    /**\n     * Redeems coupon from the the the archive. Throws an error if the coupon\n     * password is invalid or if provided archive is not a valid.\n     *\n     * @param {Uint8Array} archive\n     * @param {object} [options]\n     * @param {string} [options.password]\n     */\n    async redeem(archive, options = {}) {\n        const { agent } = this;\n        const coupon = Result.unwrap(await extract(archive));\n        return Result.unwrap(await redeem(coupon, { ...options, agent }));\n    }\n    /**\n     * Issues a coupon for the given delegation.\n     *\n     * @param {Omit<CouponOptions, 'issuer'>} options\n     */\n    async issue({ proofs = [], ...options }) {\n        const { agent } = this;\n        return await issue({\n            ...options,\n            issuer: agent.issuer,\n            proofs: [...proofs, ...agent.proofs(options.capabilities)],\n        });\n    }\n}\n/**\n * Extracts coupon from the archive.\n *\n * @param {Uint8Array} archive\n * @returns {Promise<API.Result<Coupon, Error>>}\n */\nexport const extract = async (archive) => {\n    const { ok, error } = await Delegation.extract(archive);\n    return ok ? Result.ok(new Coupon({ proofs: [ok] })) : Result.error(error);\n};\n/**\n * Encodes coupon into an archive.\n *\n * @param {Model} coupon\n */\nexport const archive = async (coupon) => {\n    const [delegation] = coupon.proofs;\n    return await Delegation.archive(delegation);\n};\n/**\n * Issues a coupon for the given delegation.\n *\n * @typedef {Omit<import('@ucanto/interface').DelegationOptions<API.Capabilities>, 'audience'> & { password?: string }} CouponOptions\n * @param {CouponOptions} options\n */\nexport const issue = async ({ password = '', ...options }) => {\n    const audience = await deriveSigner(password);\n    const delegation = await delegate({\n        ...options,\n        audience,\n    });\n    return new Coupon({ proofs: [delegation] });\n};\n/**\n * @typedef {object} Model\n * @property {[API.Delegation]} proofs\n */\n/**\n * Redeems granted access with the given agent from the given coupon.\n *\n * @param {Model} coupon\n * @param {object} options\n * @param {API.Agent} options.agent\n * @param {string} [options.password]\n * @returns {Promise<API.Result<GrantedAccess, Error>>}\n */\nexport const redeem = async (coupon, { agent, password = '' }) => {\n    const audience = await deriveSigner(password);\n    const [delegation] = coupon.proofs;\n    if (delegation.audience.did() !== audience.did()) {\n        return Result.error(new RangeError(password === ''\n            ? 'Extracting account requires a password'\n            : 'Provided password is invalid'));\n    }\n    else {\n        const authorization = await delegate({\n            issuer: audience,\n            audience: agent,\n            capabilities: delegation.capabilities,\n            expiration: delegation.expiration,\n            notBefore: delegation.notBefore,\n            proofs: [delegation],\n        });\n        return Result.ok(new GrantedAccess({ agent, proofs: [authorization] }));\n    }\n};\n/**\n * @param {string} password\n */\nconst deriveSigner = async (password) => {\n    const { digest } = await sha256.digest(new TextEncoder().encode(password));\n    return await ed25519.Signer.derive(digest);\n};\nexport class Coupon {\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    get proofs() {\n        return this.model.proofs;\n    }\n    /**\n     *\n     * @param {API.Agent} agent\n     * @param {object} [options]\n     * @param {string} [options.password]\n     */\n    redeem(agent, options = {}) {\n        return redeem(this, { ...options, agent });\n    }\n    archive() {\n        return archive(this);\n    }\n}\n//# sourceMappingURL=coupon.js.map", "import { uploadFile, uploadDirectory, uploadCAR, Receipt, } from '@storacha/upload-client';\nimport { Access as AccessCapabilities, SpaceBlob as BlobCapabilities, SpaceIndex as IndexCapabilities, Upload as UploadCapabilities, Filecoin as FilecoinCapabilities, Space as SpaceCapabilities, } from '@storacha/capabilities';\nimport * as DIDMailto from '@storacha/did-mailto';\nimport { Base } from './base.js';\nimport * as Account from './account.js';\nimport { Space } from './space.js';\nimport { AgentDelegation } from './delegation.js';\nimport { BlobClient } from './capability/blob.js';\nimport { IndexClient } from './capability/index.js';\nimport { UploadClient } from './capability/upload.js';\nimport { SpaceClient } from './capability/space.js';\nimport { SubscriptionClient } from './capability/subscription.js';\nimport { UsageClient } from './capability/usage.js';\nimport { AccountUsageClient } from './capability/account/usage.js';\nimport { AccessClient } from './capability/access.js';\nimport { PlanClient } from './capability/plan.js';\nimport { FilecoinClient } from './capability/filecoin.js';\nimport { CouponAPI } from './coupon.js';\nexport * as Access from './capability/access.js';\nimport * as Result from './result.js';\nexport { AccessClient, BlobClient, FilecoinClient, IndexClient, PlanClient, SpaceClient, SubscriptionClient, UploadClient, UsageClient, AccountUsageClient, };\nexport class Client extends Base {\n    /**\n     * @param {import('@storacha/access').AgentData} agentData\n     * @param {object} [options]\n     * @param {import('./types.js').ServiceConf} [options.serviceConf]\n     * @param {URL} [options.receiptsEndpoint]\n     */\n    constructor(agentData, options) {\n        super(agentData, options);\n        this.capability = {\n            access: new AccessClient(agentData, options),\n            filecoin: new FilecoinClient(agentData, options),\n            index: new IndexClient(agentData, options),\n            plan: new PlanClient(agentData, options),\n            space: new SpaceClient(agentData, options),\n            blob: new BlobClient(agentData, options),\n            subscription: new SubscriptionClient(agentData, options),\n            upload: new UploadClient(agentData, options),\n            usage: new UsageClient(agentData, options),\n            account: {\n                usage: new AccountUsageClient(agentData, options),\n            },\n        };\n        this.coupon = new CouponAPI(agentData, options);\n    }\n    did() {\n        return this._agent.did();\n    }\n    /* c8 ignore start */\n    /**\n     * @deprecated - Use client.login instead.\n     *\n     * Authorize the current agent to use capabilities granted to the passed\n     * email account.\n     *\n     * @param {`${string}@${string}`} email\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @param {Iterable<{ can: import('./types.js').Ability }>} [options.capabilities]\n     */\n    async authorize(email, options) {\n        await this.capability.access.authorize(email, options);\n    }\n    /* c8 ignore stop */\n    /**\n     * @param {Account.EmailAddress} email\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @param {import('@storacha/client/types').AppName} [options.appName]\n     * @param {import('@storacha/client/types').SSORequestParams} [options.sso] - SSO authentication request (all fields required if provided)\n     */\n    async login(email, options = {}) {\n        const account = Result.unwrap(await Account.login(this, email, options));\n        Result.unwrap(await account.save());\n        return account;\n    }\n    /**\n     * List all accounts that agent has stored access to.\n     *\n     * @returns {Record<DIDMailto.DidMailto, Account.Account>} A dictionary with `did:mailto` as keys and `Account` instances as values.\n     */\n    accounts() {\n        return Account.list(this);\n    }\n    /**\n     * Uploads a file to the service and returns the root data CID for the\n     * generated DAG.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     * - `space/blob/add`\n     * - `space/index/add`\n     * - `upload/add`\n     *\n     * @param {import('./types.js').BlobLike} file - File data.\n     * @param {import('./types.js').UploadFileOptions} [options]\n     */\n    async uploadFile(file, options = {}) {\n        const conf = await this._invocationConfig([\n            BlobCapabilities.add.can,\n            IndexCapabilities.add.can,\n            FilecoinCapabilities.offer.can,\n            UploadCapabilities.add.can,\n        ]);\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        return uploadFile(conf, file, options);\n    }\n    /**\n     * Uploads a directory of files to the service and returns the root data CID\n     * for the generated DAG. All files are added to a container directory, with\n     * paths in the file names preserved.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     * - `space/blob/add`\n     * - `space/index/add`\n     * - `upload/add`\n     *\n     * @param {import('./types.js').FileLike[]} files - File data.\n     * @param {import('./types.js').UploadDirectoryOptions} [options]\n     */\n    async uploadDirectory(files, options = {}) {\n        const conf = await this._invocationConfig([\n            BlobCapabilities.add.can,\n            IndexCapabilities.add.can,\n            FilecoinCapabilities.offer.can,\n            UploadCapabilities.add.can,\n        ]);\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        return uploadDirectory(conf, files, options);\n    }\n    /**\n     * Uploads a CAR file to the service.\n     *\n     * The difference between this function and `capability.blob.add` is that\n     * the CAR file is automatically sharded, an index is generated, uploaded and\n     * registered (see `capability.index.add`) and finally an an \"upload\" is\n     * registered, linking the individual shards (see `capability.upload.add`).\n     *\n     * Use the `onShardStored` callback to obtain the CIDs of the CAR file shards.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     * - `space/blob/add`\n     * - `space/index/add`\n     * - `upload/add`\n     *\n     * @param {import('./types.js').BlobLike} car - CAR file.\n     * @param {import('./types.js').UploadOptions} [options]\n     */\n    async uploadCAR(car, options = {}) {\n        const conf = await this._invocationConfig([\n            BlobCapabilities.add.can,\n            IndexCapabilities.add.can,\n            FilecoinCapabilities.offer.can,\n            UploadCapabilities.add.can,\n        ]);\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        return uploadCAR(conf, car, options);\n    }\n    /**\n     * Get a receipt for an executed task by its CID.\n     *\n     * @template {import('./types.js').Capability} C\n     * @template {Record<string, any>} S\n     * @param {import('./types.js').UCANLink<[C]>} taskCid\n     * @param {import('./types.js').ReceiptGetOptions<S> & import('./types.js').Retryable} [options]\n     * @returns {Promise<import('./types.js').InferReceipt<C, S>>}\n     */\n    async getReceipt(taskCid, options) {\n        return Receipt.poll(taskCid, {\n            endpoint: new URL(this._receiptsEndpoint),\n            ...options,\n        });\n    }\n    /**\n     * Return the default provider.\n     */\n    defaultProvider() {\n        return this._agent.connection.id.did();\n    }\n    /**\n     * The current space.\n     */\n    currentSpace() {\n        const agent = this._agent;\n        const id = agent.currentSpace();\n        if (!id)\n            return;\n        const meta = agent.spaces.get(id);\n        return new Space({ id, meta, agent });\n    }\n    /**\n     * Use a specific space.\n     *\n     * @param {import('./types.js').DID} did\n     */\n    async setCurrentSpace(did) {\n        await this._agent.setCurrentSpace(/** @type {`did:key:${string}`} */ (did));\n    }\n    /**\n     * Spaces available to this agent.\n     */\n    spaces() {\n        return [...this._agent.spaces].map(([id, meta]) => {\n            // @ts-expect-error id is not did:key\n            return new Space({ id, meta, agent: this._agent });\n        });\n    }\n    /**\n     * Creates a new space with a given name.\n     * If an account is not provided, the space is created without any delegation and is not saved, hence it is a temporary space.\n     * When an account is provided in the options argument, then it creates a delegated recovery account\n     * by provisioning the space, saving it and then delegating access to the recovery account.\n     * In addition, it authorizes the listed Gateway Services to serve content from the created space.\n     * It is done by delegating the `space/content/serve/*` capability to the Gateway Service.\n     * User can skip the Gateway authorization by setting the `skipGatewayAuthorization` option to `true`.\n     * If no gateways are specified or the `skipGatewayAuthorization` flag is not set, the client will automatically grant access\n     * to the Storacha Gateway by default (https://w3s.link/).\n     *\n     * @typedef {import('./types.js').ConnectionView<import('./types.js').ContentServeService>} ConnectionView\n     *\n     * @typedef {object} SpaceCreateOptions\n     * @property {Account.Account} [account] - The account configured as the recovery account for the space.\n     * @property {Array<ConnectionView>} [authorizeGatewayServices] - The DID Key or DID Web of the Gateway to authorize to serve content from the created space.\n     * @property {boolean} [skipGatewayAuthorization] - Whether to skip the Gateway authorization. It means that the content of the space will not be served by any Gateway.\n     * @property {import('@storacha/access').SpaceAccessType} [access] - Access type for the space - determines client-side encryption behavior.\n     *\n     * @param {string} name - The name of the space to create.\n     * @param {SpaceCreateOptions} [options] - Options for the space creation.\n     * @returns {Promise<import(\"./space.js\").OwnedSpace>} The created space owned by the agent.\n     */\n    async createSpace(name, options = {}) {\n        // Save the space to authorize the client to use the space\n        const { access, account, skipGatewayAuthorization, authorizeGatewayServices, } = options;\n        const space = await this._agent.createSpace(name, { access });\n        if (account) {\n            // Provision the account with the space\n            const provisionResult = await account.provision(space.did());\n            if (provisionResult.error) {\n                throw new Error(`failed to provision account: ${provisionResult.error.message}`, { cause: provisionResult.error });\n            }\n            // Save the space to authorize the client to use the space\n            await space.save();\n            // Create a recovery for the account\n            const recovery = await space.createRecovery(account.did());\n            // Delegate space access to the recovery\n            const delegationResult = await this.capability.access.delegate({\n                space: space.did(),\n                delegations: [recovery],\n            });\n            if (delegationResult.error) {\n                // c8 ignore next 4\n                throw new Error(`failed to authorize recovery account: ${delegationResult.error.message}`, { cause: delegationResult.error });\n            }\n        }\n        // Authorize the listed Gateway Services to serve content from the created space\n        if (skipGatewayAuthorization !== true) {\n            let gatewayServices = authorizeGatewayServices;\n            if (!gatewayServices || gatewayServices.length === 0) {\n                // If no Gateway Services are provided, authorize the Storacha Gateway Service\n                gatewayServices = [this._serviceConf.gateway];\n            }\n            // Save the space to authorize the client to use the space\n            await space.save();\n            for (const serviceConnection of gatewayServices) {\n                await authorizeContentServe(this, space, serviceConnection);\n            }\n        }\n        return space;\n    }\n    /**\n     * Share an existing space with another Storacha account via email address delegation.\n     * Delegates access to the space to the specified email account with the following permissions:\n     * - space/* - for managing space metadata\n     * - blob/* - for managing blobs\n     * - store/* - for managing stores\n     * - upload/*- for registering uploads\n     * - access/* - for re-delegating access to other devices\n     * - filecoin/* - for submitting to the filecoin pipeline\n     * - usage/* - for querying usage\n     * The default expiration is set to infinity.\n     *\n     * @typedef {object} ShareOptions\n     * @property {import('./types.js').ServiceAbility[]} abilities - Abilities to delegate to the delegate account.\n     * @property {number} expiration - Expiration time in seconds.\n     \n     * @param {import(\"./types.js\").EmailAddress} delegateEmail - Email of the account to share the space with.\n     * @param {import('./types.js').SpaceDID} spaceDID - The DID of the space to share.\n     * @param {ShareOptions} [options] - Options for the delegation.\n     *\n     * @returns {Promise<import('./delegation.js').AgentDelegation<any>>} Resolves with the AgentDelegation instance once the space is successfully shared.\n     * @throws {Error} - Throws an error if there is an issue delegating access to the space.\n     */\n    async shareSpace(delegateEmail, spaceDID, options = {\n        abilities: [\n            'space/*',\n            'store/*',\n            'upload/*',\n            'access/*',\n            'usage/*',\n            'filecoin/*',\n        ],\n        expiration: Infinity,\n    }) {\n        const { abilities, ...restOptions } = options;\n        const currentSpace = this.agent.currentSpace();\n        try {\n            // Make sure the agent is using the shared space before delegating\n            await this.agent.setCurrentSpace(spaceDID);\n            // Delegate capabilities to the delegate account to access the **current space**\n            const { root, blocks } = await this.agent.delegate({\n                ...restOptions,\n                abilities,\n                audience: {\n                    did: () => DIDMailto.fromEmail(DIDMailto.email(delegateEmail)),\n                },\n                // @ts-expect-error audienceMeta is not defined in ShareOptions\n                audienceMeta: options.audienceMeta ?? {},\n            });\n            const delegation = new AgentDelegation(root, blocks, {\n                audience: delegateEmail,\n            });\n            const sharingResult = await this.capability.access.delegate({\n                space: spaceDID,\n                delegations: [delegation],\n            });\n            if (sharingResult.error) {\n                throw new Error(`failed to share space with ${delegateEmail}: ${sharingResult.error.message}`, {\n                    cause: sharingResult.error,\n                });\n            }\n            return delegation;\n        }\n        finally {\n            // Reset to the original space if it was different\n            if (currentSpace && currentSpace !== spaceDID) {\n                await this.agent.setCurrentSpace(currentSpace);\n            }\n        }\n    }\n    /* c8 ignore stop */\n    /**\n     * Add a space from a received proof.\n     *\n     * @param {import('./types.js').Delegation} proof\n     */\n    async addSpace(proof) {\n        return await this._agent.importSpaceFromDelegation(proof);\n    }\n    /**\n     * Get all the proofs matching the capabilities.\n     *\n     * Proofs are delegations with an _audience_ matching the agent DID.\n     *\n     * @param {import('./types.js').Capability[]} [caps] - Capabilities to\n     * filter by. Empty or undefined caps with return all the proofs.\n     */\n    proofs(caps) {\n        return this._agent.proofs(caps);\n    }\n    /**\n     * Add a proof to the agent. Proofs are delegations with an _audience_\n     * matching the agent DID.\n     *\n     * @param {import('./types.js').Delegation} proof\n     */\n    async addProof(proof) {\n        await this._agent.addProof(proof);\n    }\n    /**\n     * Get delegations created by the agent for others.\n     *\n     * @param {import('./types.js').Capability[]} [caps] - Capabilities to\n     * filter by. Empty or undefined caps with return all the delegations.\n     */\n    delegations(caps) {\n        const delegations = [];\n        for (const { delegation, meta } of this._agent.delegationsWithMeta(caps)) {\n            delegations.push(new AgentDelegation(delegation.root, delegation.blocks, meta));\n        }\n        return delegations;\n    }\n    /**\n     * Create a delegation to the passed audience for the given abilities with\n     * the _current_ space as the resource.\n     *\n     * @param {import('./types.js').Principal} audience\n     * @param {import('./types.js').ServiceAbility[]} abilities\n     * @param {Omit<import('./types.js').UCANOptions, 'audience'> & { audienceMeta?: import('./types.js').AgentMeta }} [options]\n     */\n    async createDelegation(audience, abilities, options = {}) {\n        const audienceMeta = options.audienceMeta ?? {\n            name: 'agent',\n            type: 'device',\n        };\n        const { root, blocks } = await this._agent.delegate({\n            ...options,\n            abilities,\n            audience,\n            audienceMeta,\n        });\n        return new AgentDelegation(root, blocks, { audience: audienceMeta });\n    }\n    /**\n     * Revoke a delegation by CID.\n     *\n     * If the delegation was issued by this agent (and therefore is stored in the\n     * delegation store) you can just pass the CID. If not, or if the current agent's\n     * delegation store no longer contains the delegation, you MUST pass a chain of\n     * proofs that proves your authority to revoke this delegation as `options.proofs`.\n     *\n     * @param {import('@ucanto/interface').UCANLink} delegationCID\n     * @param {object} [options]\n     * @param {import('@ucanto/interface').Delegation[]} [options.proofs]\n     */\n    async revokeDelegation(delegationCID, options = {}) {\n        return this._agent.revoke(delegationCID, {\n            proofs: options.proofs,\n        });\n    }\n    /**\n     * Removes association of a content CID with the space. Optionally, also removes\n     * association of CAR shards with space.\n     *\n     *  If `shards` option is `true` all shards will be deleted even if there is another upload(s) that\n     * reference same shards, which in turn could corrupt those uploads.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/remove`\n     * - `store/remove`\n     * - `upload/get`\n     * - `upload/remove`\n     *\n     * @param {import('multiformats').UnknownLink} contentCID\n     * @param {object} [options]\n     * @param {boolean} [options.shards]\n     */\n    async remove(contentCID, options = {}) {\n        // Shortcut if there is no request to remove shards\n        if (!options.shards) {\n            // Remove association of content CID with selected space.\n            await this.capability.upload.remove(contentCID);\n            return;\n        }\n        // Get shards associated with upload.\n        const upload = await this.capability.upload.get(contentCID);\n        // Remove shards\n        if (upload.shards?.length) {\n            await Promise.allSettled(upload.shards.map((shard) => this.capability.blob.remove(shard.multihash)));\n        }\n        // Remove association of content CID with selected space.\n        await this.capability.upload.remove(contentCID);\n    }\n}\n/**\n * Authorizes an audience to serve content from the provided space and record egress events.\n * It also publishes the delegation to the content serve service.\n * Delegates the following capabilities to the audience:\n * - `space/content/serve/*`\n *\n * @param {Client} client - The w3up client instance.\n * @param {import('./types.js').OwnedSpace} space - The space to authorize the audience for.\n * @param {import('./types.js').ConnectionView<import('./types.js').ContentServeService>} connection - The connection to the Content Serve Service that will handle, validate, and store the access/delegate UCAN invocation.\n * @param {object} [options] - Options for the content serve authorization invocation.\n * @param {`did:${string}:${string}`} [options.audience] - The Web DID of the audience (gateway or peer) to authorize.\n * @param {number} [options.expiration] - The time at which the delegation expires in seconds from unix epoch.\n */\nexport const authorizeContentServe = async (client, space, connection, options = {}) => {\n    const currentSpace = client.currentSpace();\n    try {\n        // Set the current space to the space we are authorizing the gateway for, otherwise the delegation will fail\n        await client.setCurrentSpace(space.did());\n        /** @type {import('@ucanto/client').Principal<`did:${string}:${string}`>} */\n        const audience = {\n            did: () => options.audience ?? connection.id.did(),\n        };\n        // Grant the audience the ability to serve content from the space, it includes existing proofs automatically\n        const delegation = await client.createDelegation(audience, [SpaceCapabilities.contentServe.can], {\n            expiration: options.expiration ?? Infinity,\n        });\n        // Publish the delegation to the content serve service\n        const accessProofs = client.proofs([\n            { can: AccessCapabilities.access.can, with: space.did() },\n        ]);\n        const verificationResult = await AccessCapabilities.delegate\n            .invoke({\n            issuer: client.agent.issuer,\n            audience,\n            with: space.did(),\n            proofs: [...accessProofs, delegation],\n            nb: {\n                delegations: {\n                    [delegation.cid.toString()]: delegation.cid,\n                },\n            },\n        })\n            .execute(connection);\n        /* c8 ignore next 8 - can't mock this error */\n        if (verificationResult.out.error) {\n            throw new Error(`failed to publish delegation for audience ${audience.did()}: ${verificationResult.out.error.message}`, {\n                cause: verificationResult.out.error,\n            });\n        }\n        return { ok: { ...verificationResult.out.ok, delegation } };\n    }\n    finally {\n        if (currentSpace) {\n            await client.setCurrentSpace(currentSpace.did());\n        }\n    }\n};\n//# sourceMappingURL=client.js.map", "import { abilitiesAsStrings } from '@storacha/capabilities';\nconst setOfAbilities = new Set(abilitiesAsStrings);\n/**\n * Verify and return Abilities.\n *\n * Given a list of strings representing capability names (Abilities),\n * verify that all the strings are valid Abilities and return Abilities[].\n *\n * Abilities[] is still just a list of strings, but this helps us play\n * nice with Typescript.\n *\n * @param {string[]} abilities\n * @returns {import('@storacha/capabilities/types').ServiceAbility[]}\n */\nexport function asAbilities(abilities) {\n    for (const ability of abilities) {\n        if (!setOfAbilities.has(\n        /** @type {import('@storacha/capabilities/types').ServiceAbility} */ (ability))) {\n            throw new Error(`${ability} is not a supported capability`);\n        }\n    }\n    return /** @type {import('@storacha/capabilities/types').ServiceAbility[]} */ (abilities);\n}\n//# sourceMappingURL=ability.js.map", "/**\n * The main entry point for the `@storacha/client` package.\n *\n * Use the static {@link create} function to create a new {@link Client} object.\n *\n * @module\n */\nimport { AgentData } from '@storacha/access/agent';\nimport { StoreIndexedDB } from '@storacha/access/stores/store-indexeddb';\nimport { generate } from '@ucanto/principal/rsa';\nimport { Client } from './client.js';\nexport * as Result from './result.js';\nexport * as Account from './account.js';\nexport * from './ability.js';\nexport { authorizeContentServe } from './client.js';\n/**\n * Create a new w3up client.\n *\n * If no backing store is passed one will be created that is appropriate for\n * the environment.\n *\n * If the backing store is empty, a new signing key will be generated and\n * persisted to the store. In the browser an unextractable RSA key will be\n * generated by default. In other environments an Ed25519 key is generated.\n *\n * If the backing store already has data stored, it will be loaded and used.\n *\n * @type {import('./types.js').ClientFactory}\n */\nexport async function create(options = {}) {\n    const store = options.store ?? new StoreIndexedDB('w3up-client');\n    const raw = await store.load();\n    if (raw) {\n        const data = AgentData.fromExport(raw, { store });\n        if (options.principal && data.principal.did() !== options.principal.did()) {\n            throw new Error(`store cannot be used with ${options.principal.did()}, stored principal and passed principal must match`);\n        }\n        return new Client(data, options);\n    }\n    const principal = options.principal ?? (await generate());\n    const data = await AgentData.create({ principal }, { store });\n    return new Client(data, options);\n}\nexport { Client };\n//# sourceMappingURL=index.js.map"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAC7C;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AA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",
  "names": ["exports", "module", "encode", "MSB", "REST", "MSBALL", "INT", "offset", "exports", "module", "read", "MSB", "REST", "buf", "offset", "exports", "module", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "exports", "module", "exports", "module", "exports", "module", "self", "error", "exports", "original", "require_retry", "exports", "module", "exports", "module", "offset", "index", "params", "exports", "base64", "length", "string", "encode", "buffer", "i", "decode", "offset", "exports", "module", "exports", "module", "buf", "sign", "exports", "utf8", "string", "buffer", "offset", "exports", "module", "alloc", "slice", "size", "SIZE", "offset", "buf", "exports", "module", "sign", "from", "mask", "length", "exports", "src", "keys", "name", "get", "i", "size", "exports", "module", "Writer", "base64", "utf8", "noop", "State", "create", "alloc", "size", "push", "buf", "writeBytes", "fork", "exports", "module", "Writer", "buf", "exports", "module", "utf8", "buffer", "create_array", "create", "buf", "length", "bytes", "skip", "exports", "module", "buffer", "exports", "module", "request", "self", "err", "exports", "exports", "module", "exports", "configure", "require_minimal", "exports", "module", "exports", "module", "root", "undefined", "bytes", "exports", "module", "access_exports", "schema_exports", "space_exports", "fromString", "isExpired", "isTooEarly", "lib_exports", "schema_exports", "delegate", "API", "API", "create", "isLink", "view", "code", "decode", "encode", "format", "name", "parse", "name", "type", "isBuffer", "buf", "bytes", "string", "length", "size", "isBuffer", "buf", "offset", "bytes", "offset", "buf", "set", "encodedSize", "buf", "encodedSize", "compareTokens", "prefix", "length", "buf", "bytes", "encodedSize", "compareTokens", "toToken", "prefix", "length", "toToken", "prefix", "length", "buf", "encodedSize", "toToken", "prefix", "length", "buf", "encodedSize", "buf", "encodedSize", "bytes", "buf", "float", "encodedSize", "ui8a", "offset", "entries", "keys", "length", "buf", "encoder", "size", "decoder", "bytes_exports", "fromString", "toString", "hex", "hexes", "name", "encode", "length", "size", "i", "j", "decode", "string", "buffer", "name", "prefix", "bytes", "text", "decoder", "input", "encode", "decode", "alphabet", "string", "buffer", "pad", "mask", "decode", "encode", "offset", "decode", "buf", "decode", "offset", "code", "code", "digest", "size", "bytes", "decode", "equals", "link", "base", "bytes", "version", "baseCache", "version", "code", "bytes", "digest", "self", "unknown", "equals", "base", "input", "decode", "offset", "length", "size", "prefix", "decoder", "cache", "cid", "buf", "bytes", "encode", "decode", "encode", "text", "decode", "bytes", "DAG_PB_CODE", "digest", "DAG_PB_CODE", "create", "code", "base", "code", "name", "encode", "input", "decode", "encode", "format", "from", "parse", "from", "name", "code", "encode", "input", "digest", "truncate", "parse", "did", "decode", "encode", "bytes", "format", "from", "principal", "code", "buffer", "code", "decode", "encode", "name", "name", "code", "encode", "decode", "BLS12381G1", "BLS12381G2", "create", "decode", "encode", "format", "fromJSON", "parse", "toJSON", "BLS12381G1", "BLS12381G2", "code", "name", "buffer", "size", "toJSON", "offset", "bytes", "decode", "create", "encode", "algorithm", "format", "base", "parse", "fromJSON", "readPrincipal", "readProof", "decode", "input", "name", "context", "read", "error", "create", "code", "encode", "parse", "literal", "buf", "is", "mapSorter", "defaultEncodeOptions", "encode", "float", "decode", "toByteView", "buf", "cidEncoder", "bytes", "undefinedEncoder", "numberEncoder", "encodeOptions", "decodeOptions", "encode", "encodeOptions", "decode", "buf", "toByteView", "decodeOptions", "format", "version", "encode", "toJSON", "decode", "encode", "from", "code", "from", "encode", "context", "decode", "bytes", "code", "format", "encode", "parse", "decode", "from", "decode", "bytes", "parse", "encode", "format", "code", "name", "from", "name", "code", "encode", "ucan", "decode", "bytes", "digest", "create", "parse", "format", "from", "proofs", "version", "algorithm", "API", "cbor_exports", "API", "cbor_exports", "decode", "encode", "link", "write", "encode", "link", "bytes", "create", "write", "store", "encoder", "cbor_exports", "bytes", "digest", "create", "link", "code", "contentType", "createWriter", "decode", "encode", "link", "name", "write", "API", "import_varint", "bytes", "varint", "offset", "length", "v", "entries", "length", "decode", "bytes", "multihash", "version", "blockLength", "bytes", "cborEncoders", "defaultEncodeOptions", "cborEncoders", "defaultEncodeOptions", "encoder", "import_varint", "bytes", "root", "size", "varint", "encode", "offset", "length", "buffer", "bytes", "root", "contentType", "name", "code", "buffer", "createWriter", "encode", "decode", "bytes", "root", "link", "create", "write", "schema_exports", "API", "did_exports", "link_exports", "match", "error", "or", "toString", "from", "read", "API", "API", "fail", "name", "API", "input", "schema", "or", "index", "error", "type", "API", "input", "type", "or", "schema", "Boolean", "base", "number", "error", "prefix", "toString", "struct", "entries", "at", "keys", "TypeError", "indent", "API", "input", "error", "read", "from", "link_exports", "create", "link", "match", "optional", "read", "schema", "API", "API", "code", "version", "error", "schema", "link", "match", "read", "input", "optional", "from", "match", "read", "API", "API", "principal", "decode", "error", "prefix", "schema", "read", "input", "match", "from", "did_exports", "from", "fromBytes", "match", "read", "readBytes", "API", "API", "prefix", "error", "schema", "read", "input", "match", "from", "did", "decode", "readBytes", "fromBytes", "match", "read", "schema", "match", "read", "input", "API", "error", "isLink", "uri", "proofs", "capability", "root", "links", "link", "decode", "store", "variant", "write", "bytes", "encode", "match", "archive", "error", "view", "data", "input", "entries", "create", "obj", "create", "view", "API", "create", "root", "view", "capability", "proofs", "connection", "view", "API", "issue", "view", "API", "view", "root", "decode", "store", "proofs", "ran", "link", "issuer", "parse", "fork", "join", "signature", "encode", "cbor_exports", "issue", "match", "view", "root", "store", "cbor_exports", "execute", "report", "link", "connection", "input", "request", "link", "error", "name", "lib_exports", "delegate", "car_exports", "contentType", "inbound", "outbound", "contentType", "decode", "encode", "API", "contentType", "encode", "decode", "contentType", "decode", "encode", "API", "contentType", "HEADERS", "encode", "decode", "API", "contentType", "decoder", "accept", "type", "encoder", "select", "contentType", "inbound", "outbound", "API", "buffer", "link_exports", "schema_exports", "code", "get", "API", "API", "values", "tuple", "intersection", "API", "context", "li", "capability", "format", "li", "format", "capability", "space", "indent", "li", "schema_exports", "or", "and", "from", "View", "input", "Match", "capability", "group", "match", "proofs", "context", "unknown", "claim", "intersection", "error", "uri", "self", "name", "API", "API", "did_exports", "schema_exports", "fail", "linkOrDigest", "at", "and", "ability", "code", "schema_exports", "link_exports", "claim", "from", "fail", "get", "link_exports", "schema_exports", "add", "all", "get", "list", "remove", "CARLink", "link_exports", "add", "schema_exports", "self", "from", "and", "get", "remove", "list", "all", "schema_exports", "add", "list", "remove", "schema_exports", "fail", "ucan_exports", "API", "schema_exports", "claim", "from", "and", "access_exports", "claim", "delegate", "delegate", "Types", "did_exports", "schema_exports", "and", "claim", "delegate", "fail", "fromString", "fromString", "email", "did", "input", "AppName", "equals", "alloc", "size", "buf", "compare", "concat", "length", "offset", "encode", "decode", "identity_exports", "identity", "identity", "buf", "toString", "fromString", "textEncoder", "textDecoder", "identity_exports", "name", "prefix", "encode", "decode", "string", "buf", "decoder", "encoder", "Types", "bytes", "root", "delegate", "proofs", "space", "fail", "entries", "access", "claim", "request", "space_exports", "generate", "code", "decode", "derive", "encode", "format", "from", "name", "or", "parse", "signatureAlgorithm", "signatureCode", "code", "decode", "derive", "encode", "format", "from", "name", "or", "parse", "signatureAlgorithm", "signatureCode", "mod", "base", "window", "mask", "offset", "offset2", "hex", "bytes", "Signature", "length", "pad", "bytes", "hex", "array", "mod", "number", "gcd", "prefix", "prefix", "mod", "Signature", "Signature", "crypto", "mod", "randomBytes", "buffer", "code", "decode", "encode", "format", "name", "or", "parse", "API", "did", "or", "code", "name", "parse", "did", "decode", "bytes", "algorithm", "format", "principal", "encode", "or", "API", "or", "create", "from", "archive", "name", "withDID", "keys", "code", "name", "signatureAlgorithm", "signatureCode", "PUBLIC_TAG_SIZE", "SIZE", "derive", "from", "keys", "decode", "or", "bytes", "encode", "format", "encoder", "parse", "principal", "decoder", "withDID", "create", "crypto", "isBytes", "abytes", "hexes", "utf8ToBytes", "utf8ToBytes", "abytes", "pad", "buf", "abytes", "view", "isLE", "_32n", "abytes", "buffer", "dataView", "length", "add", "Bl", "view", "offset", "Bl", "add", "sha256", "sha512", "isBytes", "abytes", "input", "anumber", "encode", "decode", "alphabet", "from", "padding", "mask", "bytes", "utils", "base16", "base32", "base32hex", "base64", "base64url", "base58flickr", "alphabet", "prefix", "encode", "isBytes", "decode", "bytes", "hasHexBuiltin", "abytes", "alphabet", "wordlist", "normalize", "abytes", "sha256", "wordlist", "utils", "normalize", "add", "did_exports", "add", "and", "ProviderDID", "AccountDID", "add", "proofs", "access", "algorithm", "generate", "name", "access", "derive", "space", "spaceAccess", "toCapabilities", "entries", "fail", "proofs", "principal", "input", "SpaceDID", "schema_exports", "capability", "AccountDID", "add", "isExpired", "isTooEarly", "capability", "uri", "code", "decode", "from", "generate", "name", "or", "signatureAlgorithm", "signatureCode", "code", "bytes", "offset", "tag", "size", "encodingLength", "encodeTo", "decode", "API", "length", "bytes", "offset", "input", "tag", "readInt", "read", "encode", "decode", "info", "offset", "API", "decode", "info", "offset", "encode", "API", "API", "encode", "VERSION", "decode", "readInt", "name", "code", "signatureCode", "signatureAlgorithm", "KEY_SIZE", "generate", "size", "decode", "bytes", "from", "keys", "did", "or", "encode", "parse", "code", "signatureCode", "signatureAlgorithm", "buffer", "create", "withDID", "or", "schema_exports", "and", "equals", "schema_exports", "claim", "cache", "and", "fail", "ProviderDID", "did_exports", "and", "get", "ProviderDID", "did_exports", "get", "and", "console", "schema_exports", "error", "Provider", "did_exports", "add", "schema_exports", "and", "remove", "list", "upload", "link_exports", "and", "store", "ProviderDID", "get", "list", "ProviderDID", "did_exports", "get", "schema_exports", "and", "list", "schema_exports", "schema_exports", "claim", "from", "and", "schema_exports", "claim", "from", "and", "schema_exports", "claim", "from", "and", "schema_exports", "claim", "from", "and", "space_exports", "schema_exports", "add", "index", "index", "add", "schema_exports", "and", "get", "get", "and", "did_exports", "schema_exports", "schema_exports", "and", "schema_exports", "add", "get", "list", "remove", "schema_exports", "add", "remove", "fail", "list", "get", "and", "blob", "schema_exports", "allocate", "and", "blob", "allocate", "schema_exports", "link_exports", "claim", "from", "and", "accept", "schema_exports", "claim", "from", "and", "usage_exports", "get", "get", "schema_exports", "and", "fail", "equals", "claim", "cache", "add", "get", "remove", "list", "upload", "store", "blob", "allocate", "accept", "index", "array", "data", "init", "did", "ucan_exports", "proofs", "isExpired", "schema_exports", "access", "bytes", "space", "email", "delegate", "proofs", "outbound", "init", "values", "isExpired", "isTooEarly", "delegation", "ucan_exports", "proofs", "name", "access", "generate", "space", "allows", "did", "error", "db", "store", "error", "digest_exports", "MAX_HEIGHT", "MAX_PAYLOAD_SIZE", "code", "create", "digest", "name", "from", "bytes", "empty", "code", "digest", "name", "size", "sha256", "name", "code", "size", "Digest", "bytes", "digest", "size", "sha256", "Digest", "code", "digest", "empty", "split", "offset", "size", "size", "height", "height", "padding", "size", "fromHeight", "height", "digest_exports", "TAG_SIZE", "code", "fromBytes", "fromPiece", "name", "padding", "toBytes", "name", "code", "TAG_SIZE", "fromHeight", "fromPiece", "padding", "height", "root", "size", "offset", "bytes", "Digest", "fromBytes", "toBytes", "digest", "tag", "length", "name", "code", "MAX_HEIGHT", "MAX_PAYLOAD_SIZE", "fromHeight", "digest", "Hasher", "create", "bytes", "fromBytes", "buffer", "offset", "split", "tree", "build", "height", "root", "padding", "TAG_SIZE", "size", "length", "index", "storefront_exports", "connection", "filecoinAccept", "filecoinInfo", "filecoinOffer", "filecoinSubmit", "encoder", "decoder", "response_exports", "contentType", "encode", "API", "contentType", "HEADERS", "encode", "request_exports", "contentType", "decode", "API", "contentType", "decode", "contentType", "request_exports", "inbound", "contentType", "request_exports", "response_exports", "parse", "connection", "car_exports", "filecoinOffer", "proofs", "content", "filecoinSubmit", "filecoinAccept", "filecoinInfo", "connection", "car_exports", "connection", "car_exports", "connection", "car_exports", "blob_exports", "add", "get", "list", "remove", "replicate", "error", "input", "retry", "parse", "connection", "car_exports", "get", "get", "car_exports", "receipt", "root", "fork", "allocate", "accept", "receipt", "add", "proofs", "digest", "bytes", "size", "connection", "blob", "get", "proofs", "connection", "input", "ability", "digest", "list", "proofs", "connection", "input", "ability", "size", "remove", "proofs", "connection", "input", "ability", "digest", "replicate", "proofs", "blob", "connection", "input", "ability", "add", "add", "proofs", "index", "connection", "input", "ability", "upload_exports", "add", "get", "list", "remove", "add", "proofs", "root", "connection", "input", "ability", "get", "proofs", "root", "connection", "input", "ability", "list", "proofs", "connection", "input", "ability", "size", "remove", "proofs", "root", "connection", "input", "ability", "codec_exports", "code", "decode", "encode", "encodeLink", "name", "textDecoder", "decodeVarint", "bytes", "offset", "index", "link", "links", "textEncoder", "link", "bytes", "size", "index", "offset", "base", "textEncoder", "link", "Hash", "prepare", "validate", "toByteView", "buf", "code", "encode", "validate", "link", "decode", "bytes", "buf", "toByteView", "$protobuf", "Data", "encode", "decode", "toJSON", "values", "UnixTime", "Metadata", "EMPTY", "code", "name", "links", "encode", "prepare", "content", "entries", "readInt", "encodeLink", "encode", "root", "decode", "bytes", "type", "links", "links", "length", "link", "size", "root", "name", "content", "EMPTY", "input", "error", "name", "effect", "effects", "tag", "tag", "group", "conclude", "error", "conclude", "self", "group", "fork", "from", "index", "join", "fail", "BLANK", "init", "none", "empty", "slice", "buffer", "empty", "offset", "get", "iterate", "bytes", "panic", "EMPTY_BUFFER", "EMPTY", "open", "config", "empty", "write", "bytes", "split", "EMPTY", "close", "buffer", "offset", "size", "EMPTY", "input", "has", "link", "links", "BLANK", "EMPTY", "keys", "has", "link", "EMPTY", "BLANK", "write", "link", "close", "config", "open", "bytes", "panic", "root", "fork", "join", "content", "encoder", "asUint8Array", "EMPTY_BUFFER", "links", "buffer", "name", "name", "open", "write", "close", "EMPTY", "flush", "layout", "height", "top", "root", "index", "length", "defaults", "codec_exports", "config", "code", "name", "create", "defaults", "write", "view", "bytes", "close", "panic", "effect", "defaults", "create", "set", "view", "name", "link", "remove", "close", "entries", "bytes", "digest", "code", "fork", "api_exports", "and", "empty", "from", "fromBytes", "get", "or", "set", "size", "toBytes", "api_exports", "empty", "size", "from", "set", "bitField", "index", "get", "and", "or", "toBytes", "fromBytes", "bytes", "murmur", "configure", "bitWidth", "mask", "at", "from", "config", "create", "notFound", "fork", "entries", "name", "index", "offset", "create", "config", "get", "notFound", "offset", "index", "set", "remove", "config", "offset", "index", "fork", "entries", "import_murmurhash3js_revisited", "number", "bytes", "from", "input", "mur", "bytes_exports", "utf8", "bytes", "configure", "bitWidth", "at", "offset", "from", "mask", "api_exports", "and", "empty", "from", "fromBytes", "get", "or", "popcount", "set", "size", "toBytes", "unset", "empty", "size", "from", "index", "bytes", "set", "unset", "get", "toBytes", "fromBytes", "popcount", "offset", "byte", "or", "and", "configure", "bitWidth", "from", "entries", "has", "get", "notFound", "config", "create", "root", "set", "remove", "utf8", "hash64", "bytes", "configure", "bitWidth", "at", "read", "from", "digest", "bitCount", "offset", "configure", "builder", "from", "entries", "bytes", "offset", "iterate", "root", "config", "size", "prefix", "index", "links", "base", "get", "bytes", "defaults", "create", "asWritable", "close", "view", "entries", "root", "iterate", "bytes", "code", "fork", "from", "name", "link", "set", "remove", "builder", "get", "has", "createWriter", "defaults", "close", "view", "create", "encodeFile", "blob", "collect", "createWriter", "name", "create", "link", "encodeDirectory", "readHeader", "length", "decode", "readCid", "bytes", "multihash", "version", "readBlockHead", "blockLength", "offset", "index", "limitReader", "bytesReader", "read", "version", "bytes", "fromBytes", "fromBytes", "bytes", "bytesReader", "decoder", "version", "import_varint", "encode", "varint", "bytes", "create", "drainer", "encoder", "bytes", "bytesReader", "readHeader", "create", "root", "import_varint", "code", "root", "headerLength", "encode", "varint", "error", "decode", "archive", "create", "extract", "view", "cache", "digest", "entries", "schema_exports", "extract", "archive", "code", "view", "root", "version", "decode", "create", "digest", "offset", "length", "content", "slice", "index", "compare", "bytes", "encode", "cid", "index", "offset", "buf", "length", "bytes", "concat", "list", "radix", "skip", "view", "alloc", "equals", "MSB", "REST", "MSBALL", "INT", "encode", "offset", "decode", "buf", "CIDV0_BYTES", "buffer", "offset", "length", "bytes", "decode", "version", "getMultihashLength", "create", "encodeHeader", "encode", "bytes", "root", "index", "create", "blockLength", "headerLength", "slice", "root", "encode", "bytes", "encodeFile", "entries", "size", "encodeDirectory", "blocks", "decode", "configure", "root", "digest", "conf", "add", "create", "code", "content", "storefront_exports", "version", "ability", "input", "index", "slice", "indexLink", "parse", "car_exports", "proofs", "Account", "list", "types_exports", "fromString", "fail", "API", "ok", "error", "email", "request", "access", "input", "claim", "delegate", "access_exports", "createPendingAccessRequest", "spaceAccess", "accountAccess", "get", "set", "createAdminSession", "proofs", "list", "proofs", "list", "proofs", "access", "AccountDID", "account", "Account", "email", "session", "request", "accountAccess", "error", "ok", "createPendingAccessRequest", "space", "input", "add", "get", "set", "createAdminSession", "space", "report", "proofs", "space", "now", "report", "root", "blob", "bytes", "digest", "blob_exports", "index", "space_exports", "root", "upload_exports", "space", "egressRecord", "bytes", "proofs", "get", "usage_exports", "proofs", "content", "storefront_exports", "archive", "extract", "proofs", "issue", "ok", "error", "digest", "email", "list", "space_exports", "did", "name", "access", "space", "root", "upload", "connection", "ability", "create", "store", "data", "principal", "generate"]
}
